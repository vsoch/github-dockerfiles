# @title README
# @markup kramdown


- {file:docs/changes.md Changelog}
- {file:docs/migrating.md Migration guides}

# Important documents

The following is a list of important documents to read.

- {file:docs/bot_options.md Bot options}
- {file:docs/common_tasks.md Common Tasks}
- {file:docs/common_mistakes.md Common mistakes}
- {Cinch::DCC DCC}
- {file:docs/encodings.md Encodings}
- {file:docs/logging.md Logging}
- {Cinch::SASL SASL}
- {Cinch::Formatting Formatting messages}
- {file:docs/events.md Events}
# Tests to check if all the README examples work.
require File.expand_path('../helper', __FILE__)

class ReadmeTest < Minitest::Test
  example do
    mock_app { get('/') { 'Hello world!' } }
    get '/'
    assert_body 'Hello world!'
  end

  section "Routes" do
    example do
      mock_app do
        get('/') { ".. show something .." }

        post('/') { ".. create something .." }

        put('/') { ".. replace something .." }

        patch('/') { ".. modify something .." }

        delete('/') { ".. annihilate something .." }

        options('/') { ".. appease something .." }

        link('/') { ".. affiliate something .." }

        unlink('/') { ".. separate something .." }
      end

      get '/'
      assert_body '.. show something ..'

      post '/'
      assert_body '.. create something ..'

      put '/'
      assert_body '.. replace something ..'

      patch '/'
      assert_body '.. modify something ..'

      delete '/'
      assert_body '.. annihilate something ..'

      options '/'
      assert_body '.. appease something ..'

      link '/'
      assert_body '.. affiliate something ..'

      unlink '/'
      assert_body '.. separate something ..'
    end

    example do
      mock_app do
        get('/hello/:name') do
          # matches "GET /hello/foo" and "GET /hello/bar"
          # params[:name] is 'foo' or 'bar'
          "Hello #{params[:name]}!"
        end
      end

      get '/hello/foo'
      assert_body 'Hello foo!'

      get '/hello/bar'
      assert_body 'Hello bar!'
    end

    example do
      mock_app { get('/hello/:name') { |n| "Hello #{n}!" } }

      get '/hello/foo'
      assert_body 'Hello foo!'

      get '/hello/bar'
      assert_body 'Hello bar!'
    end

    example do
      mock_app do
        get('/say/*/to/*') do
          # matches /say/hello/to/world
          params[:splat].inspect # => ["hello", "world"]
        end

        get('/download/*.*') do
          # matches /download/path/to/file.xml
          params[:splat].inspect # => ["path/to/file", "xml"]
        end
      end

      get "/say/hello/to/world"
      assert_body '["hello", "world"]'

      get "/download/path/to/file.xml"
      assert_body '["path/to/file", "xml"]'
    end

    example do
      mock_app do
        get(%r{/hello/([\w]+)}) {
          "Hello, #{params[:captures].first}!"
        }
      end

      get '/hello/foo'
      assert_body 'Hello, foo!'

      get '/hello/bar'
      assert_body 'Hello, bar!'
    end

    example do
      mock_app do
        get( %r{/hello/([\w]+)}) { |c|
          "Hello, #{c}!"
        }
      end

      get '/hello/foo'
      assert_body 'Hello, foo!'

      get '/hello/bar'
      assert_body 'Hello, bar!'
    end
  end
end
test_truststore is a trust store which has trusted the cacert.pem certificate

localhost.pem is a server certificate signed by our test CA

We can test custom trust stores by:

1. Starting a server which uses localhost.pem/localhost.key to serve SSL
2. Trusting ca_cert.pem (via the test_truststore)

And then verifying that SSL operations complete successfully.

The test_truststore password is `test123`

You should never use these certificates or keys for anything other than testing Manticore's SSL behavior.Archive::Tar::Minitar README
============================
Archive::Tar::Minitar is a pure-Ruby library and command-line utility that
provides the ability to deal with POSIX tar(1) archive files. The
implementation is based heavily on Mauricio Ferna'ndez's implementation in
rpa-base, but has been reorganised to promote reuse in other projects.
Antoine Toulme forked the original project on rubyforge to place it on github, under
http://www.github.com/atoulme/minitar

This release is version 0.5.2, offering a Ruby 1.9 compatibility bugfix over
version 0.5.1. The library can only handle files and directories at this
point. A future version will be expanded to handle symbolic links and hard
links in a portable manner. The command line utility, minitar, can only create
archives, extract from archives, and list archive contents.

Using this library is easy. The simplest case is:

  require 'zlib'
  require 'archive/tar/minitar'
  include Archive::Tar

    # Packs everything that matches Find.find('tests')
  File.open('test.tar', 'wb') { |tar| Minitar.pack('tests', tar) }
    # Unpacks 'test.tar' to 'x', creating 'x' if necessary.
  Minitar.unpack('test.tar', 'x')

A gzipped tar can be written with:

    tgz = Zlib::GzipWriter.new(File.open('test.tgz', 'wb'))
      # Warning: tgz will be closed!
    Minitar.pack('tests', tgz)

    tgz = Zlib::GzipReader.new(File.open('test.tgz', 'rb'))
      # Warning: tgz will be closed!
    Minitar.unpack(tgz, 'x')

As the case above shows, one need not write to a file. However, it will
sometimes require that one dive a little deeper into the API, as in the case
of StringIO objects. Note that I'm not providing a block with Minitar::Output,
as Minitar::Output#close automatically closes both the Output object and the
wrapped data stream object.

  begin
    sgz = Zlib::GzipWriter.new(StringIO.new(""))
    tar = Output.new(sgz)
    Find.find('tests') do |entry|
      Minitar.pack_file(entry, tar)
    end
  ensure
      # Closes both tar and sgz.
    tar.close
  end

Copyright
=========
# Copyright 2004 Mauricio Julio Ferna'ndez Pradier and Austin Ziegler
#
# This program is based on and incorporates parts of RPA::Package from
# rpa-base (lib/rpa/package.rb and lib/rpa/util.rb) by Mauricio and has been
# adapted to be more generic by Austin.
#
# 'minitar' contains an adaptation of Ruby/ProgressBar by Satoru
# Takabayashi <satoru@namazu.org>, copyright 2001 - 2004.
#
# This program is free software. It may be redistributed and/or modified
# under the terms of the GPL version 2 (or later) or Ruby's licence.
# 
# $Id$
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# edn-ruby

[![Build Status](https://secure.travis-ci.org/relevance/edn-ruby.png)](http://travis-ci.org/relevance/edn-ruby)


&copy; 2012 Relevance Inc

**edn-ruby** is a Ruby library to read and write EDN (extensible data notation), a subset of Clojure used for transferring data between applications, much like JSON, YAML, or XML.

## Installation

Add this line to your application's Gemfile:

    gem 'edn'

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install edn

## Usage

To read a string of EDN:

```ruby
EDN.read('[1 2 {:foo "bar"}]')
```

Alternatively you can pass in an IO instance, for
example an open file:

```ruby
File.open("data.edn") do |f|
  data = EDN.read(f)
  # Do something with data
end
```

By default EDN.read will throw an execption
if you try to read past the end of the data:

```ruby
EDN.read("")   # Boom!
```

Alternatively, the `EDN.read` method takes an optional
parameter, which is the value to return
when it hits the end of data:

```ruby
EDN.read("", :nomore)

#=> :nomore
```

There is no problem using `nil` as an eof value.

### EDN::Reader

You can also do things in a more object oriented way by
creating instances of `EDN::Reader`:

```ruby
r = EDN::Reader.new('[1 2 3] {:a 1 :b 2}')

r.read #=> [1, 2, 3]
r.read #=> {:a => 1, :b => 2}
r.read #=> RuntimeError: Unexpected end of file
```

`EDN:Reader` will also take an IO instance:

```ruby
r = EDN::Reader.new(open("data.edn"))

r.read  # Read the first form from the file.
r.read  # Read the second form from the file.
r.read  # Read the third from from the file.
```

You can also iterate through the forms with `each`:

```ruby
r = EDN::Reader.new('[1 2 3] {:a 1 :b 2}')

r.each do |form|
  p form
end

#=> [1, 2, 3]
#=> {:a => 1, :b => 2}
```

Note that in contrast to earlier versions of this gem,
EDN::Reader is no longer `Enumerable`.

Like `EDN.read`, `Reader.read` also takes an optional
parameter, which is returned when there is no more data:

```ruby
r = EDN::Reader.new('1 2 3')
r.read(:eof)  # returns 1
r.read(:eof)  # returns 2
r.read(:eof)  # returns 3
r.read(:eof)  # returns :eof
```

### Converting Ruby data to EDN

To convert a data structure to an EDN string:

```ruby
data.to_edn
```

By default, this will work for strings, symbols, numbers, arrays, hashes, sets, nil, Time, and boolean values.

### Value Translations

Note that EDN uses its own terminology for the types of objects it represents
and in some cases those types not map cleanly to Ruby.

In EDN, you have _keywords_, which look like Ruby symbols and have the same meaning and
purpose. These are converted to Ruby symbols.

You also have EDN _symbols_, which generally reflect variable names, but have
several purposes. We parse these and return `EDN::Type::Symbol` values for them,
as they don't map to anything built into Ruby. To create an EDN symbol in Ruby,
call `EDN::Type::Symbol.new` or `EDN.symbol` with a string argument, or use the
convenience unary operator `~` like so: `~"elf/rings"`.

EDN also has _vectors_, which map to Ruby arrays, and _lists_, which are linked lists
in Clojure. We map EDN lists to `EDN::Type::List` values, which are type-compatible with
arrays. To create an EDN list in Ruby, call `EDN::Type::List.new` or `EDN.list`
with all arguments to go in the list. If you have an array, you will use the splat
operator, like so: `EDN.list(*[1, 2, 3])`. You can also use the `~` unary
operator like so: `~[1, 2, 3]`.

EDN also has character types, but Ruby does not. These are converted into one-character strings.

### Tagged Values

The interesting part of EDN is the _extensible_ part.
Data can be be _tagged_ to coerce interpretation of
it to a particular data type. An example of a tagged data element:

```
#wolf/pack {:alpha "Greybeard" :betas ["Frostpaw" "Blackwind" "Bloodjaw"]}
```

The tag (`#wolf/pack`) will tell any consumers of this data
to use a data type registered to handle `wolf/pack` to represent this data.

The rules for tags from the [EDN README][README] should be followed. In short, custom tags should have a prefix (the part before the `/`) designating the user that created them or context they are used in. Non-prefixed tags are reserved for built-in tags.

There are two tags built in by default: `#uuid`, used for UUIDs, and `#inst`, used for an instant in time. In `edn-ruby`, `#inst` is converted to a Time, and Time values are tagged as `#inst`. There is not a UUID data type built into Ruby, so `#uuid` is converted to an instance of `EDN::Type::UUID`.

Tags that are not registered generate a struct of the type `EDN::Type::Unknown` with the methods `tag` and `value`.

### Registering a New Tag For Reading

To register a tag for reading, call the method `EDN.register` with a tag and one of the following:

- A block that accepts data and returns a value.
- A lambda that accepts data and returns a value.
- A class that has an `initialize` method that accepts data.

Examples:

```ruby
EDN.register("clinton/uri") do |uri|
  URI(uri)
end

EDN.register("clinton/date", lambda { |date_array| Date.new(*date_array) })

class Dog
  def initialize(name)
    @name = name
  end
end

EDN.register("clinton/dog", Dog)
```

### Writing Tags

Writing tags should be done as part of the class's `.to_edn` method, like so:

```ruby
class Dog
  def to_edn
    ["#clinton/dog", @name.to_edn].join(" ")
  end
end
```

`EDN` provides a helper method, `EDN.tagout`:

```ruby
class Dog
  def to_edn
    EDN.tagout("clinton/dog", @name)
  end
end
```

This method calls `.to_edn` on the second argument and joins the arguments appropriately.

Other examples are:
```
EDN.tagout("wolf/pack", {:alpha=>"Greybeard", :betas=>["Frostpaw", "Blackwind", "Bloodjaw"]})
 => "#wolf/pack {:alpha \"Greybeard\", :betas [\"Frostpaw\" \"Blackwind\" \"Bloodjaw\"]}"

class Range
  def to_edn
    EDN.tagout("ruby/range", [self.begin, self.end, self.exclude_end?])
  end
end

(0..9).to_edn
=> "#ruby/range [0 9 false]"
```


## Metadata

Certain elements of EDN can have *metadata*. Metadata is a map of values about the element, which must follow specific rules.

* Only symbols, lists, vectors, maps, and sets can have metadata. Tagged elements *cannot* have metadata.
* Metadata keys must be symbols, keywords, or strings.

Metadata can be expressed in one of the following three ways:

* Via a map. The element is prefixed with a map which has a caret (`^`) prefixed to it, like so: `^{:doc "This is my vector" :rel :temps} [98.6 99.7]`.
* Via a keyword. The element is prefixed with a keyword, also prefixed by a caret: `^:awesome #{1 2 \c}`. This results in the key `:awesome` being set to `true`, as if the metadata was: `^{:awesome true} #{1 2 \c}`.
* Via a symbol. The element is prefixed with a symbol, also prefixed by a caret: `^Boolean "true"`. This results in the key `:tag` being set to the symbol, as if the metadata was: `^{:tag Boolean} "true"`. This is used in Clojure to indicate the Java type of the element. In other EDN implementations, it may be ignored or used differently.

More than one piece of metadata can be applied to an element. Metadata is applied to the next element appearing after it, so in the case of `^:foo ^{:bar false} [1 2]`, the metadata would be, in total, `^{:foo true, :bar false}`. Note that `^:foo` is applied to the element `[1 2]` with the metadata `^{:bar false}` applied to it. Because of this, key collisions are resolved *right-to-left*.

## Contributors

* Clinton N. Dreisbach (@crnixon)
* Michael Ficarra (@michaelficarra)
* Andrew Forward (@aforward)
* Gabriel Horner (@cldwalker)
* Russ Olsen (@russolsen)

## Contributing

1. Fork it
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Added some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create new Pull Request

[edn]: https://github.com/edn-format/edn
[README]: https://github.com/edn-format/edn/blob/master/README.md
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# ruby-ffi https://wiki.github.com/ffi/ffi [![Build Status](https://travis-ci.org/ffi/ffi.png?branch=master)](https://travis-ci.org/ffi/ffi)

## Description

Ruby-FFI is a ruby extension for programmatically loading dynamic
libraries, binding functions within them, and calling those functions
from Ruby code. Moreover, a Ruby-FFI extension works without changes
on Ruby and JRuby. [Discover why you should write your next extension
using Ruby-FFI](https://wiki.github.com/ffi/ffi/why-use-ffi).

## Features/problems

* Intuitive DSL
* Supports all C native types
* C structs (also nested), enums and global variables
* Callbacks from C to ruby
* Automatic garbage collection of native memory

## Synopsis

```ruby
require 'ffi'

module MyLib
  extend FFI::Library
  ffi_lib 'c'
  attach_function :puts, [ :string ], :int
end

MyLib.puts 'Hello, World using libc!'
```

For less minimalistic and more sane examples you may look at:

* the samples/ folder
* the examples on the [wiki](https://wiki.github.com/ffi/ffi)
* the projects using FFI listed on this page (https://wiki.github.com/ffi/ffi/projects-using-ffi)

## Requirements

You need a sane building environment in order to compile the extension.
At a minimum, you will need:
* A C compiler (e.g. Xcode on OSX, gcc on everything else)
* libffi development library - this is commonly in the libffi-dev or libffi-devel

## Installation

From rubygems:

    [sudo] gem install ffi

or from the git repository on github:

    git clone git://github.com/ffi/ffi.git
    cd ffi
    rake gem:install

## License

The ffi library is covered by the BSD license, also see the LICENSE file.
The specs are shared with Rubyspec and are licensed by the same license
as Rubyspec, see the LICENSE.SPECS file.

## Credits

The following people have submitted code, bug reports, or otherwise contributed to the success of this project:

* Alban Peignier <alban.peignier@free.fr>
* Aman Gupta <aman@tmm1.net>
* Andrea Fazzi <andrea.fazzi@alcacoop.it>
* Andreas Niederl <rico32@gmx.net>
* Andrew Cholakian <andrew@andrewvc.com>
* Antonio Terceiro <terceiro@softwarelivre.org>
* Brian Candler <B.Candler@pobox.com>
* Brian D. Burns <burns180@gmail.com>
* Bryan Kearney <bkearney@redhat.com>
* Charlie Savage <cfis@zerista.com>
* Chikanaga Tomoyuki <nagachika00@gmail.com>
* Hongli Lai <hongli@phusion.nl>
* Ian MacLeod <ian@nevir.net>
* Jake Douglas <jake@shiftedlabs.com>
* Jean-Dominique Morani <jdmorani@mac.com>
* Jeremy Hinegardner <jeremy@hinegardner.org>
* Jesús García Sáez <blaxter@gmail.com>
* Joe Khoobyar <joe@ankhcraft.com>
* Jurij Smakov <jurij@wooyd.org>
* KISHIMOTO, Makoto <ksmakoto@dd.iij4u.or.jp>
* Kim Burgestrand <kim@burgestrand.se>
* Lars Kanis <kanis@comcard.de>
* Luc Heinrich <luc@honk-honk.com>
* Luis Lavena <luislavena@gmail.com>
* Matijs van Zuijlen <matijs@matijs.net>
* Matthew King <automatthew@gmail.com>
* Mike Dalessio <mike.dalessio@gmail.com>
* NARUSE, Yui <naruse@airemix.jp>
* Park Heesob <phasis@gmail.com>
* Shin Yee <shinyee@speedgocomputing.com>
* Stephen Bannasch <stephen.bannasch@gmail.com>
* Suraj N. Kurapati <sunaku@gmail.com>
* Sylvain Daubert <sylvain.daubert@laposte.net>
* Victor Costan
* beoran@gmail.com
* ctide <christide@christide.com>
* emboss <Martin.Bosslet@googlemail.com>
* hobophobe <unusualtears@gmail.com>
* meh <meh@paranoici.org>
* postmodern <postmodern.mod3@gmail.com>
* wycats@gmail.com <wycats@gmail.com>
* Wayne Meissner <wmeissner@gmail.com>
Slop
====

Slop is a simple option parser with an easy to remember syntax and friendly API.
API Documentation is available [here](http://leejarvis.github.com/rdoc/slop/).

[![Build Status](https://travis-ci.org/leejarvis/slop.png?branch=master)](http://travis-ci.org/leejarvis/slop)

Usage
-----

```ruby
opts = Slop.parse do
  banner 'Usage: foo.rb [options]'

  on 'name=', 'Your name'
  on 'p', 'password', 'An optional password', argument: :optional
  on 'v', 'verbose', 'Enable verbose mode'
end

# if ARGV is `--name Lee -v`
opts.verbose?  #=> true
opts.password? #=> false
opts[:name]    #=> 'lee'
opts.to_hash   #=> {:name=>"Lee", :password=>nil, :verbose=>true}
```

Installation
------------

    gem install slop

Printing Help
-------------

Slop attempts to build a good looking help string to print to your users. You
can see this by calling `opts.help` or simply `puts opts`.

Configuration Options
---------------------

All of these options can be sent to `Slop.new` or `Slop.parse` in Hash form.

| Option | Description | Default/Example |
| ------ | ----------- | --------------- |
| strict | Enable strict mode. Slop will raise an `InvalidOptionError` for unkown options. | `false` |
| help   | Automatically add the `--help` option. | `false` |
| banner | Set the help banner text. | `nil` |
| ignore_case | When enabled, `-A` will look for the `-a` option if `-A` does not exist. | `false` |
| autocreate | Autocreate options on the fly. | `false` |
| arguments | Force all options to expect arguments. | `false` |
| optional_arguments | Force all options to accept optional arguments. | `false` |
| multiple_switches | When disabled, Slop will parse `-abc` as the option `a` with the argument `bc` rather than 3 separate options. | `true` |

Lists
-----

```ruby
opts = Slop.parse do
  on :list=, as: Array
end
# ruby run.rb --list one,two
opts[:list] #=> ["one", "two"]
# ruby run.rb --list one,two --list three
opts[:list] #=> ["one", "two", "three"]
```

You can also specify a delimiter and limit.

```ruby
opts = Slop.parse do
  on :list=, as: Array, delimiter: ':', limit: 2
end
# ruby run.rb --list one:two:three
opts[:list] #=> ["one", "two:three"]
```

Ranges
------

```ruby
opts = Slop.parse do
  on :range=, as: Range
end
# ruby run.rb --range 1..10
opts[:range] #=> 1..10
# ruby run.rb --range 1...10
opts[:range] #=> 1...10
# ruby run.rb --range 1-10
opts[:range] #=> 1..10
# ruby run.rb --range 1,10
opts[:range] #=> 1..10
```

Autocreate
----------

Slop has an 'autocreate' feature. This feature is intended to create
options on the fly, without having to specify them yourself. In some case,
using this code could be all you need in your application:

```ruby
# ruby run.rb --foo bar --baz --name lee
opts = Slop.parse(autocreate: true)
opts.to_hash #=> {:foo=>"bar", :baz=>true, :name=>"lee"}
opts.fetch_option(:name).expects_argument? #=> true
```

Commands
--------

Slop supports git style sub-commands, like so:

```ruby
opts = Slop.parse do
  on '-v', 'Print the version' do
    puts "Version 1.0"
  end

  command 'add' do
    on :v, :verbose, 'Enable verbose mode'
    on :name=, 'Your name'

    run do |opts, args|
      puts "You ran 'add' with options #{opts.to_hash} and args: #{args.inspect}"
    end
  end
end

# ruby run.rb -v
#=> Version 1.0
# ruby run.rb add -v foo --name Lee
#=> You ran 'add' with options {:verbose=>true,:name=>"Lee"} and args ["foo"]
opts.to_hash(true) # Pass true to tell Slop to merge sub-command option values.
# => { :v => nil, :add => { :v => true, :name => "Lee" } }
```

Remaining arguments
-------------------

The *parse!*  method will remove any options and option arguments from the original Array:

```ruby
# restarguments.rb
opts = Slop.parse! do
  on :foo
end
```

Example:

```
ruby restarguments.rb --foo bar
```

```
opts.to_hash = { :foo => true }

ARGV #=> ["bar"]
```

Woah woah, why you hating on OptionParser?
------------------------------------------

I'm not, honestly! I love OptionParser. I really do, it's a fantastic library.
So why did I build Slop? Well, I find myself using OptionParser to simply
gather a bunch of key/value options, usually you would do something like this:

```ruby
require 'optparse'

things = {}

opt = OptionParser.new do |opt|
  opt.on('-n', '--name NAME', 'Your name') do |name|
    things[:name] = name
  end

  opt.on('-a', '--age AGE', 'Your age') do |age|
    things[:age] = age.to_i
  end

  # you get the point
end

opt.parse
things #=> { :name => 'lee', :age => 105 }
```

Which is all great and stuff, but it can lead to some repetition. The same
thing in Slop:

```ruby
require 'slop'

opts = Slop.parse do
  on :n, :name=, 'Your name'
  on :a, :age=, 'Your age', as: Integer
end

opts.to_hash #=> { :name => 'lee', :age => 105 }
```
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# gelfd
gelfd is a standalone implementation of GELF (Graylog2 Extended Log Format).
This is used by the graylog2 server as an extended format for handling log messages.

## Rationale
This was originally concieved as a way to provide a graylog2-compatible input for logstash.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.= mime-types

home :: https://github.com/halostatue/mime-types/
code :: https://github.com/halostatue/mime-types/
bugs :: https://github.com/halostatue/mime-types/issues
rdoc :: http://rdoc.info/gems/mime-types/
continuous integration :: {<img src="https://travis-ci.org/halostatue/mime-types.png" />}[https://travis-ci.org/halostatue/mime-types]
test coverage :: {<img src="https://coveralls.io/repos/halostatue/mime-types/badge.png" alt="Coverage Status" />}[https://coveralls.io/r/halostatue/mime-types]

== Description

The mime-types library provides a library and registry for information about
MIME content type definitions. It can be used to determine defined filename
extensions for MIME types, or to use filename extensions to look up the likely
MIME type definitions.

MIME content types are used in MIME-compliant communications, as in e-mail or
HTTP traffic, to indicate the type of content which is transmitted. The
mime-types library provides the ability for detailed information about MIME
entities (provided as an enumerable collection of MIME::Type objects) to be
determined and used programmatically. There are many types defined by RFCs and
vendors, so the list is long but by definition incomplete; don't hesitate to to
add additional type definitions (see Contributing.rdoc). The primary sources
for MIME type definitions found in mime-types is the IANA collection of
registrations (see below for the link), RFCs, and W3C recommendations.

This is release 2.4.3, restoring full compatibility with Ruby 1.9.2 (which will
be dropped in mime-types 3.0). It also includes the performance improvements
from mime-types 2.4.2 (since yanked because of the broken Ruby 1.9.2 support)
and the 2.4.1 fix of a bug in observed use of the mime-types library where
extensions were not previously sorted, such that

    MIME::Types.of('image.jpg').first.extensions.first

returned a value of +jpeg+ in mime-types 1, but +jpe+ in mime-types 2. This was
introduced because extensions were sorted during assignment
(MIME::Type#extensions=). This behaviour has been reverted to protect clients
that work as noted above. The preferred way to express this is the new method:

    MIME::Type.of('image.jpg').first.preferred_extension

Łukasz Śliwa created the
{friendly_mime}[https://github.com/lukaszsliwa/friendly_mime] gem, which offers
friendly descriptive names for MIME types. This functionality and
English-language data has been added to mime-types as MIME::Type#friendly. To
make it easy for internationalization, MIME::Type#i18n_key has been added,
which will return a key suitable for use with the
{I18n}[https://github.com/svenfuchs/i18n] library.

As a reminder, mime-types 2.x is no longer compatible with Ruby 1.8 and
mime-types 1.x is only being maintained for security issues. No new MIME types
or features will be added.

mime-types (previously called MIME::Types for Ruby) was originally based on
MIME::Types for Perl by Mark Overmeer, copyright 2001 - 2009. It is built to
conform to the MIME types of RFCs 2045 and 2231. It tracks the {IANA Media
Types registry}[https://www.iana.org/assignments/media-types/media-types.xhtml]
with some types added by the users of mime-types.

== Synopsis

MIME types are used in MIME entities, as in email or HTTP traffic. It is useful
at times to have information available about MIME types (or, inversely, about
files). A MIME::Type stores the known information about one MIME type.

    require 'mime/types'

    plaintext = MIME::Types['text/plain'] # => [ text/plain ]
    text = plaintext.first
    puts text.media_type            # => 'text'
    puts text.sub_type              # => 'plain'

    puts text.extensions.join(" ")  # => 'txt asc c cc h hh cpp hpp dat hlp'
    puts text.friendly              # => 'Text Document'
    puts text.i18n_key              # => 'text.plain'

    puts text.encoding              # => quoted-printable
    puts text.binary?               # => false
    puts text.ascii?                # => true
    puts text.obsolete?             # => false
    puts text.registered?           # => true
    puts text == 'text/plain'       # => true
    puts 'text/plain' == text       # => true
    puts MIME::Type.simplified('x-appl/x-zip')
                                    # => 'appl/zip'

    puts MIME::Types.any? { |type|
      type.content_type == 'text/plain'
    }                               # => true
    puts MIME::Types.all?(&:registered?)
                                    # => false

== mime-types Modified Semantic Versioning

The mime-types library has one version number, but this single version number
tracks both API changes and registry data changes; this is not wholly
compatible with all aspects of {Semantic Versioning}[http://semver.org/];
removing a MIME type from the registry *could* be considered a breaking change
under some interpretations of semantic versioning (as lookups for that
particular type would no longer work by default).

mime-types uses a modified semantic versioning scheme. Given the version
MAJOR.MINOR:

1. If an incompatible API (code) change is made, the MAJOR version will be
   incremented, MINOR will be set to zero, and PATCH will be reset to the
   implied zero.

2. If an API (code) feature is added that does not break compatibilty OR if
   there are MIME types added, removed, or changed in the registry, the MINOR
   version will be incremented and PATCH will be reset to the implied zero.

3. If there is a bugfix to a feature added in the most recent MAJOR.MINOR
   release, OR if purely typographical errors are fixed in MIME types, the
   implied PATCH value will be incremented resulting in MAJOR.MINOR.PATCH.

In practical terms, there should be a MINOR release roughly monthly to track
updated or changed MIME types from the official IANA registry. This does not
indicate when new API features have been added, but all minor versions of
mime-types 2.x will be backwards compatible; the interfaces marked deprecated
will not be removed until at least mime-types 3.x or possibly later.

:include: Contributing.rdoc

:include: Licence.rdoc
# For The Web

## Getting Started

* For web agents: {FTW::Agent}
* For dns: {FTW::DNS}
* For tcp connections: {FTW::Connection}
* For tcp servers: {FTW::Server}

## Overview

net/http is pretty much not good. Additionally, DNS behavior in ruby changes quite frequently.

I primarily want two things in both client and server operations:

* A consistent API with good documentation, readable code, and high quality tests.
* Modern web features: websockets, spdy, etc.

Desired features:

* Awesome documentation
* A HTTP client that acts as a full user agent, not just a single connections. (With connection reuse)
* HTTP and SPDY support.
* WebSockets support.
* SSL/TLS support.
* Browser Agent features like cookies and caching
* An API that lets me do what I need.
* Server and Client modes.
* Support for both normal operation and EventMachine would be nice.

For reference:

* [DNS in Ruby stdlib is broken](https://github.com/jordansissel/experiments/tree/master/ruby/dns-resolving-bug), so I need to provide my own DNS api.

## Agent API

Reference: {FTW::Agent}

### Common case

    agent = FTW::Agent.new

    request = agent.get("http://www.google.com/")
    response = request.execute
    puts response.body.read

    # Simpler
    response = agent.get!("http://www.google.com/").read
    puts response.body.read

### SPDY

* This is not implemented yet

SPDY should automatically be attempted. The caller should be unaware.

I do not plan on exposing any direct means for invoking SPDY.

### WebSockets

    # 'http(s)' or 'ws(s)' urls are valid here. They will mean the same thing.
    websocket = agent.websocket!("http://somehost/endpoint")

    websocket.publish("Hello world")
    websocket.each do |message|
      puts :received => message
    end

## Web Server API

I have implemented a rack server, Rack::Handler::FTW. It does not comply fully
with the Rack spec. See 'Rack Compliance Issues' below.

Under the FTW rack handler, there is an environment variable added,
"ftw.connection". This will be a FTW::Connection you can use for CONNECT,
Upgrades, etc. 

There's also a websockets wrapper, FTW::WebSockets::Rack, that will help you
specifically with websocket requests and such.

## Rack Compliance issues

Due to some awkward and bad requirements - specifically those around the
specified behavior of 'rack.input' - I can't support the rack specification fully.

The 'rack.input' must be an IO-like object supporting #rewind which rewinds to
the beginning of the request.

For high-data connections (like uploads, HTTP CONNECT, and HTTP Upgrade), it's
not practical to hold the entire history of time in a buffer. We'll run out of
memory, you crazy fools!

Details here: https://github.com/rack/rack/issues/347

## Other Projects

Here are some related projects that I have no affiliation with:

* https://github.com/igrigorik/em-websocket - websocket server for eventmachine
* https://github.com/faye/faye - pubsub for the web (includes a websockets implementation)
* https://github.com/faye/faye-websocket-ruby - websocket client and server in ruby
* https://github.com/lifo/cramp - real-time web framework (async, websockets)
* https://github.com/igrigorik/em-http-request - HTTP client for EventMachine
* https://github.com/geemus/excon - http client library

Given some of the above (especially the server-side stuff), I'm likely try and integrate
with those projects. For example, writing a Faye handler that uses the FTW server, if the
FTW web server even stays around.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.Ruby 1.9 is a development release in anticipation of Ruby 2.0, which has
overall better performance, real threading, and character encoding support.
Note: Ruby 1.9 is a development release, meaning that everything is
subject to change without prior notice.  Among other things, this means
that xmpp4r could stop working on Ruby 1.9 at any time.

This version of xmpp4r has made a number of internal changes (nothing visible
at the API) to remove depency on deprecated Ruby Kernel APIs, support the new
encoding APIs, etc.

At the present time, all tests pass except tc_helper.rb and tc_stream.rb.
These tests themselves make assumptions about timinings of events,
assumptions that are not guaranteed with true multi-tasking.  Initial
analysis indicates that xmpp4r is operating correctly, it is the tests
themselves that need to be corrected, but this could turn out to be
incorrect.

The executing of these two tests are disabled by a check in ts_xmpp4r.rb,
which is marked as a TODO.

A specific example: test_bidi in test/tc_stream.rb defines two threads,
one pumps out requests, the other echoes them.  The receiver then verifies
that it gets back what it sent.  With Ruby 1.8, these threads tend to
alternate in lock step, and the test usually passes.  What happens in Ruby 1.9
is that the first thread waits for a message, and the second one creates a
callback block, generates a message, and then proceeds on to create a second
callback block -- even before the first message has been responded to.
The way xmpp4r works is that callbacks are saved on a pushdown stack.

The net result is that the first response typically is processed first by 
the second callback, which decides that the ids don't match, and the test fails.

The way it is supposed to work is that the reply callback is supposed to
only process requests destined for it (and return true) and ignore
everything else (returning false).

This is but one test.  Many of the tests in these two files are of this
nature.

The current status of the tests that are expected to pass on Ruby 1.9
can generally be found here:

http://intertwingly.net/projects/ruby19/logs/xmpp4r.html
= XMPP4R

== Project Home

You can find info about the xmpp4r project and how to contribute
at the project home page:

http://home.gna.org/xmpp4r/

If you need to ask questions, or want feedback on proposed changes
please feel free to ask them on the 'xmpp4r-devel@gna.org' mailing
list.  You can join or view archives of the mailing list at:

https://gna.org/mail/?group=xmpp4r

If you are having a problem and would like to report it
to the mailing list please include a protocol dump
which can be enabled in your code with:

  Jabber::debug = true


== Contributors

  Lucas Nussbaum <lucas@lucas-nussbaum.net>
  Stephan Maka <stephan@spaceboyz.net>
  Kirill A. Shutemov <k.shutemov@gmail.com>
  Glenn Rempe <glenn@rempe.us>
  Jacob Burkhart <jacob@brontes3d.com>
  Yuki Mitsui
  Peter Schrammel
  Olli
  Vojtech Vobr
  Andreas Wiese
  Chris Zelenak
  Matthew Wood
  Sam Ruby
  Tim Carey-Smith
  Scott Lillibridge
  Joshua Sierles
  Ripta Pasay <github@r8y.org>
  Seth Fitzsimmons


== Source Code

The source for xmpp4r is managed using the Git SCM and can be
found in our GitHub.com project page:

http://github.com/ln/xmpp4r/tree/master


== Installation

There are a number of ways that you can install xmpp4r depending
on your needs and the methods you prefer.

=== Install over the network using RubyGems

You can install the current release of the xmpp4r library from a stable
release gem on RubyForge using RubyGems:

  sudo gem install xmpp4r

=== Install over the network using a Debian package

You can install the current release of the xmpp4r library from a stable release copy
on your .deb friendly linux system (e.g. Debian or Ubuntu) using apt:

  sudo apt-get install libxmpp4r-ruby

=== Install from local source code (Developers Only)

If you have a local Git clone of the source repository or a tarball
you can install xmpp4r using several methods.  First you'll
need to get a local copy.

Clone the Git repository (recommended):

  git clone git://github.com/ln/xmpp4r.git

OR download a stable release tarball from:

  http://download.gna.org/xmpp4r/xmpp4r-0.3.2.tgz

OR download a snapshot of the latest source in .tar.gz format from:

  http://github.com/ln/xmpp4r/tarball/master

==== Install : Using Rake

  # Show all available rake tasks
  cd xmpp4r/
  rake -T

  # Package up the gem file and install it
  rake gem:install

==== Install : Using setup.rb

This will install a copy of the library in your Ruby path and does not
require RubyGems to be installed.

  cd xmpp4r/
  ./setup.rb


== License

XMPP4R is released under the Ruby license (see the LICENSE file), which is
compatible with the GNU GPL (see the COPYING file) via an explicit
dual-licensing clause.

What is this?

This is an example of what you can do with XMPP4R. It is a conferencing
component in which you can walk around, travel to various places, look
at things and talk to other visitors on the same places. If you like
Multi-User Dungeons (MUDs) this is for you!

---

How does it work?

The component loads a few worlds from a few XML files. Each world is a
component. Once joined the chat will tell you what you can do. Remember
that you can get a command listing anytime by saying '?'.

Reading 'You can go north, west' you may say 'go north' to go in the
northern direction and 'go west' to go in the western direction. You'll
then find yourself at some other place but still in the same MUC
conference. Your groupchat roster will change as you'll notice different
people and things that are just in the same place, not other places.

Before starting to hack the scripts you may want to take a look at
tower.xml. Note that users are <thing/>s, too and the whole world could
be serialized back to XML by just issuing "world.to_s".

Please note that the code, especially the error handling, is of extreme
poor quality and was mostly written in one afternoon. If I'm going to
develop this further everything should be rewritten...

---

How to try?

Because this is a component you are going to need your own Jabber
Daemon - which you'll need anyways if you're going to experiment with
XMPP4R. ;-)

Syntax:
./adventure.rb <JID> <Password> <Host>

Example:
./adventure.rb mud.example.com geheimnis localhost

---

Messages seem to have random order?

I don't know any solution for this. One may add short delays between
messages, but that would only be a very dirty hack.

RFC3920:

"10.  Server Rules for Handling XML Stanzas

Compliant server implementations MUST ensure in-order processing of
XML stanzas between any two entities."
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.method_source
=============

(C) John Mair (banisterfiend) 2011

_retrieve the sourcecode for a method_

*NOTE:* This simply utilizes `Method#source_location`; it
 does not access the live AST.

`method_source` is a utility to return a method's sourcecode as a
Ruby string. Also returns `Proc` and `Lambda` sourcecode.

Method comments can also be extracted using the `comment` method.

It is written in pure Ruby (no C).

* Some Ruby 1.8 support now available.
* Support for MRI, RBX, JRuby, REE

`method_source` provides the `source` and `comment` methods to the `Method` and
`UnboundMethod` and `Proc` classes.

* Install the [gem](https://rubygems.org/gems/method_source): `gem install method_source`
* Read the [documentation](http://rdoc.info/github/banister/method_source/master/file/README.markdown)
* See the [source code](http://github.com/banister/method_source)

Example: display method source
------------------------------

    Set.instance_method(:merge).source.display
    # =>
    def merge(enum)
      if enum.instance_of?(self.class)
        @hash.update(enum.instance_variable_get(:@hash))
      else
        do_with_enum(enum) { |o| add(o) }
      end

      self
    end

Example: display method comments
--------------------------------

    Set.instance_method(:merge).comment.display
    # =>
    # Merges the elements of the given enumerable object to the set and
    # returns self.

Limitations:
------------

* Occasional strange behaviour in Ruby 1.8
* Cannot return source for C methods.
* Cannot return source for dynamically defined methods.

Special Thanks
--------------

[Adam Sanderson](https://github.com/adamsanderson) for `comment` functionality.

[Dmitry Elastic](https://github.com/dmitryelastic) for the brilliant Ruby 1.8 `source_location` hack.

[Samuel Kadolph](https://github.com/samuelkadolph) for the JRuby 1.8 `source_location`.

License
-------

(The MIT License)

Copyright (c) 2011 John Mair (banisterfiend)

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
## multipart-post

* http://github.com/nicksieger/multipart-post

![build status](https://travis-ci.org/nicksieger/multipart-post.png)

#### DESCRIPTION:

Adds a streamy multipart form post capability to Net::HTTP. Also
supports other methods besides POST.

#### FEATURES/PROBLEMS:

* Appears to actually work. A good feature to have.
* Encapsulates posting of file/binary parts and name/value parameter parts, similar to 
  most browsers' file upload forms.
* Provides an UploadIO helper class to prepare IO objects for inclusion in the params
  hash of the multipart post object.

#### SYNOPSIS:

    require 'net/http/post/multipart'

    url = URI.parse('http://www.example.com/upload')
    File.open("./image.jpg") do |jpg|
      req = Net::HTTP::Post::Multipart.new url.path,
        "file" => UploadIO.new(jpg, "image/jpeg", "image.jpg")
      res = Net::HTTP.start(url.host, url.port) do |http|
        http.request(req)
      end
    end

To post multiple files or attachments, simply include multiple parameters with
UploadIO values:

    require 'net/http/post/multipart'

    url = URI.parse('http://www.example.com/upload')
    req = Net::HTTP::Post::Multipart.new url.path,
      "file1" => UploadIO.new(File.new("./image.jpg"), "image/jpeg", "image.jpg"),
      "file2" => UploadIO.new(File.new("./image2.jpg"), "image/jpeg", "image2.jpg")
    res = Net::HTTP.start(url.host, url.port) do |http|
      http.request(req)
    end

#### REQUIREMENTS:

None

#### INSTALL:

    gem install multipart-post

#### LICENSE:

(The MIT License)

Copyright (c) 2007-2013 Nick Sieger <nick@nicksieger.com>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# Please read!
## This plugin is being deprecated!
This plugin exist to provide an easy upgrade path to the new [elasticsearch](http://github.com/logstash-plugins/logstash-output-elasticsearch/) output.
This means that **new pull requests will not be accepted** here, please direct any issues to the new elasticsearch output.

# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization.

- Install dependencies
```sh
bundle install
```

#### Test

```sh
bundle exec rspec
```

The Logstash code required to run the tests/specs is specified in the `Gemfile` by the line similar to:
```ruby
gem "logstash", :github => "elasticsearch/logstash", :branch => "1.5"
```
To test against another version or a local Logstash, edit the `Gemfile` to specify an alternative location, for example:
```ruby
gem "logstash", :github => "elasticsearch/logstash", :ref => "master"
```
```ruby
gem "logstash", :path => "/your/local/logstash"
```

Then update your dependencies and run your tests:

```sh
bundle install
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `tools/Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Update Logstash dependencies
```sh
rake vendor:gems
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to me that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.[![Build Status](https://travis-ci.org/avdi/naught.png?branch=master)](https://travis-ci.org/avdi/naught)
[![Code Climate](https://codeclimate.com/github/avdi/naught.png)](https://codeclimate.com/github/avdi/naught)
[![Coverage Status](https://coveralls.io/repos/avdi/naught/badge.png?branch=master)](https://coveralls.io/r/avdi/naught?branch=master)
[![Gem Version](https://badge.fury.io/rb/naught.png)](http://badge.fury.io/rb/naught)

A quick intro to Naught
-------------------------

#### What's all this now then?

Naught is a toolkit for building [Null
Objects](http://en.wikipedia.org/wiki/Null_Object_pattern) in Ruby.

#### What's that supposed to mean?

Null Objects can make your code more
[confident](http://confidentruby.com).

Here's a method that's not very sure of itself.

```ruby
class Geordi
  def make_it_so(logger=nil)
    logger && logger.info("Reversing the flux phase capacitance!")
    logger && logger.info("Bounding a tachyon particle beam off of Data's cat!")
    logger && logger.warn("Warning, bogon levels are rising!")
  end
end
```

Now, observe as we give it a dash of confidence with the Null Object
pattern!

```ruby
class NullLogger
  def debug(*); end
  def info(*); end
  def warn(*); end
  def error(*); end
  def fatal(*); end
end

class Geordi
  def make_it_so(logger=NullLogger.new)
    logger.info "Reversing the flux phase capacitance!"
    logger.info "Bounding a tachyon particle beam off of Data's cat!"
    logger.warn "Warning, bogon levels are rising!"
  end
end
```

By providing a `NullLogger` which implements [some of] the `Logger`
interface as no-op methods, we've gotten rid of those unsightly `&&`
operators.

#### That was simple enough. Why do I need a library for it?

You don't! The Null Object pattern is a very simple one at its core.

#### And yet here we are…

Yes. While you don't *need* a Null Object library, this one offers some
conveniences you probably won't find elsewhere.

But there's an even more important reason I wrote this library. In the
immortal last words of James T. Kirk: "It was… *fun!*"

#### OK, so how do I use this thing?

Well, what would you like to do?

#### I dunno, gimme an object that responds to any message with nil

Sure thing!

```ruby
require 'naught'

NullObject = Naught.build

null = NullObject.new
null.foo                        # => nil
null.bar                        # => nil
```

#### That was… weird. What's with this "build" business?

Naught is a *toolkit* for building null object classes. It is not a
one-size-fits-all solution.

What else can I make for you?

#### How about a "black hole" null object that supports infinite chaining of methods?

OK.

```ruby
require 'naught'

BlackHole = Naught.build do |config|
  config.black_hole
end

null = BlackHole.new
null.foo                           # => <null>
null.foo.bar.baz                   # => <null>
null << "hello" << "world"         # => <null>
```

#### What's that "config" thing?

That's what you use to customize the generated class to your
liking. Internally, Naught uses the [Builder
Pattern](http://en.wikipedia.org/wiki/Builder_pattern) to make this work..

#### Whatever. What if I want a null object that has conversions to Integer, String, etc. using sensible conversions to "zero values"?

We can do that.

```ruby
require 'naught'

NullObject = Naught.build do |config|
  config.define_explicit_conversions
end

null = NullObject.new

null.to_s                          # => ""
null.to_i                          # => 0
null.to_f                          # => 0.0
null.to_a                          # => []
null.to_h                          # => {}
null.to_c                          # => (0+0i)
null.to_r                          # => (0/1)
```

#### Ah, but what about implicit conversions such as `#to_str`? Like what if I want a null object that implicitly splats the same way as an empty array?

Gotcha covered.

```ruby
require 'naught'

NullObject = Naught.build do |config|
  config.define_implicit_conversions
end

null = NullObject.new

null.to_str                     # => ""
null.to_ary                     # => []

a, b, c = []
a                               # => nil
b                               # => nil
c                               # => nil
x, y, z = null
x                               # => nil
y                               # => nil
z                               # => nil
```

#### How about a null object that only stubs out the methods from a specific class?

That's what `mimic` is for.

```ruby
require 'naught'

NullIO = Naught.build do |config|
  config.mimic IO
end

null_io = NullIO.new

null_io << "foo"                # => nil
null_io.readline                # => nil
null_io.foobar                  # =>
# ~> -:11:in `<main>': undefined method `foobar' for
#  <null:IO>:NullIO (NoMethodError)
```

There is also `impersonate` which takes `mimic` one step further. The
generated null class will be derived from the impersonated class. This
is handy when refitting legacy code that contains type checks.

```ruby
require 'naught'

NullIO = Naught.build do |config|
  config.impersonate IO
end

null_io = NullIO.new
IO === null_io                  # => true

case null_io
when IO
  puts "Yep, checks out!"
  null_io << "some output"
else
  raise "Hey, I expected an IO!"
end
# >> Yep, checks out!
```

#### What about predicate methods? You know, the ones that end with question marks? Shouldn't they return `false` instead of `nil`?

Sure, if you'd like.

```ruby
require 'naught'

NullObject = Naught.build do |config|
  config.predicates_return false
end

null = NullObject.new
null.foo                        # => nil
null.bar?                       # => false
null.nil?                       # => false
```

#### Alright smartypants. What if I want to add my own methods?

Not a problem, just define them in the `.build` block.

```ruby
require 'naught'

NullObject = Naught.build do |config|
  config.define_explicit_conversions
  config.predicates_return false
  def to_path
    "/dev/null"
  end

  # You can override methods generated by Naught
  def to_s
    "NOTHING TO SEE HERE MOVE ALONG"
  end

  def nil?
    true
  end
end

null = NullObject.new
null.to_path                    # => "/dev/null"
null.to_s                       # => "NOTHING TO SEE HERE MOVE ALONG"
null.nil?                       # => true
```

#### Got anything else up your sleeve?

Well, we can make the null class a singleton, since null objects
generally have no state.

```ruby
require 'naught'

NullObject = Naught.build do |config|
  config.singleton
end

null = NullObject.instance

null.__id__                     # => 17844080
NullObject.instance.__id__      # => 17844080
NullObject.new                  # =>
# ~> -:11:in `<main>': private method `new' called for
#  NullObject:Class (NoMethodError)
```

Speaking of null objects with state, we can also enable tracing. This is
handy for playing "where'd that null come from?!" Try doing *that* with
`nil`!

```ruby
require 'naught'

NullObject = Naught.build do |config|
  config.traceable
end

null = NullObject.new           # line 7

null.__file__                   # => "example.rb"
null.__line__                   # => 7
```

We can even conditionally enable either singleton mode (for production)
or tracing (for development). Here's an example of using the `$DEBUG`
global variable (set with the `-d` option to ruby) to choose which one.

```ruby
require 'naught'

NullObject = Naught.build do |config|
  if $DEBUG
    config.traceable
  else
    config.singleton
  end
end
```

The only caveat is that when swapping between singleton and
non-singleton implementations, you should be careful to always
instantiate your null objects with `NullObject.get`, not `.new` or
`.instance`. `.get` will work whether the class is implemented as a
singleton or not.

```ruby
NullObject.get                  # => <null>
```

#### And if I want to know legacy code better?

Naught can make a null object behave as a pebble object.

```ruby
require 'naught'

NullObject = Naught.build do |config|
  if $DEBUG
    config.pebble
  else
    config.black_hole
  end
end
```

Now you can pass the pebble object to your code and see which messages are sent to the pebble.

```ruby
null = NullObject.new

class MyConsumer < Struct.new(:producer)
  def consume
    producer.produce
  end
end

MyConsumer.new(null).consume
# >> produce() from consume
# => <null>
```

#### Are you done yet?

Just one more thing. For maximum convenience, Naught-generated null
classes also come with a full suite of conversion functions which can be
included into your classes.

```ruby
require 'naught'

NullObject = Naught.build

include NullObject::Conversions

# Convert nil to null objects. Everything else passes through.
Maybe(42)                       # => 42
Maybe(nil)                      # => <null>
Maybe(NullObject.get)           # => <null>
Maybe{ 42 }                     # => 42

# Insist on a non-null (or nil) value
Just(42)                        # => 42
Just(nil) rescue $!             # => #<ArgumentError: Null value: nil>
Just(NullObject.get) rescue $!  # => #<ArgumentError: Null value: <null>>

# nils and nulls become nulls. Everything else is rejected.
Null()                          # => <null>
Null(42) rescue $!              # => #<ArgumentError: 42 is not null!>
Null(nil)                       # => <null>
Null(NullObject.get)            # => <null>

# Convert nulls back to nils. Everything else passes through. Useful
# for preventing null objects from "leaking" into public API return
# values.
Actual(42)                      # => 42
Actual(nil)                     # => nil
Actual(NullObject.get)          # => nil
Actual { 42 }                   # => 42
```

Installation
--------------

``` {.example}
gem install naught
```

Requirements
--------------

-   Ruby 1.9

Contributing
--------------

-   Fork, branch, submit PR, blah blah blah. Don't forget tests.

Who's responsible
-------------------

Naught is by [Avdi Grimm](http://devblog.avdi.org/).

Prior Art
---------

This isn't the first Ruby Null Object library. Others to check out include:

 - [NullAndVoid](https://github.com/jfelchner/null_and_void)
 - [BlankSlate](https://github.com/saturnflyer/blank_slate)


Further reading
-----------------

-   [Null Object: Something for
    Nothing](http://www.two-sdg.demon.co.uk/curbralan/papers/europlop/NullObject.pdf)
    (PDF) by Kevlin Henney
-   [The Null Object
    Pattern](http://www.cs.oberlin.edu/~jwalker/refs/woolf.ps) (PS) by
    Bobby Woolf
-   [NullObject](http://www.c2.com/cgi/wiki?NullObject) on WikiWiki
-   [Null Object
    pattern](http://en.wikipedia.org/wiki/Null_Object_pattern) on
    Wikipedia
-   [Null Objects and
    Falsiness](http://devblog.avdi.org/2011/05/30/null-objects-and-falsiness/),
    by Avdi Grimm
= rufus-scheduler

rufus-scheduler is a Ruby gem for scheduling pieces of code (jobs). It understands running a job AT a certain time, IN a certain time, EVERY x time or simply via a CRON statement.

rufus-scheduler is no replacement for cron/at since it runs inside of Ruby.


== alternatives / complements

A list of related Ruby projects :

* http://github.com/javan/whenever
* http://github.com/yakischloba/em-timers
* http://github.com/adamwiggins/clockwork

More like complements :

* http://github.com/mojombo/chronic
* http://github.com/hpoydar/chronic_duration


== installation

  gem install rufus-scheduler


== usage

The usage is similar to the one of the old rufus-scheduler. There are a few differences though.

  require 'rubygems'
  require 'rufus/scheduler'

  scheduler = Rufus::Scheduler.start_new

  scheduler.in '20m' do
    puts "order ristretto"
  end

  scheduler.at 'Thu Mar 26 07:31:43 +0900 2009' do
    puts 'order pizza'
  end

  scheduler.cron '0 22 * * 1-5' do
    # every day of the week at 22:00 (10pm)
    puts 'activate security system'
  end

  scheduler.every '5m' do
    puts 'check blood pressure'
  end


This code summons a plain version of the scheduler, this can be made more explicit via :

  scheduler = Rufus::Scheduler::PlainScheduler.start_new

This PlainScheduler accepts a :thread_name option :

  scheduler = Rufus::Scheduler::PlainScheduler.start_new(:thread_name => 'my scheduler')

which might be helpful when tracking threads.


Note that if there is an EventMachine present and running,

  scheduler = Rufus::Scheduler.start_new

will return an instance of Rufus::Scheduler::EmScheduler (leveraging EventMachine).


== a note about cron jobs

This is a classical cron :

  scheduler.cron '0 22 * * 1-5' do
    # every day of the week at 22:00 (10pm)
  end

Rufus-scheduler supports three variants to that notation : seconds, last day of month and timezones.

  scheduler.cron '13 0 22 * * 1-5' do
    # every day of the week at 22:00:13
  end

  scheduler.cron '0 22 L * *' do
    # every month on the last day at 22:00
  end

  scheduler.cron '0 22 * * 1-5 Europe/Paris' do
    # every day of the week when it's 22:00 in Paris
  end
  scheduler.cron '0 22 * * 1-5 Etc/GMT+2' do
    # every day of the week when it's 22:00 in GMT+2
  end

The timezones are the ones supported by the 'tzinfo' rubygem (http://tzinfo.rubyforge.org/).

The timezone support was contributed by Tanzeeb Khalili.

"monthdays" are supported

  scheduler.cron '0 22 * * sun#1,sun#2' do
    # every first and second sunday of the month, at 22:00
  end

It's also OK (since 2.0.19) to use L (for last monthday) or negative numbers.

  scheduler.cron '0 22 * * sun#-1' do
    # every last sunday of the month, at 22:00
  end


== scheduler.join

Note that if you have a tiny script like this one :

  require 'rubygems'; require 'rufus-scheduler'

  scheduler = Rufus::Scheduler.start_new

  scheduler.at 'Thu Mar 26 07:31:43 +0900 2009' do
    puts 'order pizza'
  end

And you run it, it will exit immediately.

If you place

  scheduler.join

at the end, it will make the current (main) thread join the scheduler and prevent the Ruby runtime from exiting.

You shouldn't be exposed to this issue when using EventMachine, since while running EM, your runtime won't exit.

=== important note about #join

DO NOT CALL this #join method if you're running rufus-scheduler from Rails or Sinatra or any application that's already some kind of 'daemon'. It's not necessary! #join is meant for small standalone scripts.


== schedule.stop

  scheduler.stop

This call stops the scheduler. It doesn't unschedule jobs. If there are running jobs, they're left running.

If you need to stop the scheduler and wait for all the jobs currently running to finish (without killing them), rufus-scheduler 2.0.20 brings a new :terminate => true option.

  scheduler.stop(:terminate => true)
    # returns once all the jobs have been unscheduled and no jobs is running


== block parameters

Scheduled blocks accept 0 or 1 parameter (this unique parameter is the job
instance itself).

  scheduler.every '5m' do
    puts 'check blood pressure'
  end
  scheduler.every '1y' do |job|
    puts "check cholesterol levels (#{job.job_id})"
  end

See the class Job for more details :

http://rufus.rubyforge.org/rufus-scheduler/classes/Rufus/Scheduler/Job.html


== the time strings understood by rufus-scheduler

  require 'rubygems'
  require 'rufus/scheduler'

  p Rufus.parse_time_string '500'      # => 0.5
  p Rufus.parse_time_string '1000'     # => 1.0
  p Rufus.parse_time_string '1h'       # => 3600.0
  p Rufus.parse_time_string '1h10s'    # => 3610.0
  p Rufus.parse_time_string '1w2d'     # => 777600.0

  p Rufus.to_time_string 60              # => "1m"
  p Rufus.to_time_string 3661            # => "1h1m1s"
  p Rufus.to_time_string 7 * 24 * 3600   # => "1w"


== :blocking => true

Jobs will, by default, trigger in their own thread. This is usually desirable since one expects the scheduler to continue scheduling even if a job is currently running.

Jobs scheduled with the :blocking parameter will run in the thread of the scheduler, blocking it.

  scheduler.in '20m', :blocking => true do
    puts "order ristretto"
    sleep 2 * 60
  end
  scheduler.in '21m' do
    puts "order espresso"
  end

Hence, our espresso will come in 22 minutes instead of 21.

Warning, 'cron' behaves a bit differently than 'in' and 'at', if the scheduler is blocked working on a task, it may skip crons (while ins and ats get scheduled after).

  scheduler.cron '0 16 * * * *' do
    puts "four o'clock tea"
  end

If at 4pm the scheduler is in a blocking task, there will be no four o'clock tea.


== :mutex => 'that_mutex'

:blocking is nice but it is blocking the whole scheduler. What about something more fine-grained ? And also something that can be used with in, at, every and cron ?

  scheduler.in '20m', :mutex => 'that_mutex' do
    puts "order ristretto"
    sleep 2 * 60
    puts "ah, that was delicious"
  end
  scheduler.in '21m' :mutex => 'that_mutex' do
    puts "order espresso"
  end

the "order espresso" will only get triggered once the ristretto has been consumed. Rufus-scheduler will create a 'that_mutex' mutex and keep track of it. Don't go on passing too many different mutex names, rufus-scheduler will keep track of each of them (they won't get garbage collected).

It's OK to use a mutex directly:

  m = Mutex.new
  # ...
  scheduler.cron  '0 18 * * *', :mutex => m do
    # ...
  end
  scheduler.in '21m' :mutex => m do
    # ...
  end

It can be handy for even more fine-grained control:

  m = Mutex.new
  # ...
  scheduler.cron  '0 18 * * *', :mutex => m do
    # ...
  end
  scheduler.in '21m' do
    # non-critical
    m.synchronize do
      # critical
    end
    # non-critical
  end

Please note that a mutex can also be used to prevent overlapping executions of the same job:

  scheduler.every '5m', :mutex => 'the_mutex' do
    puts "order ristretto"
    # do something that might take more that 5 minutes...
    puts "ah, that was delicious"
  end

But beware the cascades...


== :mutex => ['mutex_a', 'mutex_b', ...]

Multiple mutexes can be used to ensure exlusivity:

  scheduler.in '20m', :mutex => 'mutex_r' do
    puts "order ristretto"
    sleep 2 * 60
  end

  scheduler.in '20m' :mutex => 'mutex_e' do
    puts "order espresso"
    sleep 3 * 60
  end

  scheduler.in '1h' :mutex => ['mutex_r', 'mutex_e'] do
    puts "code for fun"
  end

This allow you order ristretto and espresso at same time, but when you coding it ensure you can't order any thing, and when you ordering anything it ensure you can't code.

Sure you can also use array of Mutex object directly:

  mutex_r = Mutex.new
  mutex_e = Mutex.new
  # ...
  scheduler.in '1h' :mutex => [mutex_r, mutex_e] do
    puts "code for fun"
  end


== :allow_overlapping => false

By default, every and cron jobs will "overlap":

  scheduler.every '3s' do
    4.times do |i|
      puts "hello #{i}"
      sleep 1
    end
  end

You might end up with something that looks like

  hello 0
  hello 1
  hello 2
  hello 3
  hello 3
  hello 4
  ...

This every job will have overlaps. To prevent that:

  scheduler.every '3s', :allow_overlapping => false do
    # ...
  end


== 'every' jobs and :first_at / :first_in

This job will execute every 3 days, but first time will be in 5 days from now :

  scheduler.every '3d', :first_in => '5d' do
    # do something
  end

This job will execute every 3 days, starting from Christmas Eve at noon :

  scheduler.every '3d', :first_at => '2009/12/24 12:00' do
    # do something
  end

The chronic gem may help (http://chronic.rubyforge.org/) :

  require 'chronic' # sudo gem install chronic

  scheduler.every '3h', :first_at => Chronic.parse('this tuesday 5:00') do
    # do something starting this tuesday
  end

Note : setting a :first_at/:first_in in the past will get rufus-scheduler to trigger for all the past schedules until now. Adding :discard_past => true will prevent this.


== self unschedule for 'cron' and 'every' jobs

'at' and 'in' jobs fire once only. 'cron' and 'every' jobs do fire repeatedly, so it might be useful to stop them.

  scheduler.every '3d' do |job|
    l = determine_crop_maturity_level()
    if l >= 7
      puts "crop is ready."
      job.unschedule
    else
      puts "crop not yet ready..."
    end
  end

In this example, the 'every' job will unschedule itself when the crop is ready.


== #running?

  job = scheduler.every '3d' do
    # ...
  end

  # ...

  p job.running?

Job#running? will return true when the job got triggered and is actually performing.

Please note, that #running? is not related to the #paused? which is detailed in the next section.


== #pause, #resume and #paused?

Jobs, as well as the scheduler itself have a pair of #pause and #resume methods.

  job = scheduler.every '2h' do
    # ...
  end

  # ...

  job.pause # the job will be scheduled but won't trigger

  # ...

  puts job.paused?

Pausing / resuming a job doesn't affect the scheduling of a job, it merely "silences" it, its block won't get executed. Calling resume will not reset the schedule of the job. If you schedule a job to trigger every 10 minutes at 10am and pause it from 1020 to 1025, it's next triggering time will be 1030 approximately.

One can pause an "at" or "in" job. If it's still paused at trigger time, it will simply become a dud.

As said, the scheduler has a #pause(job_or_job_id) and a #resume(job_or_job_id) pair of methods:

  scheduler.pause(job)
  scheduler.pause(job_id)
  scheduler.resume(job)
  scheduler.resume(job_id)


== Scheduler#running_jobs

One can get a list of the jobs just triggered (actually running) by doing

  jobs = scheduler.running_jobs


== schedulables

Sometimes passing a block isn't that convenient :

  class JobThing
    def initialize(relevant_info)
      @ri = relevant_info
    end
    def call(job)
      do_something_about_it
    end
  end

  # ...

  scheduler.in '3d', JobThing.new('http://news.example.com/data_xyz')
  scheduler.in '1w', JobThing.new('http://news.example.com/data_abc'), :timeout => '1d'

rufus-scheduler accepts anything that responds to a call method with a unique parameter (it will pass the job) as a 'schedulable'.

For compatibility with older (1.x) versions, schedulables with a trigger methods are accepted :

  class JobThing
    def trigger(params)
      job = params[:job]
    end
  end

The 'params' correspond to the scheduler job params, and the key :job points to the rufus-scheduler job for the schedulable that is passed to a 'call schedulable'.


== looking up jobs

  scheduler.jobs
    # returns a map job_id => job of at/in/every jobs

  scheduler.cron_jobs
    # idem for cron jobs

  scheduler.all_jobs
    # idem but for every/at/in/cron jobs (all of them)

  scheduler.find_by_tag(t)
    # returns all the jobs with a given tag (passed at schedule time with :tags)


== unscheduling jobs

The 'scheduling' methods always return an instance of Rufus::Scheduler::Job. This object can be used for unscheduling :

  job = scheduler.in '2d', :tags => 'admin' do
    run_backlog_cleaning()
  end

  # later ...

  job.unschedule
    # or
  scheduler.unschedule(job.job_id)


== tags

You can specify tags at schedule time :

  scheduler.in '2d', :tags => 'admin' do
    run_backlog_cleaning()
  end
  scheduler.every '3m', :tags => 'production' do
    check_order_log()
  end

And later query the scheduler for those jobs :

  admin_jobs = scheduler.find_by_tag('admin')
  production_jobs = scheduler.find_by_tag('production')


== timeout

One can specify a timeout for the triggering of a job.

  scheduler.every '2d', :timeout => '40m' do
    begin
      run_backlog_cleaning()
    rescue Rufus::Scheduler::TimeOutError => toe
      # timeout occurred
    end
  end

This job will run every two days. If a run takes more than 40 minutes it will timeout (its thread will receive a TimeOutError).

This timeout feature relies on an 'in' job scheduled at the moment the main job gets triggered, hence the '40m' time string format.


== exceptions in jobs

By default, when exceptions occur when a job performs, the error messages will be output to the STDOUT.

It's easy to customize that behaviour :

  scheduler = Rufus::Scheduler::PlainScheduler.start_new
    # or
  #scheduler = Rufus::Scheduler::EmScheduler.start_new

  def scheduler.handle_exception(job, exception)
    puts "job #{job.job_id} caught exception '#{exception}'"
  end

These are OK too:

  def scheduler.on_exception(job, exception)
    puts "job #{job.job_id} caught exception '#{exception}'"
  end

  # or

  def scheduler.on_exception(exception)
    puts "caught exception '#{exception}'"

For backward compatibility, overriding #log_exception is still OK :

  def scheduler.log_exception(exception)
    puts "caught exception '#{exception}'"
  end

Note that an every job or a cron job will stay scheduled even if it experiences an exception.

By default, all exceptions are rescued. It's easy to customize that behaviour :

  scheduler = Rufus::Scheduler::PlainScheduler.start_new(:exception => StandardError)
    # or
  #scheduler = Rufus::Scheduler::EmScheduler.start_new(:exception => StandardError)

  scheduler.in "3s" do
    exit
  end

== frequency

The default frequency for the scheduler is 0.330 seconds. This means that the usual scheduler implementation will wake up, trigger jobs that are to be triggered and then go back to sleep for 0.330 seconds. Note that this doesn't mean that the scheduler will wake up very 0.330 seconds (checking and triggering do take time).

You can set a different frequency when starting / initializing the scheduler :

  require 'rubygems'
  require 'rufus/scheduler'

  scheduler = Rufus::Scheduler.start_new(:frequency => 60.0)
    # for a lazy scheduler that only wakes up every 60 seconds


== usage with EventMachine

rufus-scheduler 2.0 can be used in conjunction with EventMachine (http://github.com/eventmachine/eventmachine/).

More and more ruby applications are using EventMachine. This flavour of the scheduler relies on EventMachine, thus it doesn't require a separate thread like the PlainScheduler does.

  require 'rubygems'
  require 'eventmachine'

  EM.run {

    scheduler = Rufus::Scheduler::EmScheduler.start_new

    scheduler.in '20m' do
      puts "order ristretto"
    end
  }


== with Passenger

"it terminates for no apparent reason!"

https://github.com/jmettraux/rufus-scheduler/issues/issue/10


== tested with

* 1.8.7-p249
* 1.9.2-p290
* jruby-1.5.1

on Mac OS X (Snow Leopard).


== dependencies

The 'tzinfo' rubygem.

The ruby gem 'eventmachine' if you use Rufus::Scheduler::EmScheduler, else no other dependencies.


== support

If you identify and pinpoint a bug, please use the issue tracker. If you are unsure whether the fault lies in rufus-scheduler or in your software, use the mailing list. The mailing list is Google-powered, so, yes, you can search it.

Please read carefully: http://www.chiark.greenend.org.uk/~sgtatham/bugs.html (then re-read it).


=== mailing list

On the rufus-ruby list :

http://groups.google.com/group/rufus-ruby

Newcomers' first message is held for moderation in order to prevent spam. Further messages are not held.


=== issue tracker

https://github.com/jmettraux/rufus-scheduler/issues


=== irc

If you come over to #ruote to ask for rufus-scheduler help, please make sure to 1) say hello 2) be polite 3) state that you're looking for rufus-scheduler help 4) remember that we cannot read your mind and guess whatever lies in your deployment.

  irc.freenode.net #ruote

If there is no answer on IRC, use the mailing list.


== source

http://github.com/jmettraux/rufus-scheduler

  git clone git://github.com/jmettraux/rufus-scheduler.git


== credits

http://github.com/jmettraux/rufus-scheduler/blob/master/CREDITS.txt


== authors

John Mettraux, jmettraux@gmail.com, http://jmettraux.github.com


== the rest of Rufus

http://rufus.rubyforge.org


== license

MIT

Tilt [![Build Status](https://secure.travis-ci.org/rtomayko/tilt.png)](http://travis-ci.org/rtomayko/tilt) [![Dependency Status](https://gemnasium.com/rtomayko/tilt.png)](https://gemnasium.com/rtomayko/tilt)
====

**NOTE** The following file documents the current release of Tilt (2.0). See
https://github.com/rtomayko/tilt/tree/tilt-1 for documentation for Tilt 1.4.

Tilt is a thin interface over a bunch of different Ruby template engines in
an attempt to make their usage as generic as possible. This is useful for web
frameworks, static site generators, and other systems that support multiple
template engines but don't want to code for each of them individually.

The following features are supported for all template engines (assuming the
feature is relevant to the engine):

 * Custom template evaluation scopes / bindings
 * Ability to pass locals to template evaluation
 * Support for passing a block to template evaluation for "yield"
 * Backtraces with correct filenames and line numbers
 * Template file caching and reloading
 * Fast, method-based template source compilation

The primary goal is to get all of the things listed above right for all
template engines included in the distribution.

Support for these template engines is included with the package:

    ENGINE                     FILE EXTENSIONS         REQUIRED LIBRARIES
    -------------------------- ----------------------- ----------------------------
    Asciidoctor                .ad, .adoc, .asciidoc   asciidoctor (>= 0.1.0)
    ERB                        .erb, .rhtml            none (included ruby stdlib)
    Interpolated String        .str                    none (included ruby core)
    Erubis                     .erb, .rhtml, .erubis   erubis
    Haml                       .haml                   haml
    Sass                       .sass                   haml (< 3.1) or sass (>= 3.1)
    Scss                       .scss                   haml (< 3.1) or sass (>= 3.1)
    Less CSS                   .less                   less
    Builder                    .builder                builder
    Liquid                     .liquid                 liquid
    RDiscount                  .markdown, .mkd, .md    rdiscount
    Redcarpet                  .markdown, .mkd, .md    redcarpet
    BlueCloth                  .markdown, .mkd, .md    bluecloth
    Kramdown                   .markdown, .mkd, .md    kramdown
    Maruku                     .markdown, .mkd, .md    maruku
    RedCloth                   .textile                redcloth
    RDoc                       .rdoc                   rdoc
    Radius                     .radius                 radius
    Markaby                    .mab                    markaby
    Nokogiri                   .nokogiri               nokogiri
    CoffeeScript               .coffee                 coffee-script (+ javascript)
    Creole (Wiki markup)       .wiki, .creole          creole
    WikiCloth (Wiki markup)    .wiki, .mediawiki, .mw  wikicloth
    Yajl                       .yajl                   yajl-ruby
    CSV                        .rcsv                   none (Ruby >= 1.9), fastercsv (Ruby < 1.9)

These template engines ship with their own Tilt integration:

    ENGINE                     FILE EXTENSIONS   REQUIRED LIBRARIES
    -------------------------- ----------------- ----------------------------
    Slim                       .slim             slim (>= 0.7)
    Embedded JavaScript                          sprockets
    Embedded CoffeeScript                        sprockets
    JST                                          sprockets
    Org-mode                   .org              org-ruby (>= 0.6.2)
    Handlebars                 .hbs, .handlebars tilt-handlebars

See [TEMPLATES.md][t] for detailed information on template engine
options and supported features.

[t]: http://github.com/rtomayko/tilt/blob/master/docs/TEMPLATES.md
   "Tilt Template Engine Documentation"

Basic Usage
-----------

Instant gratification:

    require 'erb'
    require 'tilt'
    template = Tilt.new('templates/foo.erb')
    => #<Tilt::ERBTemplate @file="templates/foo.rb" ...>
    output = template.render
    => "Hello world!"

It's recommended that calling programs explicitly require template engine
libraries (like 'erb' above) at load time. Tilt attempts to lazy require the
template engine library the first time a template is created but this is
prone to error in threaded environments.

The {Tilt} module contains generic implementation classes for all supported
template engines. Each template class adheres to the same interface for
creation and rendering. In the instant gratification example, we let Tilt
determine the template implementation class based on the filename, but
{Tilt::Template} implementations can also be used directly:

    require 'tilt/haml'
    template = Tilt::HamlTemplate.new('templates/foo.haml')
    output = template.render

The `render` method takes an optional evaluation scope and locals hash
arguments. Here, the template is evaluated within the context of the
`Person` object with locals `x` and `y`:

    require 'tilt/erb'
    template = Tilt::ERBTemplate.new('templates/foo.erb')
    joe = Person.find('joe')
    output = template.render(joe, :x => 35, :y => 42)

If no scope is provided, the template is evaluated within the context of an
object created with `Object.new`.

A single `Template` instance's `render` method may be called multiple times
with different scope and locals arguments. Continuing the previous example,
we render the same compiled template but this time in jane's scope:

    jane = Person.find('jane')
    output = template.render(jane, :x => 22, :y => nil)

Blocks can be passed to `render` for templates that support running
arbitrary ruby code (usually with some form of `yield`). For instance,
assuming the following in `foo.erb`:

    Hey <%= yield %>!

The block passed to `render` is called on `yield`:

    template = Tilt::ERBTemplate.new('foo.erb')
    template.render { 'Joe' }
    # => "Hey Joe!"

Template Mappings
-----------------

The {Tilt::Mapping} class includes methods for associating template
implementation classes with filename patterns and for locating/instantiating
template classes based on those associations.

The {Tilt} module has a global instance of `Mapping` that is populated with the
table of template engines above.

The {Tilt.register} method associates a filename pattern with a specific
template implementation. To use ERB for files ending in a `.bar` extension:

     >> Tilt.register Tilt::ERBTemplate, 'bar'
     >> Tilt.new('views/foo.bar')
     => #<Tilt::ERBTemplate @file="views/foo.bar" ...>

Retrieving the template class for a file or file extension:

     >> Tilt['foo.bar']
     => Tilt::ERBTemplate
     >> Tilt['haml']
     => Tilt::HamlTemplate

Retrieving a list of template classes for a file:

    >> Tilt.templates_for('foo.bar')
    => [Tilt::ERBTemplate]
    >> Tilt.templates_for('foo.haml.bar')
    => [Tilt::ERBTemplate, Tilt::HamlTemplate]

The template class is determined by searching for a series of decreasingly
specific name patterns. When creating a new template with
`Tilt.new('views/foo.html.erb')`, we check for the following template
mappings:

  1. `views/foo.html.erb`
  2. `foo.html.erb`
  3. `html.erb`
  4. `erb`

Encodings
---------

Tilt needs to know the encoding of the template in order to work properly:

Tilt will use `Encoding.default_external` as the encoding when reading external
files. If you're mostly working with one encoding (e.g. UTF-8) we *highly*
recommend setting this option. When providing a custom reader block (`Tilt.new
{ custom_string }`) you'll have ensure the string is properly encoded yourself.

Most of the template engines in Tilt also allows you to override the encoding
using the `:default_encoding`-option:

```ruby
tmpl = Tilt.new('hello.erb', :default_encoding => 'Big5')
```

Ultimately it's up to the template engine how to handle the encoding: It might
respect `:default_encoding`, it might always assume it's UTF-8 (like
CoffeeScript), or it can do its own encoding detection.

Template Compilation
--------------------

Tilt compiles generated Ruby source code produced by template engines and reuses
it on subsequent template invocations. Benchmarks show this yields a 5x-10x
performance increase over evaluating the Ruby source on each invocation.

Template compilation is currently supported for these template engines:
StringTemplate, ERB, Erubis, Haml, Nokogiri, Builder and Yajl.

LICENSE
-------

Tilt is Copyright (c) 2010 [Ryan Tomayko](http://tomayko.com/about) and
distributed under the MIT license. See the `COPYING` file for more info.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.Mail [![Build Status](https://travis-ci.org/mikel/mail.png?branch=master)](https://travis-ci.org/mikel/mail)
====

Introduction
------------

Mail is an internet library for Ruby that is designed to handle emails
generation, parsing and sending in a simple, rubyesque manner.

The purpose of this library is to provide a single point of access to handle
all email functions, including sending and receiving emails.  All network
type actions are done through proxy methods to Net::SMTP, Net::POP3 etc.

Built from my experience with TMail, it is designed to be a pure ruby
implementation that makes generating, sending and parsing emails a no
brainer.

It is also designed from the ground up to work with the more modern versions
of Ruby.  This is because Ruby > 1.9 handles text encodings much more wonderfully
than Ruby 1.8.x and so these features have been taken full advantage of in this
library allowing Mail to handle a lot more messages more cleanly than TMail.
Mail does run on Ruby 1.8.x... it's just not as fun to code.

Finally, Mail has been designed with a very simple object oriented system
that really opens up the email messages you are parsing, if you know what
you are doing, you can fiddle with every last bit of your email directly.

Donations
-------------

Mail has been downloaded millions of times, by people around the world, in fact,
it represents more than 1% of *all* gems downloaded.

It is (like all open source software) a labour of love and something I am doing
with my own free time.  If you would like to say thanks, please feel free to
[make a donation](http://www.pledgie.com/campaigns/8790) and feel free to send
me a nice email :)

<a href='http://www.pledgie.com/campaigns/8790'><img alt='Click here to lend your support to: mail and make a donation at www.pledgie.com !' src='http://www.pledgie.com/campaigns/8790.png?skin_name=chrome' border='0' /></a>


Compatibility
-------------

Every Mail commit is tested by Travis on the [following platforms](https://github.com/mikel/mail/blob/master/.travis.yml)

* ruby-1.8.7 [ i686 ]
* ruby-1.9.2 [ x86_64 ]
* ruby-1.9.3 [ x86_64 ]
* ruby-2.0.0 [ x86_64 ]
* ruby-2.1.2 [ x86_64 ]
* ruby-head [ x86_64 ]
* jruby [ x86_64 ]
* jruby-head [ x86_64 ]
* rbx-2 [ x86_64 ]

Testing a specific mime type (needed for 1.8.7 for example) can be done manually with:

```sh
BUNDLE_GEMFILE=gemfiles/mime_types_1.16.gemfile (bundle check || bundle) && rake
```

Discussion
----------

If you want to discuss mail with like minded individuals, please subscribe to
the [Google Group](http://groups.google.com/group/mail-ruby).

Current Capabilities of Mail
----------------------------

* RFC2822 Support, Reading and Writing
* RFC2045-2049 Support for multipart emails
* Support for creating multipart alternate emails
* Support for reading multipart/report emails &amp; getting details from such
* Support for multibyte emails - needs quite a lot of work and testing
* Wrappers for File, Net/POP3, Net/SMTP
* Auto encoding of non US-ASCII header fields
* Auto encoding of non US-ASCII bodies

Mail is RFC2822 compliant now, that is, it can parse and generate valid US-ASCII
emails.  There are a few obsoleted syntax emails that it will have problems with, but
it also is quite robust, meaning, if it finds something it doesn't understand it will
not crash, instead, it will skip the problem and keep parsing.  In the case of a header
it doesn't understand, it will initialise the header as an optional unstructured
field and continue parsing.

This means Mail won't (ever) crunch your data (I think).

You can also create MIME emails.  There are helper methods for making a
multipart/alternate email for text/plain and text/html (the most common pair)
and you can manually create any other type of MIME email.

Roadmap
-------

Next TODO:

* Improve MIME support for character sets in headers, currently works, mostly, needs
  refinement.

Testing Policy
--------------

Basically... we do BDD on Mail.  No method gets written in Mail without a
corresponding or covering spec.  We expect as a minimum 100% coverage
measured by RCov.  While this is not perfect by any measure, it is pretty
good.  Additionally, all functional tests from TMail are to be passing before
the gem gets released.

It also means you can be sure Mail will behave correctly.

API Policy
----------

No API removals within a single point release.  All removals to be deprecated with
warnings for at least one MINOR point release before removal.

Also, all private or protected methods to be declared as such - though this is still I/P.

Installation
------------

Installation is fairly simple, I host mail on rubygems, so you can just do:

    # gem install mail

Encodings
---------

If you didn't know, handling encodings in Emails is not as straight forward as you
would hope.

I have tried to simplify it some:

1. All objects that can render into an email, have an `#encoded` method.  Encoded will
   return the object as a complete string ready to send in the mail system, that is,
   it will include the header field and value and CRLF at the end and wrapped as
   needed.

2. All objects that can render into an email, have a `#decoded` method.  Decoded will
   return the object's "value" only as a string.  This means it will not include
   the header fields (like 'To:' or 'Subject:').

3. By default, calling <code>#to_s</code> on a container object will call its encoded
   method, while <code>#to_s</code> on a field object will call its decoded method.
   So calling <code>#to_s</code> on a Mail object will return the mail, all encoded
   ready to send, while calling <code>#to_s</code> on the From field or the body will
   return the decoded value of the object. The header object of Mail is considered a
   container. If you are in doubt, call <code>#encoded</code>, or <code>#decoded</code>
   explicitly, this is safer if you are not sure.

4. Structured fields that have parameter values that can be encoded (e.g. Content-Type) will
   provide decoded parameter values when you call the parameter names as methods against
   the object.

5. Structured fields that have parameter values that can be encoded (e.g. Content-Type) will
   provide encoded parameter values when you call the parameter names through the
   <code>object.parameters['<parameter_name>']</code> method call.

Contributing
------------

Please do!  Contributing is easy in Mail.  Please read the CONTRIBUTING.md document for more info

Usage
-----

All major mail functions should be able to happen from the Mail module.
So, you should be able to just <code>require 'mail'</code> to get started.

### Making an email

```ruby
mail = Mail.new do
  from    'mikel@test.lindsaar.net'
  to      'you@test.lindsaar.net'
  subject 'This is a test email'
  body    File.read('body.txt')
end

mail.to_s #=> "From: mikel@test.lindsaar.net\r\nTo: you@...
```

### Making an email, have it your way:

```ruby
mail = Mail.new do
  body File.read('body.txt')
end

mail['from'] = 'mikel@test.lindsaar.net'
mail[:to]    = 'you@test.lindsaar.net'
mail.subject = 'This is a test email'

mail.header['X-Custom-Header'] = 'custom value'

mail.to_s #=> "From: mikel@test.lindsaar.net\r\nTo: you@...
```

### Don't Worry About Message IDs:

```ruby
mail = Mail.new do
  to   'you@test.lindsaar.net'
  body 'Some simple body'
end

mail.to_s =~ /Message\-ID: <[\d\w_]+@.+.mail/ #=> 27
```

Mail will automatically add a Message-ID field if it is missing and
give it a unique, random Message-ID along the lines of:

    <4a7ff76d7016_13a81ab802e1@local.host.mail>

### Or do worry about Message-IDs:

```ruby
mail = Mail.new do
  to         'you@test.lindsaar.net'
  message_id '<ThisIsMyMessageId@some.domain.com>'
  body       'Some simple body'
end

mail.to_s =~ /Message\-ID: <ThisIsMyMessageId@some.domain.com>/ #=> 27
```

Mail will take the message_id you assign to it trusting that you know
what you are doing.

### Sending an email:

Mail defaults to sending via SMTP to local host port 25.  If you have a
sendmail or postfix daemon running on on this port, sending email is as
easy as:

```ruby
Mail.deliver do
  from     'me@test.lindsaar.net'
  to       'you@test.lindsaar.net'
  subject  'Here is the image you wanted'
  body     File.read('body.txt')
  add_file '/full/path/to/somefile.png'
end
```

or

```ruby
mail = Mail.new do
  from     'me@test.lindsaar.net'
  to       'you@test.lindsaar.net'
  subject  'Here is the image you wanted'
  body     File.read('body.txt')
  add_file :filename => 'somefile.png', :content => File.read('/somefile.png')
end

mail.deliver!
```

Sending via sendmail can be done like so:

```ruby
mail = Mail.new do
  from     'me@test.lindsaar.net'
  to       'you@test.lindsaar.net'
  subject  'Here is the image you wanted'
  body     File.read('body.txt')
  add_file :filename => 'somefile.png', :content => File.read('/somefile.png')
end

mail.delivery_method :sendmail

mail.deliver
```

Sending via smtp (for example to [mailcatcher](https://github.com/sj26/mailcatcher))
```ruby

Mail.defaults do
  delivery_method :smtp, address: "localhost", port: 1025
end
```


Exim requires its own delivery manager, and can be used like so:

```ruby
mail.delivery_method :exim, :location => "/usr/bin/exim"

mail.deliver
```

### Getting emails from a pop server:

You can configure Mail to receive email using <code>retriever_method</code>
within <code>Mail.defaults</code>:

```ruby
Mail.defaults do
  retriever_method :pop3, :address    => "pop.gmail.com",
                          :port       => 995,
                          :user_name  => '<username>',
                          :password   => '<password>',
                          :enable_ssl => true
end
```

You can access incoming email in a number of ways.

The most recent email:

```ruby
Mail.all    #=> Returns an array of all emails
Mail.first  #=> Returns the first unread email
Mail.last   #=> Returns the last unread email
```

The first 10 emails sorted by date in ascending order:

```ruby
emails = Mail.find(:what => :first, :count => 10, :order => :asc)
emails.length #=> 10
```

Or even all emails:

```ruby
emails = Mail.all
emails.length #=> LOTS!
```


### Reading an Email

```ruby
mail = Mail.read('/path/to/message.eml')

mail.envelope_from   #=> 'mikel@test.lindsaar.net'
mail.from.addresses  #=> ['mikel@test.lindsaar.net', 'ada@test.lindsaar.net']
mail.sender.address  #=> 'mikel@test.lindsaar.net'
mail.to              #=> 'bob@test.lindsaar.net'
mail.cc              #=> 'sam@test.lindsaar.net'
mail.subject         #=> "This is the subject"
mail.date.to_s       #=> '21 Nov 1997 09:55:06 -0600'
mail.message_id      #=> '<4D6AA7EB.6490534@xxx.xxx>'
mail.body.decoded    #=> 'This is the body of the email...
```

Many more methods available.

### Reading a Multipart Email

```ruby
mail = Mail.read('multipart_email')

mail.multipart?          #=> true
mail.parts.length        #=> 2
mail.body.preamble       #=> "Text before the first part"
mail.body.epilogue       #=> "Text after the last part"
mail.parts.map { |p| p.content_type }  #=> ['text/plain', 'application/pdf']
mail.parts.map { |p| p.class }         #=> [Mail::Message, Mail::Message]
mail.parts[0].content_type_parameters  #=> {'charset' => 'ISO-8859-1'}
mail.parts[1].content_type_parameters  #=> {'name' => 'my.pdf'}
```

Mail generates a tree of parts.  Each message has many or no parts.  Each part
is another message which can have many or no parts.

A message will only have parts if it is a multipart/mixed or multipart/related
content type and has a boundary defined.

### Testing and extracting attachments
```ruby
mail.attachments.each do | attachment |
  # Attachments is an AttachmentsList object containing a
  # number of Part objects
  if (attachment.content_type.start_with?('image/'))
    # extracting images for example...
    filename = attachment.filename
    begin
      File.open(images_dir + filename, "w+b", 0644) {|f| f.write attachment.body.decoded}
    rescue => e
      puts "Unable to save data for #{filename} because #{e.message}"
    end
  end
end
```
### Writing and sending a multipart/alternative (html and text) email

Mail makes some basic assumptions and makes doing the common thing as
simple as possible.... (asking a lot from a mail library)

```ruby
mail = Mail.deliver do
  to      'nicolas@test.lindsaar.net.au'
  from    'Mikel Lindsaar <mikel@test.lindsaar.net.au>'
  subject 'First multipart email sent with Mail'

  text_part do
    body 'This is plain text'
  end

  html_part do
    content_type 'text/html; charset=UTF-8'
    body '<h1>This is HTML</h1>'
  end
end
```

Mail then delivers the email at the end of the block and returns the
resulting Mail::Message object, which you can then inspect if you
so desire...

```
puts mail.to_s #=>

To: nicolas@test.lindsaar.net.au
From: Mikel Lindsaar <mikel@test.lindsaar.net.au>
Subject: First multipart email sent with Mail
Content-Type: multipart/alternative;
  boundary=--==_mimepart_4a914f0c911be_6f0f1ab8026659
Message-ID: <4a914f12ac7e_6f0f1ab80267d1@baci.local.mail>
Date: Mon, 24 Aug 2009 00:15:46 +1000
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit


----==_mimepart_4a914f0c911be_6f0f1ab8026659
Content-ID: <4a914f12c8c4_6f0f1ab80268d6@baci.local.mail>
Date: Mon, 24 Aug 2009 00:15:46 +1000
Mime-Version: 1.0
Content-Type: text/plain
Content-Transfer-Encoding: 7bit

This is plain text
----==_mimepart_4a914f0c911be_6f0f1ab8026659
Content-Type: text/html; charset=UTF-8
Content-ID: <4a914f12cf86_6f0f1ab802692c@baci.local.mail>
Date: Mon, 24 Aug 2009 00:15:46 +1000
Mime-Version: 1.0
Content-Transfer-Encoding: 7bit

<h1>This is HTML</h1>
----==_mimepart_4a914f0c911be_6f0f1ab8026659--
```

Mail inserts the content transfer encoding, the mime version,
the content-id's and handles the content-type and boundary.

Mail assumes that if your text in the body is only us-ascii, that your
transfer encoding is 7bit and it is text/plain.  You can override this
by explicitly declaring it.

### Making Multipart/Alternate, without a block

You don't have to use a block with the text and html part included, you
can just do it declaratively.  However, you need to add Mail::Parts to
an email, not Mail::Messages.

```ruby
mail = Mail.new do
  to      'nicolas@test.lindsaar.net.au'
  from    'Mikel Lindsaar <mikel@test.lindsaar.net.au>'
  subject 'First multipart email sent with Mail'
end

text_part = Mail::Part.new do
  body 'This is plain text'
end

html_part = Mail::Part.new do
  content_type 'text/html; charset=UTF-8'
  body '<h1>This is HTML</h1>'
end

mail.text_part = text_part
mail.html_part = html_part
```

Results in the same email as done using the block form

### Getting error reports from an email:

```ruby
@mail = Mail.read('/path/to/bounce_message.eml')

@mail.bounced?         #=> true
@mail.final_recipient  #=> rfc822;mikel@dont.exist.com
@mail.action           #=> failed
@mail.error_status     #=> 5.5.0
@mail.diagnostic_code  #=> smtp;550 Requested action not taken: mailbox unavailable
@mail.retryable?       #=> false
```

### Attaching and Detaching Files

You can just read the file off an absolute path, Mail will try
to guess the mime_type and will encode the file in Base64 for you.

```ruby
@mail = Mail.new
@mail.add_file("/path/to/file.jpg")
@mail.parts.first.attachment? #=> true
@mail.parts.first.content_transfer_encoding.to_s #=> 'base64'
@mail.attachments.first.mime_type #=> 'image/jpg'
@mail.attachments.first.filename #=> 'file.jpg'
@mail.attachments.first.decoded == File.read('/path/to/file.jpg') #=> true
```

Or You can pass in file_data and give it a filename, again, mail
will try and guess the mime_type for you.

```ruby
@mail = Mail.new
@mail.attachments['myfile.pdf'] = File.read('path/to/myfile.pdf')
@mail.parts.first.attachment? #=> true
@mail.attachments.first.mime_type #=> 'application/pdf'
@mail.attachments.first.decoded == File.read('path/to/myfile.pdf') #=> true
```

You can also override the guessed MIME media type if you really know better
than mail (this should be rarely needed)

```ruby
@mail = Mail.new
file_data = File.read('path/to/myfile.pdf')
@mail.attachments['myfile.pdf'] = { :mime_type => 'application/x-pdf',
                                    :content => File.read('path/to/myfile.pdf') }
@mail.parts.first.mime_type #=> 'application/x-pdf'
```

Of course... Mail will round trip an attachment as well

```ruby
@mail = Mail.new do
  to      'nicolas@test.lindsaar.net.au'
  from    'Mikel Lindsaar <mikel@test.lindsaar.net.au>'
  subject 'First multipart email sent with Mail'

  text_part do
    body 'Here is the attachment you wanted'
  end

  html_part do
    content_type 'text/html; charset=UTF-8'
    body '<h1>Funky Title</h1><p>Here is the attachment you wanted</p>'
  end

  add_file '/path/to/myfile.pdf'
end

@round_tripped_mail = Mail.new(@mail.encoded)

@round_tripped_mail.attachments.length #=> 1
@round_tripped_mail.attachments.first.filename #=> 'myfile.pdf'
```
See "Testing and extracting attachments" above for more details.

Using Mail with Testing or Spec'ing Libraries
---------------------------------------------

If mail is part of your system, you'll need a way to test it without actually
sending emails, the TestMailer can do this for you.

```ruby
require 'mail'
=> true
Mail.defaults do
  delivery_method :test
end
=> #<Mail::Configuration:0x19345a8 @delivery_method=Mail::TestMailer>
Mail::TestMailer.deliveries
=> []
Mail.deliver do
  to 'mikel@me.com'
  from 'you@you.com'
  subject 'testing'
  body 'hello'
end
=> #<Mail::Message:0x19284ec ...
Mail::TestMailer.deliveries.length
=> 1
Mail::TestMailer.deliveries.first
=> #<Mail::Message:0x19284ec ...
Mail::TestMailer.deliveries.clear
=> []
```

There is also a set of RSpec matchers stolen fr^H^H^H^H^H^H^H^H inspired by Shoulda's ActionMailer matchers (you'll want to set <code>delivery_method</code> as above too):

```ruby
Mail.defaults do
  delivery_method :test # in practice you'd do this in spec_helper.rb
end

describe "sending an email" do
  include Mail::Matchers

  before(:each) do
    Mail::TestMailer.deliveries.clear

    Mail.deliver do
      to ['mikel@me.com', 'mike2@me.com']
      from 'you@you.com'
      subject 'testing'
      body 'hello'
    end
  end

  it { should have_sent_email } # passes if any email at all was sent

  it { should have_sent_email.from('you@you.com') }
  it { should have_sent_email.to('mike1@me.com') }

  # can specify a list of recipients...
  it { should have_sent_email.to(['mike1@me.com', 'mike2@me.com']) }

  # ...or chain recipients together
  it { should have_sent_email.to('mike1@me.com').to('mike2@me.com') }

  it { should have_sent_email.with_subject('testing') }

  it { should have_sent_email.with_body('hello') }

  # Can match subject or body with a regex
  # (or anything that responds_to? :match)

  it { should have_sent_email.matching_subject(/test(ing)?/) }
  it { should have_sent_email.matching_body(/h(a|e)llo/) }

  # Can chain together modifiers
  # Note that apart from recipients, repeating a modifier overwrites old value.

  it { should have_sent_email.from('you@you.com').to('mike1@me.com').matching_body(/hell/)
end
```

Excerpts from TREC Spam Corpus 2005
-----------------------------------

The spec fixture files in spec/fixtures/emails/from_trec_2005 are from the
2005 TREC Public Spam Corpus. They remain copyrighted under the terms of
that project and license agreement. They are used in this project to verify
and describe the development of this email parser implementation.

http://plg.uwaterloo.ca/~gvcormac/treccorpus/

They are used as allowed by 'Permitted Uses, Clause 3':

    "Small excerpts of the information may be displayed to others
     or published in a scientific or technical context, solely for
     the purpose of describing the research and development and
     related issues."

     -- http://plg.uwaterloo.ca/~gvcormac/treccorpus/

License
-------

(The MIT License)

Copyright (c) 2009-2013 Mikel Lindsaar

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Addressable

<dl>
  <dt>Homepage</dt><dd><a href="http://addressable.rubyforge.org/">addressable.rubyforge.org</a></dd>
  <dt>Author</dt><dd><a href="mailto:bob@sporkmonger.com">Bob Aman</a></dd>
  <dt>Copyright</dt><dd>Copyright © 2006-2015 Bob Aman</dd>
  <dt>License</dt><dd>Apache 2.0</dd>
</dl>

[![Gem Version](http://img.shields.io/gem/dt/addressable.svg)][gem]
[![Build Status](https://secure.travis-ci.org/sporkmonger/addressable.png?branch=master)][travis]
[![Dependency Status](https://gemnasium.com/sporkmonger/addressable.png?travis)][gemnasium]
[![Test Coverage Status](https://img.shields.io/coveralls/sporkmonger/addressable.svg)][coveralls]
[![Documentation Coverage Status](http://inch-ci.org/github/sporkmonger/addressable.svg?branch=master)][inch]
[![Gittip Donate](http://img.shields.io/gittip/sporkmonger.png)](https://www.gittip.com/sporkmonger/ "Support Open Source Development w/ Gittip")

[gem]: https://rubygems.org/gems/addressable
[travis]: http://travis-ci.org/sporkmonger/addressable
[gemnasium]: https://gemnasium.com/sporkmonger/addressable
[coveralls]: https://coveralls.io/r/sporkmonger/addressable
[inch]: http://inch-ci.org/github/sporkmonger/addressable

# Description

Addressable is a replacement for the URI implementation that is part of
Ruby's standard library. It more closely conforms to RFC 3986, RFC 3987, and
RFC 6570 (level 4), providing support for IRIs and URI templates.

# Reference

- {Addressable::URI}
- {Addressable::Template}

# Example usage

```ruby
require "addressable/uri"

uri = Addressable::URI.parse("http://example.com/path/to/resource/")
uri.scheme
#=> "http"
uri.host
#=> "example.com"
uri.path
#=> "/path/to/resource/"

uri = Addressable::URI.parse("http://www.詹姆斯.com/")
uri.normalize
#=> #<Addressable::URI:0xc9a4c8 URI:http://www.xn--8ws00zhy3a.com/>
```


# URI Templates

For more details, see [RFC 6570](https://www.rfc-editor.org/rfc/rfc6570.txt).


```ruby

require "addressable/template"

template = Addressable::Template.new("http://example.com/{?query*}/")
template.expand({
  "query" => {
    'foo' => 'bar',
    'color' => 'red'
  }
})
#=> #<Addressable::URI:0xc9d95c URI:http://example.com/?foo=bar&color=red>

template = Addressable::Template.new("http://example.com/{?one,two,three}/")
template.partial_expand({"one" => "1", "three" => 3}).pattern
#=> "http://example.com/?one=1{&two}&three=3"

template = Addressable::Template.new(
  "http://{host}{/segments*}/{?one,two,bogus}{#fragment}"
)
uri = Addressable::URI.parse(
  "http://example.com/a/b/c/?one=1&two=2#foo"
)
template.extract(uri)
#=>
# {
#   "host" => "example.com",
#   "segments" => ["a", "b", "c"],
#   "one" => "1",
#   "two" => "2",
#   "fragment" => "foo"
# }
```

# Install

```console
$ sudo gem install addressable
```

You may optionally turn on native IDN support by installing libidn and the
idn gem:

```console
$ sudo apt-get install idn # Debian/Ubuntu
$ sudo brew install libidn # OS X
$ sudo gem install idn-ruby
```
# http_parser.rb

A simple callback-based HTTP request/response parser for writing http
servers, clients and proxies.

This gem is built on top of [joyent/http-parser](http://github.com/joyent/http-parser) and its java port [http-parser/http-parser.java](http://github.com/http-parser/http-parser.java).

## Supported Platforms

This gem aims to work on all major Ruby platforms, including:

- MRI 1.8 and 1.9
- Rubinius
- JRuby
- win32

## Usage

```ruby
require "http/parser"

parser = Http::Parser.new

parser.on_headers_complete = proc do
  p parser.http_version

  p parser.http_method # for requests
  p parser.request_url

  p parser.status_code # for responses

  p parser.headers
end

parser.on_body = proc do |chunk|
  # One chunk of the body
  p chunk
end

parser.on_message_complete = proc do |env|
  # Headers and body is all parsed
  puts "Done!"
end
```

# Feed raw data from the socket to the parser
`parser << raw_data`

## Advanced Usage

### Accept callbacks on an object

```ruby
module MyHttpConnection
  def connection_completed
    @parser = Http::Parser.new(self)
  end

  def receive_data(data)
    @parser << data
  end

  def on_message_begin
    @headers = nil
    @body = ''
  end

  def on_headers_complete(headers)
    @headers = headers
  end

  def on_body(chunk)
    @body << chunk
  end

  def on_message_complete
    p [@headers, @body]
  end
end
```

### Stop parsing after headers

```ruby
parser = Http::Parser.new
parser.on_headers_complete = proc{ :stop }

offset = parser << request_data
body = request_data[offset..-1]
```
HTTP Parser
===========

This is a parser for HTTP messages written in C. It parses both requests and
responses. The parser is designed to be used in performance HTTP
applications. It does not make any syscalls nor allocations, it does not
buffer data, it can be interrupted at anytime. Depending on your
architecture, it only requires about 40 bytes of data per message
stream (in a web server that is per connection).

Features:

  * No dependencies
  * Handles persistent streams (keep-alive).
  * Decodes chunked encoding.
  * Upgrade support
  * Defends against buffer overflow attacks.

The parser extracts the following information from HTTP messages:

  * Header fields and values
  * Content-Length
  * Request method
  * Response status code
  * Transfer-Encoding
  * HTTP version
  * Request URL
  * Message body


Usage
-----

One `http_parser` object is used per TCP connection. Initialize the struct
using `http_parser_init()` and set the callbacks. That might look something
like this for a request parser:

    http_parser_settings settings;
    settings.on_path = my_path_callback;
    settings.on_header_field = my_header_field_callback;
    /* ... */

    http_parser *parser = malloc(sizeof(http_parser));
    http_parser_init(parser, HTTP_REQUEST);
    parser->data = my_socket;

When data is received on the socket execute the parser and check for errors.

    size_t len = 80*1024, nparsed;
    char buf[len];
    ssize_t recved;

    recved = recv(fd, buf, len, 0);

    if (recved < 0) {
      /* Handle error. */
    }

    /* Start up / continue the parser.
     * Note we pass recved==0 to signal that EOF has been recieved.
     */
    nparsed = http_parser_execute(parser, &settings, buf, recved);

    if (parser->upgrade) {
      /* handle new protocol */
    } else if (nparsed != recved) {
      /* Handle error. Usually just close the connection. */
    }

HTTP needs to know where the end of the stream is. For example, sometimes
servers send responses without Content-Length and expect the client to
consume input (for the body) until EOF. To tell http_parser about EOF, give
`0` as the forth parameter to `http_parser_execute()`. Callbacks and errors
can still be encountered during an EOF, so one must still be prepared
to receive them.

Scalar valued message information such as `status_code`, `method`, and the
HTTP version are stored in the parser structure. This data is only
temporally stored in `http_parser` and gets reset on each new message. If
this information is needed later, copy it out of the structure during the
`headers_complete` callback.

The parser decodes the transfer-encoding for both requests and responses
transparently. That is, a chunked encoding is decoded before being sent to
the on_body callback.


The Special Problem of Upgrade
------------------------------

HTTP supports upgrading the connection to a different protocol. An
increasingly common example of this is the Web Socket protocol which sends
a request like

        GET /demo HTTP/1.1
        Upgrade: WebSocket
        Connection: Upgrade
        Host: example.com
        Origin: http://example.com
        WebSocket-Protocol: sample

followed by non-HTTP data.

(See http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-75 for more
information the Web Socket protocol.)

To support this, the parser will treat this as a normal HTTP message without a
body. Issuing both on_headers_complete and on_message_complete callbacks. However
http_parser_execute() will stop parsing at the end of the headers and return.

The user is expected to check if `parser->upgrade` has been set to 1 after
`http_parser_execute()` returns. Non-HTTP data begins at the buffer supplied
offset by the return value of `http_parser_execute()`.


Callbacks
---------

During the `http_parser_execute()` call, the callbacks set in
`http_parser_settings` will be executed. The parser maintains state and
never looks behind, so buffering the data is not necessary. If you need to
save certain data for later usage, you can do that from the callbacks.

There are two types of callbacks:

* notification `typedef int (*http_cb) (http_parser*);`
    Callbacks: on_message_begin, on_headers_complete, on_message_complete.
* data `typedef int (*http_data_cb) (http_parser*, const char *at, size_t length);`
    Callbacks: (requests only) on_uri,
               (common) on_header_field, on_header_value, on_body;

Callbacks must return 0 on success. Returning a non-zero value indicates
error to the parser, making it exit immediately.

In case you parse HTTP message in chunks (i.e. `read()` request line
from socket, parse, read half headers, parse, etc) your data callbacks
may be called more than once. Http-parser guarantees that data pointer is only
valid for the lifetime of callback. You can also `read()` into a heap allocated
buffer to avoid copying memory around if this fits your application.

Reading headers may be a tricky task if you read/parse headers partially.
Basically, you need to remember whether last header callback was field or value
and apply following logic:

    (on_header_field and on_header_value shortened to on_h_*)
     ------------------------ ------------ --------------------------------------------
    | State (prev. callback) | Callback   | Description/action                         |
     ------------------------ ------------ --------------------------------------------
    | nothing (first call)   | on_h_field | Allocate new buffer and copy callback data |
    |                        |            | into it                                    |
     ------------------------ ------------ --------------------------------------------
    | value                  | on_h_field | New header started.                        |
    |                        |            | Copy current name,value buffers to headers |
    |                        |            | list and allocate new buffer for new name  |
     ------------------------ ------------ --------------------------------------------
    | field                  | on_h_field | Previous name continues. Reallocate name   |
    |                        |            | buffer and append callback data to it      |
     ------------------------ ------------ --------------------------------------------
    | field                  | on_h_value | Value for current header started. Allocate |
    |                        |            | new buffer and copy callback data to it    |
     ------------------------ ------------ --------------------------------------------
    | value                  | on_h_value | Value continues. Reallocate value buffer   |
    |                        |            | and append callback data to it             |
     ------------------------ ------------ --------------------------------------------


Parsing URLs
------------

A simplistic zero-copy URL parser is provided as `http_parser_parse_url()`.
Users of this library may wish to use it to parse URLs constructed from
consecutive `on_url` callbacks.

See examples of reading in headers:

* [partial example](http://gist.github.com/155877) in C
* [from http-parser tests](http://github.com/ry/http-parser/blob/37a0ff8928fb0d83cec0d0d8909c5a4abcd221af/test.c#L403) in C
* [from Node library](http://github.com/ry/node/blob/842eaf446d2fdcb33b296c67c911c32a0dabc747/src/http.js#L284) in Javascript
HTTP Parser
===========

This is a parser for HTTP written in Java, based quite heavily on
the Ryan Dahl's C Version: `http-parser` available here:

  http://github.com/ry/http-parser

It parses both requests and responses. The parser is designed to be used
in performance HTTP applications. 

Features:

  * No dependencies (probably won't be able to keep it up)
  * Handles persistent streams (keep-alive).
  * Decodes chunked encoding.
  * Upgrade support

The parser extracts the following information from HTTP messages:

  * Header fields and values
  * Content-Length
  * Request method
  * Response status code
  * Transfer-Encoding
  * HTTP version
  * Request URL
  * Message body

Building
--------

use `ant compile|test|jar`

Usage
-----

  TODO: in the present form, usage of the Java version of the parser
  shouldn't be too difficult to figure out for someone familiar with the
  C version.

  More documentation will follow shortly, in case you're looking for an
  easy to use http library, this lib is probably not what you are
  looking for anyway ...

  All text after this paragraph (and most of the text above it) are from
  the original C version of the README and are currently only here for
  reference. In case you encounter any difficulties, find bugs, need
  help or have suggestions, feel free to contact me at
  (tim.becker@kuriositaet.de).


One `http_parser` object is used per TCP connection. Initialize the struct
using `http_parser_init()` and set the callbacks. That might look something
like this for a request parser:

    http_parser_settings settings;
    settings.on_path = my_path_callback;
    settings.on_header_field = my_header_field_callback;
    /* ... */

    http_parser *parser = malloc(sizeof(http_parser));
    http_parser_init(parser, HTTP_REQUEST);
    parser->data = my_socket;

When data is received on the socket execute the parser and check for errors.

    size_t len = 80*1024, nparsed;
    char buf[len];
    ssize_t recved;

    recved = recv(fd, buf, len, 0);

    if (recved < 0) {
      /* Handle error. */
    }

    /* Start up / continue the parser.
     * Note we pass recved==0 to signal that EOF has been recieved.
     */
    nparsed = http_parser_execute(parser, &settings, buf, recved);

    if (parser->upgrade) {
      /* handle new protocol */
    } else if (nparsed != recved) {
      /* Handle error. Usually just close the connection. */
    }

HTTP needs to know where the end of the stream is. For example, sometimes
servers send responses without Content-Length and expect the client to
consume input (for the body) until EOF. To tell http_parser about EOF, give
`0` as the forth parameter to `http_parser_execute()`. Callbacks and errors
can still be encountered during an EOF, so one must still be prepared
to receive them.

Scalar valued message information such as `status_code`, `method`, and the
HTTP version are stored in the parser structure. This data is only
temporally stored in `http_parser` and gets reset on each new message. If
this information is needed later, copy it out of the structure during the
`headers_complete` callback.

The parser decodes the transfer-encoding for both requests and responses
transparently. That is, a chunked encoding is decoded before being sent to
the on_body callback.


The Special Problem of Upgrade
------------------------------

HTTP supports upgrading the connection to a different protocol. An
increasingly common example of this is the Web Socket protocol which sends
a request like

        GET /demo HTTP/1.1
        Upgrade: WebSocket
        Connection: Upgrade
        Host: example.com
        Origin: http://example.com
        WebSocket-Protocol: sample

followed by non-HTTP data.

(See http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-75 for more
information the Web Socket protocol.)

To support this, the parser will treat this as a normal HTTP message without a
body. Issuing both on_headers_complete and on_message_complete callbacks. However
http_parser_execute() will stop parsing at the end of the headers and return.

The user is expected to check if `parser->upgrade` has been set to 1 after
`http_parser_execute()` returns. Non-HTTP data begins at the buffer supplied
offset by the return value of `http_parser_execute()`.


Callbacks
---------

During the `http_parser_execute()` call, the callbacks set in
`http_parser_settings` will be executed. The parser maintains state and
never looks behind, so buffering the data is not necessary. If you need to
save certain data for later usage, you can do that from the callbacks.

There are two types of callbacks:

* notification `typedef int (*http_cb) (http_parser*);`
    Callbacks: on_message_begin, on_headers_complete, on_message_complete.
* data `typedef int (*http_data_cb) (http_parser*, const char *at, size_t length);`
    Callbacks: (requests only) on_uri,
               (common) on_header_field, on_header_value, on_body;

Callbacks must return 0 on success. Returning a non-zero value indicates
error to the parser, making it exit immediately.

In case you parse HTTP message in chunks (i.e. `read()` request line
from socket, parse, read half headers, parse, etc) your data callbacks
may be called more than once. Http-parser guarantees that data pointer is only
valid for the lifetime of callback. You can also `read()` into a heap allocated
buffer to avoid copying memory around if this fits your application.

Reading headers may be a tricky task if you read/parse headers partially.
Basically, you need to remember whether last header callback was field or value
and apply following logic:

    (on_header_field and on_header_value shortened to on_h_*)
     ------------------------ ------------ --------------------------------------------
    | State (prev. callback) | Callback   | Description/action                         |
     ------------------------ ------------ --------------------------------------------
    | nothing (first call)   | on_h_field | Allocate new buffer and copy callback data |
    |                        |            | into it                                    |
     ------------------------ ------------ --------------------------------------------
    | value                  | on_h_field | New header started.                        |
    |                        |            | Copy current name,value buffers to headers |
    |                        |            | list and allocate new buffer for new name  |
     ------------------------ ------------ --------------------------------------------
    | field                  | on_h_field | Previous name continues. Reallocate name   |
    |                        |            | buffer and append callback data to it      |
     ------------------------ ------------ --------------------------------------------
    | field                  | on_h_value | Value for current header started. Allocate |
    |                        |            | new buffer and copy callback data to it    |
     ------------------------ ------------ --------------------------------------------
    | value                  | on_h_value | Value continues. Reallocate value buffer   |
    |                        |            | and append callback data to it             |
     ------------------------ ------------ --------------------------------------------
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.= geoip

http://github.com/cjheath/geoip

== DESCRIPTION:

GeoIP searches a GeoIP database for a given host or IP address, and
returns information about the country where the IP address is allocated,
and the city, ISP and other information, if you have that database version.

== FEATURES/PROBLEMS:

Includes support for ASN data files, thanks to Roland Matiz.
This release adds support for timezone names, thanks to Tonni Aagesen.

If you have required 'io/extra' and have IO#pread, cross-process file-descriptor sharing is enabled.
Each GeoIP instance keeps the file descriptor open, with a Mutex for thread-safety.
You should consider this if your process will fork without exec, as
{modrails does}[http://www.modrails.com/documentation/Users%20guide%20Nginx.html#_smart_spawning_gotcha_1_unintential_file_descriptor_sharing]

== SYNOPSIS:

  require 'geoip'

  # Use the country database:
  c = GeoIP.new('GeoIP.dat').country('www.nokia.com')
  => ["www.nokia.com", "147.243.3.83", 69, "FI", "FIN", "Finland", "EU"]
  c.country_code3
  => "FIN"
  c.to_hash
  => {:country_code3=>"FIN", :country_name=>"Finland", :continent_code=>"EU", :request=>"www.nokia.com", :country_code=>69, :country_code2=>"FI", :ip=>"147.243.3.83"}

Returned values are the requested hostname, the IP address as a dotted quad,
Maxmind's country code, the ISO3166-1 alpha-2 country code, the ISO3166-2 alpha-3
country code, the ISO3166 country name, and the continent code.

  # Use the city database:
  c = GeoIP.new('GeoLiteCity.dat').city('github.com')
  => ["github.com", "207.97.227.239", "US", "USA", "United States", "NA", "CA", "San Francisco", "94110", 37.7484, -122.4156, 807, 415, "America/Los_Angeles"]
  >> c.longitude
  => -122.4156
  >> c.timezone
  => "America/Los_Angeles"

  GeoIP.new('GeoCity.dat').city('github.com')
  => ["github.com", "207.97.227.239", "US", "USA", "United States", "NA", "CA", "San Francisco", "94110", 37.7484, -122.4156, 807, 415, "America/Los_Angeles"]

  # Use the city ipv6 database:
  GeoIP.new('GeoLiteCityv6.dat').city('::151.38.39.114')
  => ["::151.38.39.114", "::151.38.39.114", "IT", "ITA", "Italy", "EU", "05", "Piacenza", "", 45.016699999999986, 9.666699999999992, nil, nil, "Europe/Rome"]

Returned values are the requested hostname, the IP address as a dotted quad,
the ISO3166-1 alpha-2 country code, the ISO3166-2 alpha-3 country code, the
ISO3166 country name, the continent code, the region (state or territory) name,
city name, postal_code/zipcode, latitude, longitude, USA DMA code, USA area code,
timezone name.

Result arrays from both city and country have mixed-in accessor methods as appropriate:
request, ip, country_code, country_code2, country_code3, country_name, continent_code,
region_name, city_name, postal_code, latitude, longitude, dma_code, area_code, timezone

  GeoIP.new('GeoIPASNum.dat').asn("www.fsb.ru")
  => ["AS8342", "RTComm.RU Autonomous System"]

== REQUIREMENTS:

You need one of the free GeoLite country, city or ASN databases, or a subscription database version.
The last known download locations for the GeoLite database versions are
<http://geolite.maxmind.com/download/geoip/database/GeoLiteCountry/GeoIP.dat.gz>,
<http://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz>,
<http://geolite.maxmind.com/download/geoip/database/asnum/GeoIPASNum.dat.gz>.

This API requires the file to be decompressed for searching. Other versions
of this database are available for purchase which contain more detailed
information, but this information is not returned by this implementation.
See www.maxmind.com for more information.

== INSTALL:

sudo gem install geoip

== LICENSE:

This version Copyright (C) 2005 Clifford Heath
Derived from the C version, Copyright (C) 2003 MaxMind LLC

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public License,
as published by the Free Software Foundation; either version 2.1 of
the License, or (at your option) any later version. This follows the
license applied by Maxmind to their C library, for example in the
version here:
<http://www.maxmind.com/download/geoip/api/c/GeoIP-1.4.2.tar.gz>.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# AVL tree, Red-black tree in Ruby

avl_tree - AVL tree, Red-black tree and Lock-free Red black tree in Ruby
Copyright (C) 2014 Hiroshi Nakamura <nahi@ruby-lang.org>


## Usage

You can use AVLTree, RedBlackTree or ConcurrentRedBlackTree just as a
replacement of Hash.

    @points = Hash.new
    ...
    @points[score] = person
    ...
    @points.each do |score, person|
      ...
    end

    ->

    require 'avl_tree'
    @points = AVLTree.new

    require 'red_black_tree'
    @points = RedBlackTree.new
    @points = ConcurrentRedBlackTree.new

AVLTree and RedBlackTree are faster but not thread-safe.  Use ConcurrentRedBlackTree in multi-thread environment.

## Author

Name:: Hiroshi Nakamura
E-mail:: nahi@ruby-lang.org
Project web site:: http://github.com/nahi/avl_tree


## License

This program is copyrighted free software by Hiroshi Nakamura.  You can
redistribute it and/or modify it under the same terms of Ruby's license;
either the dual license version in 2003, or any later version.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.ffi-rzmq-core
=============

The intention of this gem is to provide a very basic FFI wrapper around the Zeromq libzmq C API.
This gem isn't intended to be used directly by any Ruby programmer looking to write Zeromq code.
They should use a higher-level gem like ffi-rzmq which pulls in this gem for its FFI definitions.

There have been complaints that the ffi-rzmq gem doesn't provide the correct or best Ruby idioms, so I am
hoping this encourages other library writers to create their own. Rather than duplicate the FFI
wrapping code, they can just pull in this gem and build a more idiomatic library around the
basic definitions.

See [ffi-rzmq]

### Development

As this library supports both ZeroMQ 3.2+ and ZeroMQ 4.0+ it's common to have to swap out
which version of ZeroMQ is installed to test out various features (say, 4.0 for security).

With Homebrew on Mac OS X this is easy enough. The main ZeroMQ formula installs 4.0. To get
version 3.2 pull in the homebrew-versions using:

  brew tap homebrew/versions

and install version 3.2:

  brew install zeromq32
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.= Rack, a modular Ruby webserver interface {<img src="https://secure.travis-ci.org/rack/rack.svg" alt="Build Status" />}[http://travis-ci.org/rack/rack] {<img src="https://gemnasium.com/rack/rack.svg" alt="Dependency Status" />}[https://gemnasium.com/rack/rack]

Rack provides a minimal, modular and adaptable interface for developing
web applications in Ruby.  By wrapping HTTP requests and responses in
the simplest way possible, it unifies and distills the API for web
servers, web frameworks, and software in between (the so-called
middleware) into a single method call.

The exact details of this are described in the Rack specification,
which all Rack applications should conform to.

== Supported web servers

The included *handlers* connect all kinds of web servers to Rack:
* Mongrel
* EventedMongrel
* SwiftipliedMongrel
* WEBrick
* FCGI
* CGI
* SCGI
* LiteSpeed
* Thin

These web servers include Rack handlers in their distributions:
* Ebb
* Fuzed
* Glassfish v3
* Phusion Passenger (which is mod_rack for Apache and for nginx)
* Puma
* Rainbows!
* Reel
* Unicorn
* unixrack
* uWSGI
* yahns
* Zbatery

Any valid Rack app will run the same on all these handlers, without
changing anything.

== Supported web frameworks

These frameworks include Rack adapters in their distributions:
* Camping
* Coset
* Espresso
* Halcyon
* Mack
* Maveric
* Merb
* Racktools::SimpleApplication
* Ramaze
* Ruby on Rails
* Rum
* Sinatra
* Sin
* Vintage
* Waves
* Wee
* ... and many others.

== Available middleware

Between the server and the framework, Rack can be customized to your
applications needs using middleware, for example:
* Rack::URLMap, to route to multiple applications inside the same process.
* Rack::CommonLogger, for creating Apache-style logfiles.
* Rack::ShowException, for catching unhandled exceptions and
  presenting them in a nice and helpful way with clickable backtrace.
* Rack::File, for serving static files.
* ...many others!

All these components use the same interface, which is described in
detail in the Rack specification.  These optional components can be
used in any way you wish.

== Convenience

If you want to develop outside of existing frameworks, implement your
own ones, or develop middleware, Rack provides many helpers to create
Rack applications quickly and without doing the same web stuff all
over:
* Rack::Request, which also provides query string parsing and
  multipart handling.
* Rack::Response, for convenient generation of HTTP replies and
  cookie handling.
* Rack::MockRequest and Rack::MockResponse for efficient and quick
  testing of Rack application without real HTTP round-trips.

== rack-contrib

The plethora of useful middleware created the need for a project that
collects fresh Rack middleware.  rack-contrib includes a variety of
add-on components for Rack and it is easy to contribute new modules.

* http://github.com/rack/rack-contrib

== rackup

rackup is a useful tool for running Rack applications, which uses the
Rack::Builder DSL to configure middleware and build up applications
easily.

rackup automatically figures out the environment it is run in, and
runs your application as FastCGI, CGI, or standalone with Mongrel or
WEBrick---all from the same configuration.

== Quick start

Try the lobster!

Either with the embedded WEBrick starter:

    ruby -Ilib lib/rack/lobster.rb

Or with rackup:

    bin/rackup -Ilib example/lobster.ru

By default, the lobster is found at http://localhost:9292.

== Installing with RubyGems

A Gem of Rack is available at rubygems.org.  You can install it with:

    gem install rack

I also provide a local mirror of the gems (and development snapshots)
at my site:

    gem install rack --source http://chneukirchen.org/releases/gems/

== Running the tests

Testing Rack requires the bacon testing framework:

    bundle install --without extra # to be able to run the fast tests

Or:

    bundle install # this assumes that you have installed native extensions!

There are two rake-based test tasks:

    rake test       tests all the fast tests (no Handlers or Adapters)
    rake fulltest   runs all the tests

The fast testsuite has no dependencies outside of the core Ruby
installation and bacon.

To run the test suite completely, you need:

  * fcgi
  * memcache-client
  * mongrel
  * thin

The full set of tests test FCGI access with lighttpd (on port
9203) so you will need lighttpd installed as well as the FCGI
libraries and the fcgi gem:

Download and install lighttpd:

    http://www.lighttpd.net/download

Installing the FCGI libraries:

    curl -O http://www.fastcgi.com/dist/fcgi-2.4.0.tar.gz
    tar xzvf fcgi-2.4.0.tar.gz
    cd fcgi-2.4.0
    ./configure --prefix=/usr/local
    make
    sudo make install
    cd ..

Installing the Ruby fcgi gem:

    gem install fcgi

Furthermore, to test Memcache sessions, you need memcached (will be
run on port 11211) and memcache-client installed.

== Configuration

Several parameters can be modified on `Rack::Utils` to configure Rack behaviour.

e.g:

```ruby
Rack::Utils.key_space_limit = 128
```

=== key_space_limit

The default number of bytes to allow a single parameter key to take up.
This helps prevent a rogue client from flooding a Request.

Default to 65536 characters (4 kiB in worst case).

=== multipart_part_limit

The maximum number of parts a request can contain.
Accepting too many part can lead to the server running out of file handles.

The default is `128`, which mean that a single request can't upload more than 128 files at once.

Set to `0` for not limit.

Can also be set via the `RACK_MULTIPART_PART_LIMIT` environment variable.

== History

* March 3rd, 2007: First public release 0.1.

* May 16th, 2007: Second public release 0.2.
  * HTTP Basic authentication.
  * Cookie Sessions.
  * Static file handler.
  * Improved Rack::Request.
  * Improved Rack::Response.
  * Added Rack::ShowStatus, for better default error messages.
  * Bug fixes in the Camping adapter.
  * Removed Rails adapter, was too alpha.

* February 26th, 2008: Third public release 0.3.
  * LiteSpeed handler, by Adrian Madrid.
  * SCGI handler, by Jeremy Evans.
  * Pool sessions, by blink.
  * OpenID authentication, by blink.
  * :Port and :File options for opening FastCGI sockets, by blink.
  * Last-Modified HTTP header for Rack::File, by blink.
  * Rack::Builder#use now accepts blocks, by Corey Jewett.
    (See example/protectedlobster.ru)
  * HTTP status 201 can contain a Content-Type and a body now.
  * Many bugfixes, especially related to Cookie handling.

* August 21st, 2008: Fourth public release 0.4.
  * New middleware, Rack::Deflater, by Christoffer Sawicki.
  * OpenID authentication now needs ruby-openid 2.
  * New Memcache sessions, by blink.
  * Explicit EventedMongrel handler, by Joshua Peek <josh@joshpeek.com>
  * Rack::Reloader is not loaded in rackup development mode.
  * rackup can daemonize with -D.
  * Many bugfixes, especially for pool sessions, URLMap, thread safety
    and tempfile handling.
  * Improved tests.
  * Rack moved to Git.

* January 6th, 2009: Fifth public release 0.9.
  * Rack is now managed by the Rack Core Team.
  * Rack::Lint is stricter and follows the HTTP RFCs more closely.
  * Added ConditionalGet middleware.
  * Added ContentLength middleware.
  * Added Deflater middleware.
  * Added Head middleware.
  * Added MethodOverride middleware.
  * Rack::Mime now provides popular MIME-types and their extension.
  * Mongrel Header now streams.
  * Added Thin handler.
  * Official support for swiftiplied Mongrel.
  * Secure cookies.
  * Made HeaderHash case-preserving.
  * Many bugfixes and small improvements.

* January 9th, 2009: Sixth public release 0.9.1.
  * Fix directory traversal exploits in Rack::File and Rack::Directory.

* April 25th, 2009: Seventh public release 1.0.0.
  * SPEC change: Rack::VERSION has been pushed to [1,0].
  * SPEC change: header values must be Strings now, split on "\n".
  * SPEC change: Content-Length can be missing, in this case chunked transfer
    encoding is used.
  * SPEC change: rack.input must be rewindable and support reading into
    a buffer, wrap with Rack::RewindableInput if it isn't.
  * SPEC change: rack.session is now specified.
  * SPEC change: Bodies can now additionally respond to #to_path with
    a filename to be served.
  * NOTE: String bodies break in 1.9, use an Array consisting of a
    single String instead.
  * New middleware Rack::Lock.
  * New middleware Rack::ContentType.
  * Rack::Reloader has been rewritten.
  * Major update to Rack::Auth::OpenID.
  * Support for nested parameter parsing in Rack::Response.
  * Support for redirects in Rack::Response.
  * HttpOnly cookie support in Rack::Response.
  * The Rakefile has been rewritten.
  * Many bugfixes and small improvements.

* October 18th, 2009: Eighth public release 1.0.1.
  * Bump remainder of rack.versions.
  * Support the pure Ruby FCGI implementation.
  * Fix for form names containing "=": split first then unescape components
  * Fixes the handling of the filename parameter with semicolons in names.
  * Add anchor to nested params parsing regexp to prevent stack overflows
  * Use more compatible gzip write api instead of "<<".
  * Make sure that Reloader doesn't break when executed via ruby -e
  * Make sure WEBrick respects the :Host option
  * Many Ruby 1.9 fixes.

* January 3rd, 2010: Ninth public release 1.1.0.
  * Moved Auth::OpenID to rack-contrib.
  * SPEC change that relaxes Lint slightly to allow subclasses of the
    required types
  * SPEC change to document rack.input binary mode in greator detail
  * SPEC define optional rack.logger specification
  * File servers support X-Cascade header
  * Imported Config middleware
  * Imported ETag middleware
  * Imported Runtime middleware
  * Imported Sendfile middleware
  * New Logger and NullLogger middlewares
  * Added mime type for .ogv and .manifest.
  * Don't squeeze PATH_INFO slashes
  * Use Content-Type to determine POST params parsing
  * Update Rack::Utils::HTTP_STATUS_CODES hash
  * Add status code lookup utility
  * Response should call #to_i on the status
  * Add Request#user_agent
  * Request#host knows about forwared host
  * Return an empty string for Request#host if HTTP_HOST and
    SERVER_NAME are both missing
  * Allow MockRequest to accept hash params
  * Optimizations to HeaderHash
  * Refactored rackup into Rack::Server
  * Added Utils.build_nested_query to complement Utils.parse_nested_query
  * Added Utils::Multipart.build_multipart to complement
    Utils::Multipart.parse_multipart
  * Extracted set and delete cookie helpers into Utils so they can be
    used outside Response
  * Extract parse_query and parse_multipart in Request so subclasses
    can change their behavior
  * Enforce binary encoding in RewindableInput
  * Set correct external_encoding for handlers that don't use RewindableInput

* June 13th, 2010: Tenth public release 1.2.0.
  * Removed Camping adapter: Camping 2.0 supports Rack as-is
  * Removed parsing of quoted values
  * Add Request.trace? and Request.options?
  * Add mime-type for .webm and .htc
  * Fix HTTP_X_FORWARDED_FOR
  * Various multipart fixes
  * Switch test suite to bacon

* June 15th, 2010: Eleventh public release 1.2.1.
  * Make CGI handler rewindable
  * Rename spec/ to test/ to not conflict with SPEC on lesser
    operating systems

* March 13th, 2011: Twelfth public release 1.2.2/1.1.2.
  * Security fix in Rack::Auth::Digest::MD5: when authenticator
    returned nil, permission was granted on empty password.

* May 22nd, 2011: Thirteenth public release 1.3.0
  * Various performance optimizations
  * Various multipart fixes
  * Various multipart refactors
  * Infinite loop fix for multipart
  * Test coverage for Rack::Server returns
  * Allow files with '..', but not path components that are '..'
  * rackup accepts handler-specific options on the command line
  * Request#params no longer merges POST into GET (but returns the same)
  * Use URI.encode_www_form_component instead. Use core methods for escaping.
  * Allow multi-line comments in the config file
  * Bug L#94 reported by Nikolai Lugovoi, query parameter unescaping.
  * Rack::Response now deletes Content-Length when appropriate
  * Rack::Deflater now supports streaming
  * Improved Rack::Handler loading and searching
  * Support for the PATCH verb
  * env['rack.session.options'] now contains session options
  * Cookies respect renew
  * Session middleware uses SecureRandom.hex

* May 22nd, 2011: Fourteenth public release 1.2.3
  * Pulled in relevant bug fixes from 1.3
  * Fixed 1.8.6 support

* July 13, 2011: Fifteenth public release 1.3.1
  * Fix 1.9.1 support
  * Fix JRuby support
  * Properly handle $KCODE in Rack::Utils.escape
  * Make method_missing/respond_to behavior consistent for Rack::Lock,
    Rack::Auth::Digest::Request and Rack::Multipart::UploadedFile
  * Reenable passing rack.session to session middleware
  * Rack::CommonLogger handles streaming responses correctly
  * Rack::MockResponse calls close on the body object
  * Fix a DOS vector from MRI stdlib backport

* July 16, 2011: Sixteenth public release 1.3.2
  * Fix for Rails and rack-test, Rack::Utils#escape calls to_s

* September 16, 2011: Seventeenth public release 1.3.3
  * Fix bug with broken query parameters in Rack::ShowExceptions
  * Rack::Request#cookies no longer swallows exceptions on broken input
  * Prevents XSS attacks enabled by bug in Ruby 1.8's regexp engine
  * Rack::ConditionalGet handles broken If-Modified-Since helpers

* September 16, 2011: Eighteenth public release 1.2.4
  * Fix a bug with MRI regex engine to prevent XSS by malformed unicode

* October 1, 2011: Nineteenth public release 1.3.4
  * Backport security fix from 1.9.3, also fixes some roundtrip issues in URI
  * Small documentation update
  * Fix an issue where BodyProxy could cause an infinite recursion
  * Add some supporting files for travis-ci

* October 17, 2011: Twentieth public release 1.3.5
  * Fix annoying warnings caused by the backport in 1.3.4

* December 28th, 2011: Twenty first public release: 1.1.3.
  * Security fix. http://www.ocert.org/advisories/ocert-2011-003.html
    Further information here: http://jruby.org/2011/12/27/jruby-1-6-5-1

* December 28th, 2011: Twenty fourth public release 1.4.0
  * Ruby 1.8.6 support has officially been dropped. Not all tests pass.
  * Raise sane error messages for broken config.ru
  * Allow combining run and map in a config.ru
  * Rack::ContentType will not set Content-Type for responses without a body
  * Status code 205 does not send a response body
  * Rack::Response::Helpers will not rely on instance variables
  * Rack::Utils.build_query no longer outputs '=' for nil query values
  * Various mime types added
  * Rack::MockRequest now supports HEAD
  * Rack::Directory now supports files that contain RFC3986 reserved chars
  * Rack::File now only supports GET and HEAD requests
  * Rack::Server#start now passes the block to Rack::Handler::<h>#run
  * Rack::Static now supports an index option
  * Added the Teapot status code
  * rackup now defaults to Thin instead of Mongrel (if installed)
  * Support added for HTTP_X_FORWARDED_SCHEME
  * Numerous bug fixes, including many fixes for new and alternate rubies

* January 22nd, 2012: Twenty fifth public release 1.4.1
  * Alter the keyspace limit calculations to reduce issues with nested params
  * Add a workaround for multipart parsing where files contain unescaped "%"
  * Added Rack::Response::Helpers#method_not_allowed? (code 405)
  * Rack::File now returns 404 for illegal directory traversals
  * Rack::File now returns 405 for illegal methods (non HEAD/GET)
  * Rack::Cascade now catches 405 by default, as well as 404
  * Cookies missing '--' no longer cause an exception to be raised
  * Various style changes and documentation spelling errors
  * Rack::BodyProxy always ensures to execute its block
  * Additional test coverage around cookies and secrets
  * Rack::Session::Cookie can now be supplied either secret or old_secret
  * Tests are no longer dependent on set order
  * Rack::Static no longer defaults to serving index files
  * Rack.release was fixed

* January 6th, 2013: Twenty sixth public release 1.1.4
  * Add warnings when users do not provide a session secret

* January 6th, 2013: Twenty seventh public release 1.2.6
  * Add warnings when users do not provide a session secret
  * Fix parsing performance for unquoted filenames

* January 6th, 2013: Twenty eighth public release 1.3.7
  * Add warnings when users do not provide a session secret
  * Fix parsing performance for unquoted filenames
  * Updated URI backports
  * Fix URI backport version matching, and silence constant warnings
  * Correct parameter parsing with empty values
  * Correct rackup '-I' flag, to allow multiple uses
  * Correct rackup pidfile handling
  * Report rackup line numbers correctly
  * Fix request loops caused by non-stale nonces with time limits
  * Fix reloader on Windows
  * Prevent infinite recursions from Response#to_ary
  * Various middleware better conforms to the body close specification
  * Updated language for the body close specification
  * Additional notes regarding ECMA escape compatibility issues
  * Fix the parsing of multiple ranges in range headers

* January 6th, 2013: Twenty ninth public release 1.4.2
  * Add warnings when users do not provide a session secret
  * Fix parsing performance for unquoted filenames
  * Updated URI backports
  * Fix URI backport version matching, and silence constant warnings
  * Correct parameter parsing with empty values
  * Correct rackup '-I' flag, to allow multiple uses
  * Correct rackup pidfile handling
  * Report rackup line numbers correctly
  * Fix request loops caused by non-stale nonces with time limits
  * Fix reloader on Windows
  * Prevent infinite recursions from Response#to_ary
  * Various middleware better conforms to the body close specification
  * Updated language for the body close specification
  * Additional notes regarding ECMA escape compatibility issues
  * Fix the parsing of multiple ranges in range headers
  * Prevent errors from empty parameter keys
  * Added PATCH verb to Rack::Request
  * Various documentation updates
  * Fix session merge semantics (fixes rack-test)
  * Rack::Static :index can now handle multiple directories
  * All tests now utilize Rack::Lint (special thanks to Lars Gierth)
  * Rack::File cache_control parameter is now deprecated, and removed by 1.5
  * Correct Rack::Directory script name escaping
  * Rack::Static supports header rules for sophisticated configurations
  * Multipart parsing now works without a Content-Length header
  * New logos courtesy of Zachary Scott!
  * Rack::BodyProxy now explicitly defines #each, useful for C extensions
  * Cookies that are not URI escaped no longer cause exceptions

* January 7th, 2013: Thirtieth public release 1.3.8
  * Security: Prevent unbounded reads in large multipart boundaries

* January 7th, 2013: Thirty first public release 1.4.3
  * Security: Prevent unbounded reads in large multipart boundaries

* January 13th, 2013: Thirty second public release 1.4.4, 1.3.9, 1.2.7, 1.1.5
  * [SEC] Rack::Auth::AbstractRequest no longer symbolizes arbitrary strings
  * Fixed erroneous test case in the 1.3.x series

* January 21st, 2013: Thirty third public release 1.5.0
  * Introduced hijack SPEC, for before-response and after-response hijacking
  * SessionHash is no longer a Hash subclass
  * Rack::File cache_control parameter is removed, in place of headers options
  * Rack::Auth::AbstractRequest#scheme now yields strings, not symbols
  * Rack::Utils cookie functions now format expires in RFC 2822 format
  * Rack::File now has a default mime type
  * rackup -b 'run Rack::File.new(".")', option provides command line configs
  * Rack::Deflater will no longer double encode bodies
  * Rack::Mime#match? provides convenience for Accept header matching
  * Rack::Utils#q_values provides splitting for Accept headers
  * Rack::Utils#best_q_match provides a helper for Accept headers
  * Rack::Handler.pick provides convenience for finding available servers
  * Puma added to the list of default servers (preferred over Webrick)
  * Various middleware now correctly close body when replacing it
  * Rack::Request#params is no longer persistent with only GET params
  * Rack::Request#update_param and #delete_param provide persistent operations
  * Rack::Request#trusted_proxy? now returns true for local unix sockets
  * Rack::Response no longer forces Content-Types
  * Rack::Sendfile provides local mapping configuration options
  * Rack::Utils#rfc2109 provides old netscape style time output
  * Updated HTTP status codes
  * Ruby 1.8.6 likely no longer passes tests, and is no longer fully supported

* January 28th, 2013: Thirty fourth public release 1.5.1
  * Rack::Lint check_hijack now conforms to other parts of SPEC
  * Added hash-like methods to Abstract::ID::SessionHash for compatibility
  * Various documentation corrections

* February 7th, Thirty fifth public release 1.1.6, 1.2.8, 1.3.10
  * Fix CVE-2013-0263, timing attack against Rack::Session::Cookie

* February 7th, Thirty fifth public release 1.4.5
  * Fix CVE-2013-0263, timing attack against Rack::Session::Cookie
  * Fix CVE-2013-0262, symlink path traversal in Rack::File

* February 7th, Thirty fifth public release 1.5.2
  * Fix CVE-2013-0263, timing attack against Rack::Session::Cookie
  * Fix CVE-2013-0262, symlink path traversal in Rack::File
  * Add various methods to Session for enhanced Rails compatibility
  * Request#trusted_proxy? now only matches whole stirngs
  * Add JSON cookie coder, to be default in Rack 1.6+ due to security concerns
  * URLMap host matching in environments that don't set the Host header fixed
  * Fix a race condition that could result in overwritten pidfiles
  * Various documentation additions

== Contact

Please post bugs, suggestions and patches to
the bug tracker at <http://github.com/rack/rack/issues>.

Please post security related bugs and suggestions to the core team at
<https://groups.google.com/group/rack-core> or rack-core@googlegroups.com. This
list is not public. Due to wide usage of the library, it is strongly preferred
that we manage timing in order to provide viable patches at the time of
disclosure. Your assistance in this matter is greatly appreciated.

Mailing list archives are available at
<http://groups.google.com/group/rack-devel>.

Git repository (send Git patches to the mailing list):
* http://github.com/rack/rack
* http://git.vuxu.org/cgi-bin/gitweb.cgi?p=rack-github.git

You are also welcome to join the #rack channel on irc.freenode.net.

== Thanks

The Rack Core Team, consisting of

* Christian Neukirchen (chneukirchen)
* James Tucker (raggi)
* Josh Peek (josh)
* José Valim (josevalim)
* Michael Fellinger (manveru)
* Aaron Patterson (tenderlove)
* Santiago Pastorino (spastorino)
* Konstantin Haase (rkh)

and the Rack Alumnis

* Ryan Tomayko (rtomayko)
* Scytrin dai Kinthra (scytrin)

would like to thank:

* Adrian Madrid, for the LiteSpeed handler.
* Christoffer Sawicki, for the first Rails adapter and Rack::Deflater.
* Tim Fletcher, for the HTTP authentication code.
* Luc Heinrich for the Cookie sessions, the static file handler and bugfixes.
* Armin Ronacher, for the logo and racktools.
* Alex Beregszaszi, Alexander Kahn, Anil Wadghule, Aredridel, Ben
  Alpert, Dan Kubb, Daniel Roethlisberger, Matt Todd, Tom Robinson,
  Phil Hagelberg, S. Brent Faulkner, Bosko Milekic, Daniel Rodríguez
  Troitiño, Genki Takiuchi, Geoffrey Grosenbach, Julien Sanchez, Kamal
  Fariz Mahyuddin, Masayoshi Takahashi, Patrick Aljordm, Mig, Kazuhiro
  Nishiyama, Jon Bardin, Konstantin Haase, Larry Siden, Matias
  Korhonen, Sam Ruby, Simon Chiang, Tim Connor, Timur Batyrshin, and
  Zach Brock for bug fixing and other improvements.
* Eric Wong, Hongli Lai, Jeremy Kemper for their continuous support
  and API improvements.
* Yehuda Katz and Carl Lerche for refactoring rackup.
* Brian Candler, for Rack::ContentType.
* Graham Batty, for improved handler loading.
* Stephen Bannasch, for bug reports and documentation.
* Gary Wright, for proposing a better Rack::Response interface.
* Jonathan Buch, for improvements regarding Rack::Response.
* Armin Röhrl, for tracking down bugs in the Cookie generator.
* Alexander Kellett for testing the Gem and reviewing the announcement.
* Marcus Rückert, for help with configuring and debugging lighttpd.
* The WSGI team for the well-done and documented work they've done and
  Rack builds up on.
* All bug reporters and patch contributors not mentioned above.

== Copyright

Copyright (C) 2007, 2008, 2009, 2010 Christian Neukirchen <http://purl.org/net/chneukirchen>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

== Links

Rack:: <http://rack.github.io/>
Official Rack repositories:: <http://github.com/rack>
Rack Bug Tracking:: <http://github.com/rack/rack/issues>
rack-devel mailing list:: <http://groups.google.com/group/rack-devel>
Rack's Rubyforge project:: <http://rubyforge.org/projects/rack>

Christian Neukirchen:: <http://chneukirchen.org/>

# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Coercible

[![Build Status](https://travis-ci.org/solnic/coercible.png?branch=master)](https://travis-ci.org/solnic/coercible)
[![Code Climate](https://codeclimate.com/github/solnic/coercible.png)](https://codeclimate.com/github/solnic/coercible)
[![Dependency Status](https://gemnasium.com/solnic/coercible.png)](https://gemnasium.com/solnic/coercible)

## Installation

Add this line to your application's Gemfile:

    gem 'coercible'

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install coercible

## Usage

Coercible gives you access to coercer objects where each object is responsible
for coercing only one type into other types. For example a string coercer knows
only how to coerce string objects, integer coercer knows only how to coerce integers
etc.

Here's the most basic example:

```ruby
coercer = Coercible::Coercer.new

# coerce a string to a date
coercer[String].to_date('2012/12/25') # => #<Date: 4912573/2,0,2299161>

# coerce a string to a boolean value
coercer[String].to_boolean('yes') # => true

# you got the idea :)
```

For more control you can configure your coercer like that:

``` ruby
# build coercer instance
coercer = Coercible::Coercer.new do |config|
  config.string.boolean_map = { 'yup' => true, 'nope' => false }
end

# coerce a string to boolean
coercer[String].to_boolean('yup') # => true
coercer[String].to_boolean('nope') # => false
```

Note that at the moment only Integer and String are configurable. More configurable
coercers will be added later whenever we find good usecases.

## Contributing

1. Fork it
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Add some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create new Pull Request
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Ruby Atomic

[![Gem Version](https://badge.fury.io/rb/atomic.svg)](http://badge.fury.io/rb/atomic) [![Build Status](https://travis-ci.org/ruby-concurrency/atomic.svg?branch=master)](https://travis-ci.org/ruby-concurrency/atomic) [![Code Climate](https://codeclimate.com/github/ruby-concurrency/atomic.svg)](https://codeclimate.com/github/ruby-concurrency/atomic) [![Dependency Status](https://gemnasium.com/ruby-concurrency/atomic.svg)](https://gemnasium.com/ruby-concurrency/atomic) [![License](https://img.shields.io/badge/license-Apache-green.svg)](http://opensource.org/licenses/Apache-2.0) [![Gitter chat](http://img.shields.io/badge/gitter-join%20chat%20%E2%86%92-brightgreen.svg)](https://gitter.im/ruby-concurrency/concurrent-ruby)

An atomic reference implementation for JRuby, Rubinius, and MRI.

# Deprecated!

*This gem has been deprecated in lieu of [Concurrent Ruby](http://www.concurrent-ruby.com).
This gem will be retained in GitHUb and Rubygems.org indefinitely but no new development
will occur, including updates to support new versions of Ruby, JRuby, and Java. All users
of this gem are encouraged to update their projects to use `concurrent-ruby` instead.*

All code from this gem has been merged into `concurrent-ruby` and its companion gems.
All abstrations in this library are available in `concurrent-ruby` but have been moved
under the `Concurrent` module to avoid namespace collisions.

```ruby
# old way
require 'atomic'
my_atomic = Atomic.new(0)

# new way
require 'concurrent'
my_atomic = Concurrent::Atomic.new(0)
```

# Old Documentation

*For historic purposes only...*

## Summary

This library provides:

* an Atomic class that guarantees atomic updates to its contained value

The Atomic class provides accessors for the contained "value" plus two update methods:

* update will run the provided block, passing the current value and replacing it with the block result if the value has not been changed in the meantime. It may run the block repeatedly if there are other concurrent updates in progress.
* try_update will run the provided block, passing the current value and replacing it with the block result. If the value changes before the update can happen, it will throw an Atomic::ConcurrentUpdateError.

The atomic repository is at http://github.com/ruby-concurrency/ruby-atomic.

## Usage

The simplest way to use "atomic" is to call the "update" or "try_update" methods.

"try_update" and "update" both call the given block, passing the current value and using the block's result as the new value. If the value is updated by another thread before the block completes, "try update" raises a ConcurrentUpdateError and "update" retries the block. Because "update" may call the block several times when multiple threads are all updating the same value, the block's logic should be kept as simple as possible.

```ruby
require 'atomic'

my_atomic = Atomic.new(0)
my_atomic.update {|v| v + 1}
begin
  my_atomic.try_update {|v| v + 1}
rescue Atomic::ConcurrentUpdateError => cue
  # deal with it (retry, propagate, etc)
end
```

It's also possible to use the regular get/set operations on the Atomic, if you want to avoid the exception and respond to contended changes in some other way.

```ruby
my_atomic = Atomic.new(0)
my_atomic.value # => 0
my_atomic.value = 1
my_atomic.swap(2) # => 1
my_atomic.compare_and_swap(2, 3) # => true, updated to 3
my_atomic.compare_and_swap(2, 3) # => false, current is not 2
```

## Building

As of 1.1.0, JDK8 is required to build the atomic gem, since it attempts to use the new atomic Unsafe.getAndSetObject method only in JDK8. The resulting code should still work fine as far back as Java 5.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.[![Build Status](https://img.shields.io/travis/pry/pry.svg)](https://travis-ci.org/pry/pry)
[![Code Climate](https://img.shields.io/codeclimate/github/pry/pry.svg)](https://codeclimate.com/github/pry/pry)
[![Inline docs](http://inch-ci.org/github/pry/pry.svg)](http://inch-ci.org/github/pry/pry)

<center>
![The Pry Logo](https://dl.dropbox.com/u/26521875/pry%20stuff/logo/pry_logo_350.png)

© John Mair ([banisterfiend](https://twitter.com/banisterfiend)) 2013<br>

**Please** [DONATE](http://www.pledgie.com/campaigns/15899) to the Pry project - Pry was a **huge** amount of work and every donation received is encouraging and supports Pry's continued development!

**Sponsors**

[Tealeaf Academy](http://www.gotealeaf.com)<br/>
[Atomic Object](http://www.atomicobject.com/)<br/>
[Hashrocket](http://hashrocket.com/)<br/>
[Intridea](http://intridea.com/)<br/>
[Gaslight](http://gaslight.co/home)<br/>

**Other Resources**

[Skip to the website (recommended)](http://pry.github.com) <br />
[Skip to the wiki](https://github.com/pry/pry/wiki)
</center>

Pry is a powerful alternative to the standard IRB shell for Ruby. It is
written from scratch to provide a number of advanced features,
including:

* Source code browsing (including core C source with the pry-doc gem)
* Documentation browsing
* Live help system
* Open methods in editors (`edit Class#method`)
* Syntax highlighting
* Command shell integration (start editors, run git, and rake from within Pry)
* Gist integration
* Navigation around state (`cd`, `ls` and friends)
* Runtime invocation (use Pry as a developer console or debugger)
* Exotic object support (BasicObject instances, IClasses, ...)
* A Powerful and flexible command system
* Ability to view and replay history
* Many convenience commands inspired by IPython, Smalltalk and other advanced REPLs
* A wide-range number of [plugins](https://github.com/pry/pry/wiki/Available-plugins) that provide remote sessions, full debugging functionality, and more.

Pry also aims to be more than an IRB replacement; it is an
attempt to bring REPL driven programming to the Ruby language. It is
currently not as powerful as tools like [SLIME](http://en.wikipedia.org/wiki/SLIME) for lisp, but that is the
general direction Pry is heading.

Pry is also fairly flexible and allows significant user
[customization](https://github.com/pry/pry/wiki/Customization-and-configuration)
is trivial to set it to read from any object that has a `readline` method and write to any object that has a
`puts` method - many other aspects of Pry are also configurable making
it a good choice for implementing custom shells.

Pry comes with an executable so it can be invoked at the command line.
Just enter `pry` to start. A `.pryrc` file in the user's home directory will
be loaded if it exists. Type `pry --help` at the command line for more
information.

Try `gem install pry-doc` for additional documentation on Ruby Core
methods. The additional docs are accessed through the `show-doc` and
`show-method` commands.

* Install the [gem](https://rubygems.org/gems/pry): `gem install pry`
* Browse the comprehensive [documentation at the official Pry wiki](https://github.com/pry/pry/wiki)
* Read the [YARD API documentation](http://rdoc.info/github/pry/pry/master/file/README.markdown)
* See the [source code](http://github.com/pry/pry)

### Commands

Nearly every piece of functionality in a Pry session is implemented as
a command. Commands are not methods and must start at the beginning of a line, with no
whitespace in between. Commands support a flexible syntax and allow
'options' in the same way as shell commands, for example the following
Pry command will show a list of all private instance methods (in
scope) that begin with 'pa'

    pry(YARD::Parser::SourceParser):5> ls -Mp --grep ^pa
    YARD::Parser::SourceParser#methods: parse  parser_class  parser_type  parser_type=  parser_type_for_filename

### Navigating around state

Pry allows us to pop in and out of different scopes (objects) using
the `cd` command. This enables us to explore the run-time view of a
program or library. To view which variables and methods are available
within a particular scope we use the versatile [ls command.](https://gist.github.com/c0fc686ef923c8b87715)

Here we will begin Pry at top-level, then Pry on a class and then on
an instance variable inside that class:

    pry(main)> class Hello
    pry(main)*   @x = 20
    pry(main)* end
    => 20
    pry(main)> cd Hello
    pry(Hello):1> ls -i
    instance variables: @x
    pry(Hello):1> cd @x
    pry(20):2> self + 10
    => 30
    pry(20):2> cd ..
    pry(Hello):1> cd ..
    pry(main)> cd ..

The number after the `:` in the pry prompt indicates the nesting
level. To display more information about nesting, use the `nesting`
command. E.g

    pry("friend"):3> nesting
    Nesting status:
    0. main (Pry top level)
    1. Hello
    2. 100
    3. "friend"
    => nil

We can then jump back to any of the previous nesting levels by using
the `jump-to` command:

    pry("friend"):3> jump-to 1
    => 100
    pry(Hello):1>

### Runtime invocation

Pry can be invoked in the middle of a running program. It opens a Pry
session at the point it's called and makes all program state at that
point available. It can be invoked on any object using the
`my_object.pry` syntax or on the current binding (or any binding)
using `binding.pry`. The Pry session will then begin within the scope
of the object (or binding). When the session ends the program continues with any
modifications you made to it.

This functionality can be used for such things as: debugging,
implementing developer consoles and applying hot patches.

code:

    # test.rb
    require 'pry'

    class A
      def hello() puts "hello world!" end
    end

    a = A.new

    # start a REPL session
    binding.pry

    # program resumes here (after pry session)
    puts "program resumes here."

Pry session:

    pry(main)> a.hello
    hello world!
    => nil
    pry(main)> def a.goodbye
    pry(main)*   puts "goodbye cruel world!"
    pry(main)* end
    => nil
    pry(main)> a.goodbye
    goodbye cruel world!
    => nil
    pry(main)> exit

    program resumes here.

### Command Shell Integration

A line of input that begins with a '.' will be forwarded to the
command shell. This enables us to navigate the file system, spawn
editors, and run git and rake directly from within Pry.

Further, we can use the `shell-mode` command to incorporate the
present working directory into the Pry prompt and bring in (limited at this stage, sorry) file name completion.
We can also interpolate Ruby code directly into the shell by
using the normal `#{}` string interpolation syntax.

In the code below we're going to switch to `shell-mode` and edit the
`.pryrc` file in the home directory. We'll then cat its contents and
reload the file.

    pry(main)> shell-mode
    pry main:/home/john/ruby/projects/pry $ .cd ~
    pry main:/home/john $ .emacsclient .pryrc
    pry main:/home/john $ .cat .pryrc
    def hello_world
      puts "hello world!"
    end
    pry main:/home/john $ load ".pryrc"
    => true
    pry main:/home/john $ hello_world
    hello world!

We can also interpolate Ruby code into the shell. In the
example below we use the shell command `cat` on a random file from the
current directory and count the number of lines in that file with
`wc`:

    pry main:/home/john $ .cat #{Dir['*.*'].sample} | wc -l
    44

### Code Browsing

You can browse method source code with the `show-method` command. Nearly all Ruby methods (and some C methods, with the pry-doc
gem) can have their source viewed. Code that is longer than a page is
sent through a pager (such as less), and all code is properly syntax
highlighted (even C code).

The `show-method` command accepts two syntaxes, the typical ri
`Class#method` syntax and also simply the name of a method that's in
scope. You can optionally pass the `-l` option to show-method to
include line numbers in the output.

In the following example we will enter the `Pry` class, list the
instance methods beginning with 're' and display the source code for the `rep` method:

    pry(main)> cd Pry
    pry(Pry):1> ls -M --grep re
    Pry#methods: re  readline  refresh  rep  repl  repl_epilogue  repl_prologue  retrieve_line
    pry(Pry):1> show-method rep -l

    From: /home/john/ruby/projects/pry/lib/pry/pry_instance.rb @ line 143:
    Number of lines: 6

    143: def rep(target=TOPLEVEL_BINDING)
    144:   target = Pry.binding_for(target)
    145:   result = re(target)
    146:
    147:   show_result(result) if should_print?
    148: end

Note that we can also view C methods (from Ruby Core) using the
`pry-doc` plugin; we also show off the alternate syntax for
`show-method`:

    pry(main)> show-method Array#select

    From: array.c in Ruby Core (C Method):
    Number of lines: 15

    static VALUE
    rb_ary_select(VALUE ary)
    {
        VALUE result;
        long i;

        RETURN_ENUMERATOR(ary, 0, 0);
        result = rb_ary_new2(RARRAY_LEN(ary));
        for (i = 0; i < RARRAY_LEN(ary); i++) {
            if (RTEST(rb_yield(RARRAY_PTR(ary)[i]))) {
                rb_ary_push(result, rb_ary_elt(ary, i));
            }
        }
        return result;
    }

### Documentation Browsing

One use-case for Pry is to explore a program at run-time by `cd`-ing
in and out of objects and viewing and invoking methods. In the course
of exploring it may be useful to read the documentation for a
specific method that you come across. Like `show-method` the `show-doc` command supports
two syntaxes - the normal `ri` syntax as well as accepting the name of
any method that is currently in scope.

The Pry documentation system does not rely on pre-generated `rdoc` or
`ri`, instead it grabs the comments directly above the method on
demand. This results in speedier documentation retrieval and allows
the Pry system to retrieve documentation for methods that would not be
picked up by `rdoc`. Pry also has a basic understanding of both the
rdoc and yard formats and will attempt to syntax highlight the
documentation appropriately.

Nonetheless, the `ri` functionality is very good and
has an advantage over Pry's system in that it allows documentation
lookup for classes as well as methods. Pry therefore has good
integration with  `ri` through the `ri` command. The syntax
for the command is exactly as it would be in command-line -
so it is not necessary to quote strings.

In our example we will enter the `Gem` class and view the
documentation for the `try_activate` method:

    pry(main)> cd Gem
    pry(Gem):1> show-doc try_activate

    From: /Users/john/.rvm/rubies/ruby-1.9.2-p180/lib/ruby/site_ruby/1.9.1/rubygems.rb @ line 201:
    Number of lines: 3

    Try to activate a gem containing path. Returns true if
    activation succeeded or wasn't needed because it was already
    activated. Returns false if it can't find the path in a gem.
    pry(Gem):1>

We can also use `ri` in the normal way:

    pry(main) ri Array#each
    ----------------------------------------------------------- Array#each
         array.each {|item| block }   ->   array
    ------------------------------------------------------------------------
         Calls _block_ once for each element in _self_, passing that element
         as a parameter.

            a = [ "a", "b", "c" ]
            a.each {|x| print x, " -- " }

         produces:

            a -- b -- c --

### Gist integration

If the `gist` gem is installed then method source or documentation can be gisted to github with the
`gist` command.  The `gist` command is capable of gisting [almost any REPL content](https://gist.github.com/cae143e4533416529726), including methods, documentation,
input expressions, command source, and so on. In the example below we will gist the C source
code for the `Symbol#to_proc` method to github:

    pry(main)> gist -m Symbol#to_proc
    Gist created at https://gist.github.com/5332c38afc46d902ce46 and added to clipboard.
    pry(main)>

You can see the actual gist generated here: [https://gist.github.com/5332c38afc46d902ce46](https://gist.github.com/5332c38afc46d902ce46)

### Edit methods

You can use `edit Class#method` or `edit my_method`
(if the method is in scope) to open a method for editing directly in
your favorite editor. Pry has knowledge of a few different editors and
will attempt to open the file at the line the method is defined.

You can set the editor to use by assigning to the `Pry.editor`
accessor. `Pry.editor` will default to `$EDITOR` or failing that will
use `nano` as the backup default. The file that is edited will be
automatically reloaded after exiting the editor - reloading can be
suppressed by passing the `--no-reload` option to `edit`

In the example below we will set our default editor to "emacsclient"
and open the `Pry#repl` method for editing:

    pry(main)> Pry.editor = "emacsclient"
    pry(main)> edit Pry#repl

### Live Help System

Many other commands are available in Pry; to see the full list type
`help` at the prompt. A short description of each command is provided
with basic instructions for use; some commands have a more extensive
help that can be accessed via typing `command_name --help`. A command
will typically say in its description if the `--help` option is
avaiable.

### Use Pry as your Rails Console

The recommended way to use Pry as your Rails console is to add
[the `pry-rails` gem](https://github.com/rweng/pry-rails) to
your Gemfile. This replaces the default console with Pry, in
addition to loading the Rails console helpers and adding some
useful Rails-specific commands.

If you don't want to change your Gemfile, you can still run a Pry
console in your app's environment using Pry's `-r` flag:

    pry -r ./config/environment

Also check out the [wiki](https://github.com/pry/pry/wiki/Setting-up-Rails-or-Heroku-to-use-Pry)
for more information about integrating Pry with Rails.

### Limitations:

* Tab completion is currently a bit broken/limited this will have a
  major overhaul in a future version.

### Syntax Highlighting

Syntax highlighting is on by default in Pry. If you want to change
the colors, check out the [pry-theme](https://github.com/kyrylo/pry-theme)
gem.

You can toggle the syntax highlighting on and off in a session by
using the `toggle-color` command. Alternatively, you can turn it off
permanently by putting the line `Pry.color = false` in your `~/.pryrc`
file.

### Future Directions

Many new features are planned such as:

* Increase modularity (rely more on plugin system)
* Much improved documentation system, better support for YARD
* Better support for code and method reloading and saving code
* Extended and more sophisticated command system, allowing piping
between commands and running commands in background

### Contact

Problems or questions? file an issue at [github](https://github.com/pry/pry/issues)

### Contributors

Pry is primarily the work of [John Mair (banisterfiend)](http://github.com/banister), for full list
of contributors see the
[CONTRIBUTORS](https://github.com/pry/pry/blob/master/CONTRIBUTORS) file.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.Support
=======

Support for Treetop is provided through the mailing list you can join or browse here:
http://groups.google.com/group/treetop-dev 

Tutorial
========
Languages can be split into two components, their *syntax* and their *semantics*. It's your understanding of English syntax that tells you the stream of words "Sleep furiously green ideas colorless" is not a valid sentence. Semantics is deeper. Even if we rearrange the above sentence to be "Colorless green ideas sleep furiously", which is syntactically correct, it remains nonsensical on a semantic level. With Treetop, you'll be dealing with languages that are much simpler than English, but these basic concepts apply. Your programs will need to address both the syntax and the semantics of the languages they interpret.

Treetop equips you with powerful tools for each of these two aspects of interpreter writing. You'll describe the syntax of your language with a *parsing expression grammar*. From this description, Treetop will generate a Ruby parser that transforms streams of characters written into your language into *abstract syntax trees* representing their structure. You'll then describe the semantics of your language in Ruby by defining methods on the syntax trees the parser generates.

Parsing Expression Grammars, The Basics
=======================================
The first step in using Treetop is defining a grammar in a file with the `.treetop` extension. Here's a grammar that's useless because it's empty:
    
    # my_grammar.treetop
    grammar MyGrammar
    end

Next, you start filling your grammar with rules. Each rule associates a name with a parsing expression, like the following:

    # my_grammar.treetop
    # You can use a .tt extension instead if you wish
    grammar MyGrammar
      rule hello
        'hello chomsky'
      end
    end

The first rule becomes the *root* of the grammar, causing its expression to be matched when a parser for the grammar is fed a string. The above grammar can now be used in a Ruby program. Notice how a string matching the first rule parses successfully, but a second nonmatching string does not.

```ruby
# use_grammar.rb
require 'rubygems'
require 'treetop'
Treetop.load 'my_grammar'
# or just:
# require 'my_grammar'                     # This works because Polyglot hooks "require" to find and load Treetop files
    
parser = MyGrammarParser.new
puts parser.parse('hello chomsky')         # => Treetop::Runtime::SyntaxNode
puts parser.parse('silly generativists!')  # => nil
```
Users of *regular expressions* will find parsing expressions familiar. They share the same basic purpose, matching strings against patterns. However, parsing expressions can recognize a broader category of languages than their less expressive brethren. Before we get into demonstrating that, lets cover some basics. At first parsing expressions won't seem much different. Trust that they are.

Terminal Symbols
----------------
The expression in the grammar above is a terminal symbol. It will only match a string that matches it exactly. There are two other kinds of terminal symbols, which we'll revisit later. Terminals are called *atomic expressions* because they aren't composed of smaller expressions.

Ordered Choices
---------------
Ordered choices are *composite expressions*, which allow for any of several subexpressions to be matched. These should be familiar from regular expressions, but in parsing expressions, they are delimited by the `/` character. Its important to note that the choices are prioritized in the order they appear. If an earlier expression is matched, no subsequent expressions are tried. Here's an example:

    # my_grammar.treetop
    grammar MyGrammar
      rule hello
        'hello chomsky' / 'hello lambek'
      end
    end

```ruby    
# fragment of use_grammar.rb
puts parser.parse('hello chomsky')         # => Treetop::Runtime::SyntaxNode
puts parser.parse('hello lambek')          # => Treetop::Runtime::SyntaxNode
puts parser.parse('silly generativists!')  # => nil
```
Note that once a choice rule has matched the text using a particular alternative at a particular location in the input and hence has succeeded, that choice will never be reconsidered, even if the chosen alternative causes another rule to fail where a later alternative wouldn't have. It's always a later alternative, since the first to succeed is final - why keep looking when you've found what you wanted? This is a feature of PEG parsers that you need to understand if you're going to succeed in using Treetop. In order to memoize success and failures, such decisions cannot be reversed. Luckily Treetop provides a variety of clever ways you can tell it to avoid making the wrong decisions. But more on that later.

Sequences
---------
Sequences are composed of other parsing expressions separated by spaces. Using sequences, we can tighten up the above grammar.

    # my_grammar.treetop
    grammar MyGrammar
      rule hello
        'hello ' ('chomsky' / 'lambek')
      end
    end

Note the use of parentheses to override the default precedence rules, which bind sequences more tightly than choices.

Once the whole sequence has been matched, the result is memoized and the details of the match will not be reconsidered for that location in the input.

Nonterminal Symbols
-------------------
Here we leave regular expressions behind. Nonterminals allow expressions to refer to other expressions by name. A trivial use of this facility would allow us to make the above grammar more readable should the list of names grow longer.

    # my_grammar.treetop
    grammar MyGrammar
      rule hello
        'hello ' linguist
      end
      
      rule linguist
        'chomsky' / 'lambek' / 'jacobsen' / 'frege'
      end
    end

The true power of this facility, however, is unleashed when writing *recursive expressions*. Here is a self-referential expression that can match any number of open parentheses followed by any number of closed parentheses. This is theoretically impossible with regular expressions due to the *pumping lemma*.

    # parentheses.treetop
    grammar Parentheses
      rule parens
        '(' parens ')' / ''
      end
    end


The `parens` expression simply states that a `parens` is a set of parentheses surrounding another `parens` expression or, if that doesn't match, the empty string. If you are uncomfortable with recursion, its time to get comfortable, because it is the basis of language. Here's a tip: Don't try and imagine the parser circling round and round through the same rule. Instead, imagine the rule is *already* defined while you are defining it. If you imagine that `parens` already matches a string of matching parentheses, then its easy to think of `parens` as an open and closing parentheses around another set of matching parentheses, which conveniently, you happen to be defining. You know that `parens` is supposed to represent a string of matched parentheses, so trust in that meaning, even if you haven't fully implemented it yet.

Repetition
----------
Any item in a rule may be followed by a '+' or a '*' character, signifying one-or-more and zero-or-more occurrences of that item. Beware though; the match is greedy, and if it matches too many items and causes subsequent items in the sequence to fail, the number matched will never be reconsidered. Here's a simple example of a rule that will never succeed:

    # toogreedy.treetop
    grammar TooGreedy
      rule a_s
      	'a'* 'a'
      end
    end

The 'a'* will always eat up any 'a's that follow, and the subsequent 'a' will find none there, so the whole rule will fail. You might need to use lookahead to avoid matching too much. Alternatively, you can use an occurrence range:

    # toogreedy.treetop
    grammar TooGreedy
      rule two_to_four_as
      	'a' 2..4
      end
    end

In an occurrence range, you may omit either the minimum count or the maximum count, so that "0.. " works like "*" and "1.. " works like '+'.

Negative Lookahead
------------------

When you need to ensure that the following item *doesn't* match in some case where it might otherwise, you can use negat!ve lookahead, which is an item preceeded by a ! - here's an example:

    # postcondition.treetop
    grammar PostCondition
      rule conditional_sentence
        ( !conditional_keyword word )+ conditional_keyword [ \t]+ word*
      end

      rule word
        ([a-zA-Z]+ [ \t]+) 
      end

      rule conditional_keyword
        'if' / 'while' / 'until'
      end
    end

Even though the rule `word` would match any of the conditional keywords, the first words of a conditional_sentence must not be conditional_keywords. The negative lookahead prevents that matching, and prevents the repetition from matching too much input. Note that the lookahead may be a grammar rule of any complexity, including one that isn't used elsewhere in your grammar.

Positive lookahead
------------------

Sometimes you want an item to match, but only if the *following* text would match some pattern. You don't want to consume that following text, but if it's not there, you want this rule to fail. You can append a positive lookahead like this to a rule by appending the lookahead rule preceeded by an & character.

Semantic predicates
-------------------

Warning: This is an advanced feature. You need to understand the way a packrat parser operates to use it correctly. The result of computing a rule containing a semantic predicate will be memoized, even if the same rule, applied later at the same location in the input, would work differently due to a semantic predicate returning a different value. If you don't understand the previous sentence yet still use this feature, you're on your own, so test carefully!

Sometimes, you need to run external Ruby code to decide whether this syntax rule should continue or should fail. You can do this using either positive or negative semantic predicates. These are Ruby code blocks (lambdas) which are called when the parser reaches that location. For this rule to succeed, the value must be true for a positive predicate (a block like &{ ... }), or false for a negative predicate (a block like !{ ... }).

The block is called with one argument, the array containing the preceding syntax nodes in the current sequence. Within the block, you cannot use node names or labels for the preceding nodes, as the node for the current rule does not yet exist. You must refer to preceding nodes using their position in the sequence.

    grammar Keywords
      rule sequence_of_reserved_and_nonreserved_words
      	( reserved / word )*
      end

      rule reserved
        word &{ |s| symbol_reserved?(s[0].text_value) }
      end

      rule word
        ([a-zA-Z]+ [ \t]+) 
      end
    end

One case where it is always safe to use a semantic predicate is to invoke the Ruby debugger, but don't forget to return true so the rule succeeds! Assuming you have required the 'ruby-debug' module somewhere, it looks like this:

      rule problems
        word &{ |s| debugger; true }
      end

When the debugger stops here, you can inspect the contents of the SyntaxNode for "word" by looking at s[0], and the stack trace will show how you got there.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# The Twitter Ruby Gem

[![Gem Version](http://img.shields.io/gem/v/twitter.svg)][gem]
[![Build Status](http://img.shields.io/travis/sferik/twitter.svg)][travis]
[![Dependency Status](http://img.shields.io/gemnasium/sferik/twitter.svg)][gemnasium]
[![Code Climate](http://img.shields.io/codeclimate/github/sferik/twitter.svg)][codeclimate]
[![Coverage Status](http://img.shields.io/coveralls/sferik/twitter.svg)][coveralls]
[![Inline docs](http://inch-ci.org/github/sferik/twitter.png)][inchpages]

[gem]: https://rubygems.org/gems/twitter
[travis]: https://travis-ci.org/sferik/twitter
[gemnasium]: https://gemnasium.com/sferik/twitter
[codeclimate]: https://codeclimate.com/github/sferik/twitter
[coveralls]: https://coveralls.io/r/sferik/twitter
[inchpages]: http://inch-ci.org/github/sferik/twitter

A Ruby interface to the Twitter API.

## Installation
    gem install twitter

## CLI

Looking for the Twitter command-line interface? It was [removed][] from this
gem in version 0.5.0 and now exists as a [separate project][t].

[removed]: https://github.com/sferik/twitter/commit/dd2445e3e2c97f38b28a3f32ea902536b3897adf
[t]: https://github.com/sferik/t

## Documentation
[http://rdoc.info/gems/twitter][documentation]

[documentation]: http://rdoc.info/gems/twitter

## Examples
[https://github.com/sferik/twitter/tree/master/examples][examples]

[examples]: https://github.com/sferik/twitter/tree/master/examples

## Announcements
You should [follow @gem][follow] on Twitter for announcements and updates about
this library.

[follow]: https://twitter.com/gem

## Mailing List
Please direct questions about this library to the [mailing list].

[mailing list]: https://groups.google.com/group/twitter-ruby-gem

## Apps Wiki
Does your project or organization use this gem? Add it to the [apps
wiki][apps]!

[apps]: https://github.com/sferik/twitter/wiki/apps

## What's New in Version 5?
### Configuration
Global configuration has been removed, as it was not threadsafe. Instead, you
can configure a `Twitter::REST::Client` by passing it a block when it's
initialized.

```ruby
client = Twitter::REST::Client.new do |config|
  config.consumer_key        = "YOUR_CONSUMER_KEY"
  config.consumer_secret     = "YOUR_CONSUMER_SECRET"
  config.access_token        = "YOUR_ACCESS_TOKEN"
  config.access_token_secret = "YOUR_ACCESS_SECRET"
end
```

Note: `oauth_token` has been renamed to `access_token` and `oauth_token_secret`
is now `access_token_secret` to conform to the terminology used in Twitter's
developer documentation.

### Streaming (Experimental)
This library now offers support for the [Twitter Streaming API][streaming].

[streaming]: https://dev.twitter.com/docs/streaming-apis
[tweetstream]: http://rubygems.org/gems/tweetstream

Site Streams are restricted to whitelisted accounts. To apply for access,
[follow the steps in the Site Streams documentation][site-streams]. [User
Streams][user-streams] do not require prior approval.

[site-streams]: https://dev.twitter.com/docs/streaming-apis/streams/site#Applying_for_access
[user-streams]: https://dev.twitter.com/docs/streaming-apis/streams/user

Unlike the rest of this library, this feature is not well tested and not
recommended for production applications. I've decided to ship it as an
experimental feature and make it more robust over time. Patches in this area are
particularly welcome.

Hopefully, by the time version 6 is released, this gem can fully replace
[TweetStream][], [em-twitter][], [twitterstream][], and [twitter-stream].
Special thanks to [Steve Agalloco][spagalloco], [Tim Carey-Smith][halorgium],
and [Tony Arcieri][tarcieri] for helping to develop this feature.

[em-twitter]: http://rubygems.org/gems/em-twitter
[twitterstream]: http://rubygems.org/gems/twitterstream
[twitter-stream]: http://rubygems.org/gems/twitter-stream
[spagalloco]: https://github.com/spagalloco
[halorgium]: https://github.com/halorgium
[tarcieri]: https://github.com/tarcieri

**Configuration works just like `Twitter::REST::Client`**

```ruby
client = Twitter::Streaming::Client.new do |config|
  config.consumer_key        = "YOUR_CONSUMER_KEY"
  config.consumer_secret     = "YOUR_CONSUMER_SECRET"
  config.access_token        = "YOUR_ACCESS_TOKEN"
  config.access_token_secret = "YOUR_ACCESS_SECRET"
end
```

**Stream mentions of coffee or tea**

```ruby
topics = ["coffee", "tea"]
client.filter(:track => topics.join(",")) do |object|
  puts object.text if object.is_a?(Twitter::Tweet)
end
```

**Stream a random sample of all tweets**

```ruby
client.sample do |object|
  puts object.text if object.is_a?(Twitter::Tweet)
end
```

**Stream tweets, events, and direct messages for the authenticated user**

```ruby
client.user do |object|
  case object
  when Twitter::Tweet
    puts "It's a tweet!"
  when Twitter::DirectMessage
    puts "It's a direct message!"
  when Twitter::Streaming::StallWarning
    warn "Falling behind!"
  end
end
```

An `object` may be one of the following:
* `Twitter::DirectMessage`
* `Twitter::Streaming::DeletedTweet`
* `Twitter::Streaming::Event`
* `Twitter::Streaming::FriendList`
* `Twitter::Streaming::StallWarning`
* `Twitter::Tweet`

### Cursors
The `Twitter::Cursor` class has been completely redesigned with a focus on
simplicity and performance.

<table>
  <thead>
    <tr>
      <th>Notes</th>
      <th colspan="2">Version 4</th>
      <th colspan="2">Version 5</th>
    </tr>
    <tr>
      <th></th>
      <th>Code</th>
      <th>HTTP GETs</th>
      <th>Code</th>
      <th>HTTP GETs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        Are you at the start of the cursor?
      </td>
      <td>
        <pre><code>client.friends.first</code></pre>
      </td>
      <td>
        <em>Θ(1)</em>
      </td>
      <td>
        <pre><code>client.friends.first?</code></pre>
      </td>
      <td>
        <em>Θ(1)</em>
      </td>
    </tr>
    <tr>
      <td>
        Return your most recent friend.
      </td>
      <td>
        <pre><code>client.friends.users.first</code></pre>
      </td>
      <td>
        <em>Θ(1)</em>
      </td>
      <td>
        <pre><code>client.friends.first</code></pre>
      </td>
      <td>
        <em>Θ(1)</em>
      </td>
    </tr>
    <tr>
      <td>
        Return an array of all your friends.
      </td>
      <td>
        <pre><code>client.friends.all</code></pre>
      </td>
      <td>
        <em>Θ(n+1)</em>
      </td>
      <td>
        <pre><code>client.friends.to_a</code></pre>
      </td>
      <td>
        <em>Θ(n)</em>
      </td>
    </tr>
    <tr>
      <td>
        Collect your 20 most recent friends.
      </td>
      <td>
        <pre><code>client.friends.take(20)</code></pre>
      </td>
      <td>
        <em>Θ(n+1)</em>
      </td>
      <td>
        <pre><code>client.friends.take(20)</code></pre>
      </td>
      <td>
        <em>Θ(1)</em>
      </td>
    </tr>
    <tr>
      <td>
        Collect your 20 most recent friends twice.
      </td>
      <td>
        <pre><code>friends = client.friends
2.times.collect do
  friends.take(20)
end</code></pre>
      </td>
      <td>
        <em>Θ(2n+2)</em>
      </td>
      <td>
        <pre><code>friends = client.friends
2.times.collect do
  friends.take(20)
end</code></pre>
      </td>
      <td>
        <em>Θ(1)</em>
      </td>
    </tr>
  </tbody>
</table>

In the examples above, *n* varies with the number of people the authenticated
user follows on Twitter. This resource returns up to 20 friends per HTTP GET,
so if the authenticated user follows 200 people, calling
`client.friends.take(20)` would make 11 HTTP requests in version 4. In version
5, it makes just 1 HTTP request. Keep in mind, eliminating a single HTTP
request to the Twitter API will reduce the latency of your application by
[about 500 ms][status].

[status]: https://dev.twitter.com/status

The last example might seem contrived ("Why would I call
`client.friends.take(20)` twice?") but it applies to any
[`Enumerable`][enumerable] method you might call on a cursor, including:
`#all?`, `#collect`, `#count`, `#each`, `#inject`, `#max`, `#min`, `#reject`,
`#reverse_each`, `#select`, `#sort`, `#sort_by`, and `#to_a`. In version 4,
each time you called one of those methods, it would perform *n+1* HTTP
requests. In version 5, it only performs those HTTP requests the first time any
one of those methods is called. Each subsequent call fetches data from a
[cache][].

[enumerable]: http://ruby-doc.org/core-2.0/Enumerable.html
[cache]: https://github.com/sferik/twitter/commit/7d8b2727af9400643ac397207185fd54e3f6387b

The performance improvements are actually even **better** than the table above
indicates. In version 5, calling `Twitter::Cursor#each` (or any
[`Enumerable`][enumerable] method) starts yielding results immediately and
continues yielding as each response comes back from the server. In version 4,
`#each` made a series of requests and waited for the last one to complete
before yielding any data.

Here is a list of the interface changes to `Twitter::Cursor`:

* `#all` has been replaced by `#to_a`.
* `#last` has been replaced by `#last?`.
* `#first` has been replaced by `#first?`.
* `#first` now returns the first element in the collection, as prescribed by `Enumerable`.
* `#collection` and its aliases have been removed.

### Search Results
The `Twitter::SearchResults` class has also been redesigned to have an
[`Enumerable`][enumerable] interface. The `#statuses` method and its aliases
(`#collection` and `#results`) have been replaced by `#to_a`. Additionally,
this class no longer inherits from `Twitter::Base`. As a result, the `#[]`
method has been removed.

### Trend Results
The `#trends` method now returns an [`Enumerable`][enumerable]
`Twitter::TrendResults` object instead of an array. This object provides
methods to determine the recency of the trend (`#as_of`), when the trend
started (`#created_at`), and the location of the trend (`#location`). This data
was previously unavailable.

### Geo Results
Similarly, the `#reverse_geocode`, `#geo_search`, and `#similar_places` methods
now return an [`Enumerable`][enumerable] `Twitter::GeoResults` object instead
of an array. This object provides access to the token to create a new place
(`#token`), which was previously unavailable.

### Tweets
The `Twitter::Tweet` object has been cleaned up. The following methods have been
removed:

* `#from_user`
* `#from_user_id`
* `#from_user_name`
* `#to_user`
* `#to_user_id`
* `#to_user_name`
* `#profile_image_url`
* `#profile_image_url_https`

These attributes can be accessed via the `Twitter::User` object, returned
through the `#user` method.

### Users
The `Twitter::User` object has also been cleaned up. The following aliases have
been removed:

* `#favorite_count` (use `#favorites_count`)
* `#favoriters_count` (use `#favorites_count`)
* `#favourite_count` (use `#favorites_count`)
* `#favouriters_count` (use `#favorites_count`)
* `#follower_count` (use `#followers_count`)
* `#friend_count` (use `#friends_count`)
* `#status_count` (use `#statuses_count`)
* `#tweet_count` (use `#tweets_count`)
* `#update_count` (use `#tweets_count`)
* `#updates_count` (use `#tweets_count`)
* `#translator` (use `#translator?`)

### Remove British English aliases
Earlier versions of this library aliased `favourites` to `favorites`. These
aliases have been removed. Ruby is implemented in American English. The
`initialize` method is spelled with a "z", not an "s", and Ruby provides no
alias. Likewise, this library does not provide aliases for Commonwealthers.
Merica. :us:

### More natural method names
All create, destroy, add, and remove methods have been renamed to put the verb
at the beginning:

* `#direct_message_create` is now `#create_direct_message`
* `#direct_message_destroy` is now `#destroy_direct_message`
* `#list_create` is now `#create_list`
* `#list_destroy` is now `#destroy_list`
* `#list_remove_member` is now `#remove_list_member`
* `#list_remove_members` is now `#remove_list_members`
* `#list_add_member` is now `#add_list_member`
* `#list_add_members` is now `#add_list_members`
* `#lists_owned` is now `#owned_lists`
* `#saved_search_create` is now `#create_saved_search`
* `#saved_search_destroy` is now `#destroy_saved_search`
* `#status_destroy` is now `#destroy_status`

### Null Objects
In version 4, methods you would expect to return a `Twitter` object would
return `nil` if that object was missing. This may have resulted in a
`NoMethodError`. To prevent such errors, you may have introduced checks for the
truthiness of the response, for example:

```ruby
status = client.status(55709764298092545)
if status.place
  # Do something with the Twitter::Place object
elsif status.geo
  # Do something with the Twitter::Geo object
end
```
In version 5, all such methods will return a `Twitter::NullObject` instead of
`nil`. This should prevent `NoMethodError` but may result in unexpected
behavior if you have truthiness checks in place, since everything is truthy in
Ruby except `false` and `nil`. For these cases, there are now predicate
methods:

```ruby
status = client.status(55709764298092545)
if status.place?
  # Do something with the Twitter::Place object
elsif status.geo?
  # Do something with the Twitter::Geo object
end
```

### URI Methods
The `Twitter::List`, `Twitter::Tweet`, and `Twitter::User` objects all have a
`#uri` method, which returns an HTTPS URI to twitter.com. This clobbers the
`Twitter::List#uri` method, which previously returned the list URI's path (not
a URI).

These methods are aliased to `#url` for users who prefer that nomenclature.
`Twitter::User` previously had a `#url` method, which returned the user's
website. This URI is now available via the `#website` method.

All `#uri` methods now return `Addressable::URI` objects instead of strings. To convert an
`Addressable::URI` object to a string, call `#to_s` on it.

## Configuration
Twitter API v1.1 requires you to authenticate via OAuth, so you'll need to
[register your application with Twitter][register]. Once you've registered an
application, make sure to set the correct access level, otherwise you may see
the error:

[register]: https://dev.twitter.com/apps

    Read-only application cannot POST

Your new application will be assigned a consumer key/secret pair and you will
be assigned an OAuth access token/secret pair for that application. You'll need
to configure these values before you make a request or else you'll get the
error:

    Bad Authentication data

You can pass configuration options as a block to `Twitter::REST::Client.new`.

```ruby
client = Twitter::REST::Client.new do |config|
  config.consumer_key        = "YOUR_CONSUMER_KEY"
  config.consumer_secret     = "YOUR_CONSUMER_SECRET"
  config.access_token        = "YOUR_ACCESS_TOKEN"
  config.access_token_secret = "YOUR_ACCESS_SECRET"
end
```

After configuration, requests can be made like so:

```ruby
client.update("I'm tweeting with @gem!")
```

**Performance/DNS settings issue**

When you are using the gem in production (running for example in a DigitalOcean VPS) be aware that DNS settings on the server can affect outbound traffic performance with `Twitter::Error::RequestTimeout` as a result. Don't use the public Google DNS services (4.4.4.4 / 8.8.8.8) they are rate-limited and have very bad response times. Use a DNS service close to your data-center.

## Usage Examples
All examples require an authenticated Twitter client. See the section on <a
href="#configuration">configuration</a>.

**Tweet (as the authenticated user)**

```ruby
client.update("I'm tweeting with @gem!")
```
**Follow a user (by screen name or user ID)**

```ruby
client.follow("gem")
client.follow(213747670)
```
**Fetch a user (by screen name or user ID)**

```ruby
client.user("gem")
client.user(213747670)
```
**Fetch a cursored list of followers with profile details (by screen name or user ID, or by implicit authenticated user)**

```ruby
client.followers("gem")
client.followers(213747670)
client.followers
```
**Fetch a cursored list of friends with profile details (by screen name or user ID, or by implicit authenticated user)**

```ruby
client.friends("gem")
client.friends(213747670)
client.friends
```

**Fetch a collection of user_ids that the currently authenticated user does not want to receive retweets from**

```ruby
client.no_retweet_ids
````

**Fetch the timeline of Tweets by a user**

```ruby
client.user_timeline("gem")
client.user_timeline(213747670)
```
**Fetch the timeline of Tweets from the authenticated user's home page**

```ruby
client.home_timeline
```
**Fetch the timeline of Tweets mentioning the authenticated user**

```ruby
client.mentions_timeline
```
**Fetch a particular Tweet by ID**

```ruby
client.status(27558893223)
```
**Collect the three most recent marriage proposals to @justinbieber**

```ruby
client.search("to:justinbieber marry me", :result_type => "recent").take(3).collect do |tweet|
  "#{tweet.user.screen_name}: #{tweet.text}"
end
```
**Find a Japanese-language Tweet tagged #ruby (excluding retweets)**

```ruby
client.search("#ruby -rt", :lang => "ja").first.text
```
For more usage examples, please see the full [documentation][].

## Object Graph

![Entity-relationship diagram][erd]

[erd]: https://github.com/sferik/twitter/raw/master/etc/erd.png "Entity-relationship diagram"

This entity-relationship diagram is generated programatically. If you add or
remove any Twitter objects, please regenerate the ERD with the following
command:

    bundle exec rake erd

## Supported Ruby Versions

This library aims to support and is [tested against][travis] the following Ruby
versions:

* Ruby 1.8.7
* Ruby 1.9.3
* Ruby 2.0.0
* Ruby 2.1
* JRuby 1.7 (Both 1.9 mode and 1.8 mode)

If something doesn't work on one of these versions, it's a bug.

This library may inadvertently work (or seem to work) on other Ruby versions,
however support will only be provided for the versions listed above.

If you would like this library to support another Ruby version or
implementation, you may volunteer to be a maintainer. Being a maintainer
entails making sure all tests run and pass on that implementation. When
something breaks on your implementation, you will be responsible for providing
patches in a timely fashion. If critical issues for a particular implementation
exist at the time of a major release, support for that Ruby version may be
dropped.

## Versioning
This library aims to adhere to [Semantic Versioning 2.0.0][semver]. Violations
of this scheme should be reported as bugs. Specifically, if a minor or patch
version is released that breaks backward compatibility, that version should be
immediately yanked and/or a new version should be immediately released that
restores compatibility. Breaking changes to the public API will only be
introduced with new major versions. As a result of this policy, you can (and
should) specify a dependency on this gem using the [Pessimistic Version
Constraint][pvc] with two digits of precision. For example:

    spec.add_dependency 'twitter', '~> 5.0'

[semver]: http://semver.org/
[pvc]: http://docs.rubygems.org/read/chapter/16#page74

## Copyright
Copyright (c) 2006-2013 Erik Michaels-Ober, John Nunemaker, Wynn Netherland, Steve Richert, Steve Agalloco.
See [LICENSE][] for details.

[license]: LICENSE.md

                          Apache Maven

  What is it?
  -----------

  Maven is a software project management and comprehension tool. Based on
  the concept of a Project Object Model (POM), Maven can manage a project's
  build, reporting and documentation from a central piece of information.

  Documentation
  -------------

  The most up-to-date documentation can be found at http://maven.apache.org/.

  Release Notes
  -------------

  The full list of changes can be found at http://maven.apache.org/release-notes.html.

  System Requirements
  -------------------

  JDK:
    1.5 or above (this is to execute Maven - it still allows you to build against 1.3
    and prior JDK's).
  Memory:
    No minimum requirement.
  Disk:
    No minimum requirement. Approximately 100MB will be used for your local repository,
    however this will vary depending on usage and can be removed and redownloaded at
    any time.
  Operating System:
    No minimum requirement. On Windows, Windows NT and above or Cygwin is required for
    the startup scripts. Tested on Windows XP, Fedora Core and Mac OS X.

  Installing Maven
  ----------------

  1) Unpack the archive where you would like to store the binaries, eg:

    Unix-based Operating Systems (Linux, Solaris and Mac OS X)
      tar zxvf apache-maven-3.x.y.tar.gz
    Windows 2000/XP
      unzip apache-maven-3.x.y.zip

  2) A directory called "apache-maven-3.x.y" will be created.

  3) Add the bin directory to your PATH, eg:

    Unix-based Operating Systems (Linux, Solaris and Mac OS X)
      export PATH=/usr/local/apache-maven-3.x.y/bin:$PATH
    Windows 2000/XP
      set PATH="c:\program files\apache-maven-3.x.y\bin";%PATH%

  4) Make sure JAVA_HOME is set to the location of your JDK

  5) Run "mvn --version" to verify that it is correctly installed.

  For complete documentation, see http://maven.apache.org/download.html#Installation

  Licensing
  ---------

  Please see the file called LICENSE.TXT

  Maven URLS
  ----------

  Home Page:          http://maven.apache.org/
  Downloads:          http://maven.apache.org/download.html
  Release Notes:      http://maven.apache.org/release-notes.html
  Mailing Lists:      http://maven.apache.org/mail-lists.html
  Source Code:        https://git-wip-us.apache.org/repos/asf/maven.git/apache-maven
  Issue Tracking:     http://jira.codehaus.org/browse/MNG
  Wiki:               https://cwiki.apache.org/confluence/display/MAVEN/
  Available Plugins:  http://maven.apache.org/plugins/index.html
Use this directory to contribute 3rd-party extensions to the Maven core. These extensions can either extend or override
Maven's default implementation.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.Archive::Tar::Minitar README
============================
Archive::Tar::Minitar is a pure-Ruby library and command-line utility that
provides the ability to deal with POSIX tar(1) archive files. The
implementation is based heavily on Mauricio Ferna'ndez's implementation in
rpa-base, but has been reorganised to promote reuse in other projects.
Antoine Toulme forked the original project on rubyforge to place it on github, under
http://www.github.com/atoulme/minitar

This release is version 0.5.2, offering a Ruby 1.9 compatibility bugfix over
version 0.5.1. The library can only handle files and directories at this
point. A future version will be expanded to handle symbolic links and hard
links in a portable manner. The command line utility, minitar, can only create
archives, extract from archives, and list archive contents.

Using this library is easy. The simplest case is:

  require 'zlib'
  require 'archive/tar/minitar'
  include Archive::Tar

    # Packs everything that matches Find.find('tests')
  File.open('test.tar', 'wb') { |tar| Minitar.pack('tests', tar) }
    # Unpacks 'test.tar' to 'x', creating 'x' if necessary.
  Minitar.unpack('test.tar', 'x')

A gzipped tar can be written with:

    tgz = Zlib::GzipWriter.new(File.open('test.tgz', 'wb'))
      # Warning: tgz will be closed!
    Minitar.pack('tests', tgz)

    tgz = Zlib::GzipReader.new(File.open('test.tgz', 'rb'))
      # Warning: tgz will be closed!
    Minitar.unpack(tgz, 'x')

As the case above shows, one need not write to a file. However, it will
sometimes require that one dive a little deeper into the API, as in the case
of StringIO objects. Note that I'm not providing a block with Minitar::Output,
as Minitar::Output#close automatically closes both the Output object and the
wrapped data stream object.

  begin
    sgz = Zlib::GzipWriter.new(StringIO.new(""))
    tar = Output.new(sgz)
    Find.find('tests') do |entry|
      Minitar.pack_file(entry, tar)
    end
  ensure
      # Closes both tar and sgz.
    tar.close
  end

Copyright
=========
# Copyright 2004 Mauricio Julio Ferna'ndez Pradier and Austin Ziegler
#
# This program is based on and incorporates parts of RPA::Package from
# rpa-base (lib/rpa/package.rb and lib/rpa/util.rb) by Mauricio and has been
# adapted to be more generic by Austin.
#
# 'minitar' contains an adaptation of Ruby/ProgressBar by Satoru
# Takabayashi <satoru@namazu.org>, copyright 2001 - 2004.
#
# This program is free software. It may be redistributed and/or modified
# under the terms of the GPL version 2 (or later) or Ruby's licence.
# 
# $Id$
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.= mime-types

home :: https://github.com/mime-types/ruby-mime-types/
code :: https://github.com/mime-types/ruby-mime-types/
bugs :: https://github.com/mime-types/ruby-mime-types/issues
rdoc :: http://rdoc.info/gems/mime-types/
continuous integration :: {<img src="https://travis-ci.org/mime-types/ruby-mime-types.png" />}[https://travis-ci.org/mime-types/ruby-mime-types]
test coverage :: {<img src="https://coveralls.io/repos/mime-types/ruby-mime-types/badge.png" alt="Coverage Status" />}[https://coveralls.io/r/mime-types/ruby-mime-types]

== Description

The mime-types library provides a library and registry for information about
MIME content type definitions. It can be used to determine defined filename
extensions for MIME types, or to use filename extensions to look up the likely
MIME type definitions.

MIME content types are used in MIME-compliant communications, as in e-mail or
HTTP traffic, to indicate the type of content which is transmitted. The
mime-types library provides the ability for detailed information about MIME
entities (provided as an enumerable collection of MIME::Type objects) to be
determined and used programmatically. There are many types defined by RFCs and
vendors, so the list is long but by definition incomplete; don't hesitate to
add additional type definitions (see Contributing.rdoc). The primary sources
for MIME type definitions found in mime-types is the
{IANA Media Types registry}[https://www.iana.org/assignments/media-types/media-types.xhtml],
RFCs, and W3C recommendations. It conforms to RFCs 2045 and 2231.

This is release 2.5 with a couple of bug fixes, updating to the latest IANA
type registry, and adding a user-contributed type. mime-types 2.x supports Ruby
1.9.2 or later.

=== mime-types 1.x End of Life

mime-types 2.0 was released in late 2013, and as of early 2015 there have been
no reported security issues for mime-types 1.x. With the release of mime-types
2.5, I setting the formal End of Life for mime-types 1.x for 2015-10-27 (the
second anniversary of the release of mime-types 2.0). After this date,
absolutely no pull requests for mime-types 1.x will be accepted.

=== mime-types Future

Even though there are a number of issues open, it is clear to me that there are
some fundamental changes that need to happen to both the data representation
and the API provided by mime-types. This cannot happen under the current
release, so all new development is focussing on an upcoming 3.0 release. The
target for the release is on or before the beginning of RubyConf 2015
(2015-11-15).

When 3.0 is released, mime-types 2.x will receive regular updates of the IANA
registry for two years following the release. It will also receive security
updates, if needed, for the same period. There will be no further feature
development on mime-types 2.x following the 3.0 release.

Coincident with the 3.0 release, I will release mime-types 2.99.0 that no
longer imports the data to fields that have been deprecated. If they work
because they derive data from that which is imported, they will continue to
work. The quarterly updates will be against 2.99.x.

== Synopsis

MIME types are used in MIME entities, as in email or HTTP traffic. It is useful
at times to have information available about MIME types (or, inversely, about
files). A MIME::Type stores the known information about one MIME type.

    require 'mime/types'

    plaintext = MIME::Types['text/plain'] # => [ text/plain ]
    text = plaintext.first
    puts text.media_type            # => 'text'
    puts text.sub_type              # => 'plain'

    puts text.extensions.join(" ")  # => 'txt asc c cc h hh cpp hpp dat hlp'
    puts text.preferred_extension   # => 'txt'
    puts text.friendly              # => 'Text Document'
    puts text.i18n_key              # => 'text.plain'

    puts text.encoding              # => quoted-printable
    puts text.binary?               # => false
    puts text.ascii?                # => true
    puts text.obsolete?             # => false
    puts text.registered?           # => true
    puts text == 'text/plain'       # => true
    puts 'text/plain' == text       # => true
    puts MIME::Type.simplified('x-appl/x-zip')
                                    # => 'appl/zip'

    puts MIME::Types.any? { |type|
      type.content_type == 'text/plain'
    }                               # => true
    puts MIME::Types.all?(&:registered?)
                                    # => false

    # Various string representations of MIME types

    qcelp = MIME::Types['audio/QCELP'].first # => audio/QCELP
    puts qcelp.content_type         # => 'audio/QCELP'
    puts qcelp.simplified           # => 'audio/qcelp'

    xwingz = MIME::Types['application/x-Wingz'].first # => application/x-Wingz
    puts xwingz.content_type        # => 'application/x-Wingz'
    puts xwingz.simplified          # => 'application/wingz'


== mime-types Modified Semantic Versioning

The mime-types library has one version number, but this single version number
tracks both API changes and registry data changes; this is not wholly
compatible with all aspects of {Semantic Versioning}[http://semver.org/];
removing a MIME type from the registry *could* be considered a breaking change
under some interpretations of semantic versioning (as lookups for that
particular type would no longer work by default).

mime-types uses a modified semantic versioning scheme. Given the version
MAJOR.MINOR:

1. If an incompatible API (code) change is made, the MAJOR version will be
   incremented, MINOR will be set to zero, and PATCH will be reset to the
   implied zero.

2. If an API (code) feature is added that does not break compatibilty OR if
   there are MIME types added, removed, or changed in the registry, the MINOR
   version will be incremented and PATCH will be reset to the implied zero.

3. If there is a bugfix to a feature added in the most recent MAJOR.MINOR
   release, OR if purely typographical errors are fixed in MIME types, the
   implied PATCH value will be incremented resulting in MAJOR.MINOR.PATCH.

In practical terms, there should be a MINOR release roughly monthly to track
updated or changed MIME types from the official IANA registry. This does not
indicate when new API features have been added, but all minor versions of
mime-types 2.x will be backwards compatible; the interfaces marked deprecated
will not be removed until at least mime-types 3.x or possibly later.

:include: Contributing.rdoc

:include: Licence.rdoc
ffi-rzmq
    by Chuck Remes
    http://www.zeromq.org/bindings:ruby-ffi

== FUTURE SUPPORT

Most people writing Zeromq applications in Ruby should be using the rbczmq
project. It wraps the CZMQ binding which is a much higher-level library
for writing Zeromq code. Find the Ruby gem here:

    http://github.com/methodmissing/rbczmq
    
Few projects need to write the low-level zeromq code that this gem allows.
With the release of ffi-rzmq 2.0.3, this library is going into permanent 
maintenance mode. As new versions of libzmq are released, interested parties
should send pull requests to this project or its related project
ffi-rzmq-core to support new features.

The original README text follows...

== DESCRIPTION:

This gem wraps the ZeroMQ networking library using the ruby FFI (foreign
function interface). It's a pure ruby wrapper so this gem can be loaded
and run by any ruby runtime that supports FFI. That's all of them:
MRI 1.9.x, Rubinius and JRuby.

The Ruby API provided by this gem is *NOT* very Ruby-like. It very closely
tracks the libzmq C API. However, the contributors to this project have
done all of the hard work to wrap up all of libzmq and make it accessible
from Ruby. If you want it to be more Ruby-like (e.g. raise Exceptions instead
of returning integer codes) then *wrap this library* with your own and release
it as a gem. We will all be grateful!

This single gem supports 0mq 3.2.x and 4.x APIs. The 0mq project started
making backward-incompatible changes to the API with the 3.1.x release.
The gem auto-configures itself to expose the API conforming to the loaded
C library. 0mq 2.x is no longer supported. 0mq API 3.0 is *not* supported; 
the 0mq community voted to abandon it.

The impetus behind this library was to provide support for ZeroMQ in
JRuby which has native threads. Unlike MRI, which has a GIL, JRuby and
Rubinius allow for threaded access to Ruby code from outside extensions.
ZeroMQ is heavily threaded, so until the MRI runtime removes its GIL,
JRuby and Rubinius will likely be the best environments to run this library.

Please read the History.txt file for a description of all changes, including
API changes, since the last release!

== PERFORMANCE:

Check out the latest performance results:

  http://www.zeromq.org/bindings:ruby-ffi

The short version is that the FFI bindings are a few microseconds slower
than using a C extension.

== FEATURES/PROBLEMS:

This gem needs more tests. This gem has been battle tested by myself
and others for years, so I am fairly confident that it is solid.
However, it is inevitable that there will be bugs, so please open
issues for them here or fork this project, fix them, and send me a pull
request.

The 'ffi' gem has dropped support for MRI 1.8.x. Since this project relies
on that gem to load and run this code, then this project also no longer
supports MRI 1.8.x. I recommend JRuby for the best performance and
stability.

All features are implemented.

== BUILD STATUS:

{<img src="https://secure.travis-ci.org/chuckremes/ffi-rzmq.png?branch=master" alt="Build Status" />}[http://travis-ci.org/chuckremes/ffi-rzmq]

{<img src="https://codeclimate.com/badge.png" />}[https://codeclimate.com/github/chuckremes/ffi-rzmq]

== SYNOPSIS:

0mq API v3.2-4 client code:

  require 'rubygems'
  require 'ffi-rzmq'

  if ARGV.length < 3
    puts "usage: ruby local_lat.rb <connect-to> <message-size> <roundtrip-count>"
    exit
  end
  
  bind_to = ARGV[0]
  message_size = ARGV[1].to_i
  roundtrip_count = ARGV[2].to_i

  ctx = ZMQ::Context.new
  s   = ctx.socket ZMQ::REP
  rc  = s.setsockopt(ZMQ::SNDHWM, 100)
  rc  = s.setsockopt(ZMQ::RCVHWM, 100)
  rc  = s.bind(bind_to)

  roundtrip_count.times do
    msg = ""
    rc  = s.recv_string msg
    raise "Message size doesn't match, expected [#{message_size}] but received [#{msg.size}]" if message_size != msg.size
    rc  = s.send_string msg, 0
  end

0mq API v3.2-4 server code:

  require 'rubygems'
  require 'ffi-rzmq'

  if ARGV.length < 3
    puts "usage: ruby remote_lat.rb <connect-to> <message-size> <roundtrip-count>"
    exit
  end
  
  def assert(rc)
    raise "Last API call failed at #{caller(1)}" unless rc >= 0
  end
  
  connect_to = ARGV[0]
  message_size = ARGV[1].to_i
  roundtrip_count = ARGV[2].to_i

  ctx = ZMQ::Context.new
  s   = ctx.socket ZMQ::REQ
  rc  = s.connect(connect_to)

  msg = "#{ '3' * message_size }"

  time_start = Time.now

  roundtrip_count.times do
    assert(s.send_string(msg, 0))
  
    msg = ''
    assert(s.recv_string(msg, 0))
  
    raise "Message size doesn't match, expected [#{message_size}] but received [#{msg.size}]" if message_size != msg.size
  end

  time_end = Time.now
  puts "Time #{( time_end - time_start )}"

== Better Examples

I highly recommend visiting the Learn Ruby 0mq project for a bunch of good code examples.

  http://github.com/andrewvc/learn-ruby-zeromq



== REQUIREMENTS:

  * 0mq 3.2.x, 4.x or later; 2.x, 3.0.x and 3.1.x are no longer supported

The ZeroMQ library must be installed on your system in a well-known location
like /usr/local/lib. This is the default for new ZeroMQ installs.

If you have installed ZeroMQ using brew, you need to `brew link zeromq` before installing this gem.

  * ffi (>= 1.0.0)
	* ffi-rzmq-core

This is a requirement for MRI and Rubinius. JRuby has FFI support built
in as a standard component. Do *not* run this gem under MRI with an old 'ffi' gem.
It will crash randomly and you will be sad.


== INSTALL:

Make sure the ZeroMQ library is already installed on your system. We recommend 'brew' or 'macports' to get it.

 % gem install ffi-rzmq # should grab the latest release


To build from git master:

 % git clone git://github.com/chuckremes/ffi-rzmq
 % cd ffi-rzmq
 % gem build ffi-rzmq.gemspec
 % gem install ffi-rzmq-*.gem


NOTE for Windows users!
In order for this gem to find the libzmq.dll, it *must* be on the Windows PATH. Google
for "modify windows path" for instructions on how to do that if you are unfamiliar with
that activity. That DLL also requires that you copy libstdc++-6.dll and libgcc_s_sjlj-1.dll from DevKit MinGW into the same folder that you copied libzmq.dll.

== LICENSE:

(The MIT License)

Copyright (c) 2013 Chuck Remes

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
= Examples

== Requirements

1. lib dir

All of the examples assume the lib directory containing the gem sources is one directory up from the location of the example.

2. Installed libzmq library

The ZeroMQ C libraries need to be downloaded, compiled and installed separately from the gem. Please see http://www.zeromq.org/area:download for links to the downloadable files along with some simple installation instructions. Also, be sure to check the FAQ if you run into problems with compiling.

It is possible to install the libzmq* files directly into the gem in the ext/ directory. This directory is checked for loadable libraries first before it falls back to checking the system paths.

3. One terminal window

ZeroMQ is used to build network applications. At minimum, there is a "client" application and a "server" application that talk to each other over the network, IPC or an internal thread queue. Several of the examples start the client and server components within separate threads or use the polling mechanism to interleave I/O operations amongst several sockets. A few examples need two terminal windows because the client and server code is in separate files (local_lat.rb/remote_lat.rb, local_throughput.rb/remote_throughput.rb).

== Latency Test

The examples include a latency performance test. The example sets up a pair of REQ/REP sockets and send a message back and forth as fast as possible. There is only a single message in flight at any given moment. The time required to send the message the requested number of times determines overall single-message latency for this type of socket.

==== Files

* latency_measurement.rb

==== Arguments

The remote_lat.rb program takes 3 arguments:

  [link_address]  Requires a transport string of the format "transport"://"endpoint"<:><port>. For example, tcp://127.0.0.1:5555
  
  [message size] Size of each message measured in bytes. Allowable range is 1 to 2^(64-1).
  
  [message count] The number of round-trips used for the latency measurements. Allowable range is 1 to 2^(64-1).

  
==== Execution

In an open terminal window, execute the latency_measurement.rb file.

  % ruby latency_measurement.rb tcp://127.0.0.1:5555 1024 100_000

On a relatively new system, it can run 100k messages in under 30 seconds. When complete, the program prints out a few statistics and exits.

Running with a larger "message count" will yield a more accurate latency measurement since nearly all Ruby runtimes require a little warm up time to hit their stride. I recommend 100k as a minimum while 10 million is better for determining a true measure.

On a desktop computer purchased in 2007, all of the Ruby runtimes report a latency of approximately 110 microseconds per message. For comparison, the pure C latency test reports approximately 88 microseconds of latency.



== Throughput Test

The examples include a throughput performance test. The example sets up a pair of PUB/SUB sockets and publish messages as fast as possible to a subscriber listening for every message. The publisher can send much faster than the subscriber can retrieve messages. 

Since the publisher completes first, the program waits for all subscribers to exit before closing the PUB socket. This is necessary because all enqueued messages are discarded when the socket is closed.

The subscriber prints some statistics when it exits.

==== Files

* throughput_measurement.rb

==== Arguments

The throughput_measurement.rb program takes 3 arguments:

  [link_address]  Requires a transport string of the format "transport"://"endpoint"<:><port>. For example, tcp://127.0.0.1:5555
  
  [message size] Size of each message measured in bytes. Allowable range is 1 to 2^(64-1).
  
  [message count] The number of round-trips used for the latency measurements. Allowable range is 1 to 2^(64-1).


==== Execution

In an open terminal, execute the throughput_measurement.rb script.

  % ruby throughput_measurement.rb tcp://127.0.0.1:5555 1024 100_000

On a relatively new system, it can run 100k messages in under 10 seconds. When complete, the program prints out a few statistics and exits.

Running with a larger "message count" will yield a more accurate latency measurement since nearly all Ruby runtimes require a little warm up time to hit their stride. I recommend 100k as a minimum while 1 million is better for determining a true measure. NOTE! The publisher can send much faster than the subscriber so the publisher's queue will grow very rapidly in RAM. For 1 million messages (or more) this can consume hundreds of megabytes or gigabytes of RAM. On my system, sending 10 million messages requires 10 GB of RAM before the subscriber can catch up.

On a desktop computer purchased in 2007, all of the Ruby runtimes report a throughput of approximately 150k messages per second. For comparison, the pure C throughput test reports approximately 260k messages per second.



== Poll

For a reasonable example of using zmq_poll(), take a look at the reqrep_poll.rb program. It illustrates the use of zmq_poll(), as wrapped by the Ruby library, for detecting and responding to read and write events recorded on sockets. It also shows how to use ZMQ::NO_BLOCK/ZMQ::DONTWAIT for non-blocking send and receive.

==== Files

* reqrep_poll.rb

==== Arguments

None.

==== Execution

This program is completely self-contained, so it only requires a single terminal window for execution.

  % ruby reqrep_poll.rb

To avoid loading a system-wide 0mq library, place
the C libraries here. This let's you run your Ruby
code with a 0mq C library build that is different
from the system-wide one. This can be handy for
rolling upgrades or testing.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.Clamp
=====

[![Gem Version](https://badge.fury.io/rb/clamp.png)](http://badge.fury.io/rb/clamp)
[![Build Status](https://secure.travis-ci.org/mdub/clamp.png?branch=master)](http://travis-ci.org/mdub/clamp)

"Clamp" is a minimal framework for command-line utilities.

It handles boring stuff like parsing the command-line, and generating help, so you can get on with making your command actually do stuff.

Not another one!
----------------

Yeah, sorry.  There are a bunch of existing command-line parsing libraries out there, and Clamp draws inspiration from a variety of sources, including [Thor], [optparse], and [Clip].  In the end, though, I wanted a slightly rounder wheel.  (Although, Clamp has a _lot_ in common with Ara T. Howard's [main.rb]. Had I been aware of that project at the time, I might not have written Clamp.)

[optparse]: http://ruby-doc.org/stdlib/libdoc/optparse/rdoc/index.html
[Thor]: http://github.com/wycats/thor
[Clip]: http://clip.rubyforge.org/
[main.rb]: https://github.com/ahoward/main

Quick Start
-----------

A typical Clamp script looks like this:

```ruby
require 'clamp'

Clamp do

  option "--loud", :flag, "say it loud"
  option ["-n", "--iterations"], "N", "say it N times", :default => 1 do |s|
    Integer(s)
  end

  parameter "WORDS ...", "the thing to say", :attribute_name => :words

  def execute
    the_truth = words.join(" ")
    the_truth.upcase! if loud?
    iterations.times do
      puts the_truth
    end
  end

end
```

Internally, Clamp models a command as a Ruby class (a subclass of `Clamp::Command`), and a command execution as an instance of that class.  The example above is really just syntax-sugar for:

```ruby
require 'clamp'

class SpeakCommand < Clamp::Command

  option "--loud", :flag, "say it loud"
  option ["-n", "--iterations"], "N", "say it N times", :default => 1 do |s|
    Integer(s)
  end

  parameter "WORDS ...", "the thing to say", :attribute_name => :words

  def execute
    the_truth = words.join(" ")
    the_truth.upcase! if loud?
    iterations.times do
      puts the_truth
    end
  end

end

SpeakCommand.run
```

Class-level methods like `option` and `parameter` declare attributes, in a similar way to `attr_accessor`, and arrange for them to be populated automatically based on command-line arguments.  They are also used to generate `help` documentation.

There are more examples demonstrating various features of Clamp [on Github][examples].

[examples]: https://github.com/mdub/clamp/tree/master/examples

Declaring options
-----------------

Options are declared using the `option` method.  The three required arguments are:

  1. the option switch (or switches),
  2. an option argument name
  3. a short description

For example:

```ruby
option "--flavour", "FLAVOUR", "ice-cream flavour"
```

It works a little like `attr_accessor`, defining reader and writer methods on the command class.  The attribute name is inferred from the switch (in this case, "`flavour`").  When you pass options to your command, Clamp will populate the attributes, which are then available for use in your `#execute` method.

```ruby
def execute
  puts "You chose #{flavour}.  Excellent choice!"
end
```

If you don't like the inferred attribute name, you can override it:

```ruby
option "--type", "TYPE", "type of widget", :attribute_name => :widget_type
                                           # to avoid clobbering Object#type
```

### Short/long option switches

The first argument to `option` can be an array, rather than a single string, in which case all the switches are treated as aliases:

```ruby
option ["-s", "--subject"], "SUBJECT", "email subject line"
```

### Flag options

Some options are just boolean flags.  Pass "`:flag`" as the second parameter to tell Clamp not to expect an option argument:

```ruby
option "--verbose", :flag, "be chatty"
```

For flag options, Clamp appends "`?`" to the generated reader method; ie. you get a method called "`#verbose?`", rather than just "`#verbose`".

Negatable flags are easy to generate, too:

```ruby
option "--[no-]force", :flag, "be forceful (or not)"
```

Clamp will handle both "`--force`" and "`--no-force`" options, setting the value of "`#force?`" appropriately.

### Required options

Although 'required option' is a an oxymoron, Clamp lets you mark an option as required, and will verify that a value is provided:

```ruby
option "--password", "PASSWORD", "the secret password", :required => true
```

Note that it makes no sense to mark a `:flag` option, or one with a `:default`, as `:required`.

### Multivalued options

Declaring an option "`:multivalued`" allows it to be specified multiple times on the command line.

```ruby
option "--format", "FORMAT", "output format", :multivalued => true
```

The underlying attribute becomes an Array, and the suffix "`_list`" is appended to the default attribute name.  In this case, an attribute called "`format_list`" would be generated (unless you override the default by specifying an `:attribute_name`).

Declaring parameters
--------------------

Positional parameters can be declared using `parameter`, specifying

  1. the parameter name, and
  2. a short description

For example:

```ruby
parameter "SRC", "source file"
```

Like options, parameters are implemented as attributes of the command, with the default attribute name derived from the parameter name (in this case, "`src`"). By convention, parameter names are specified in uppercase, to make them obvious in usage help.

### Optional parameters

Wrapping a parameter name in square brackets indicates that it's optional, e.g.

```ruby
parameter "[TARGET_DIR]", "target directory"
```

### Multivalued (aka "greedy") parameters

Three dots at the end of a parameter name makes it "greedy" - it will consume all remaining command-line arguments.  For example:

```ruby
parameter "FILE ...", "input files", :attribute_name => :files
```

Like multivalued options, greedy parameters are backed by an Array attribute (named with a "`_list`" suffix, by default).

Parsing and validation of options and parameters
------------------------------------------------

When you `#run` a command, it will first attempt to `#parse` command-line arguments, and map them onto the declared options and parameters, before invoking your `#execute` method.

Clamp will verify that all required (ie. non-optional) parameters are present, and signal a error if they aren't.

### Validation

Both `option` and `parameter` accept an optional block.  If present, the block will be
called with the raw string argument, and is expected to validate it.  The value returned by the block will be assigned to the underlying attribute, so it's also a good place to coerce the String to a different type, if appropriate.

For example:

```ruby
option "--port", "PORT", "port to listen on" do |s|
  Integer(s)
end
```

If the block raises an ArgumentError, Clamp will catch it, and report that the value was bad:

```ruby
!!!plain
ERROR: option '--port': invalid value for Integer: "blah"
```

For multivalued options and parameters, the validation block will be called for each value specified.

More complex validation, e.g. those involving multiple options/parameters, should be performed within the `#execute` method.  Use `#signal_usage_error` to tell the user what they did wrong, e.g.

```ruby
def execute
  if port < 1024 && user != 'root'
    signal_usage_error "port restricted for non-root users"
  end
  # ... carry on ...
end
```

### Advanced option/parameter handling

While Clamp provides an attribute-writer method for each declared option or parameter, you always have the option of overriding it to provide custom argument-handling logic, e.g.

```ruby
parameter "SERVER", "location of server"

def server=(server)
  @server_address, @server_port = server.split(":")
end
```

### Default values

Default values can be specified for options, and optional parameters:

```ruby
option "--flavour", "FLAVOUR", "ice-cream flavour", :default => "chocolate"

parameter "[HOST]", "server host", :default => "localhost"
```

For more advanced cases, you can also specify default values by defining a method called "`default_#{attribute_name}`":

```ruby
option "--http-port", "PORT", "web-server port", :default => 9000

option "--admin-port", "PORT", "admin port"

def default_admin_port
   http_port + 1
end
```

### Environment variable support

Options (and optional parameters) can also be associated with environment variables:

```ruby
option "--port", "PORT", "the port to listen on", :environment_variable => "MYAPP_PORT" do |val|
  val.to_i
end

parameter "[HOST]", "server address", :environment_variable => "MYAPP_HOST"
```

Clamp will check the specified envariables in the absence of values supplied on the command line, before looking for a default value.

Declaring Subcommands
---------------------

Subcommand support helps you wrap a number of related commands into a single script (ala tools like "`git`").  Clamp will inspect the first command-line argument (after options are parsed), and delegate to the named subcommand.

Unsuprisingly, subcommands are declared using the `subcommand` method. e.g.

```ruby
Clamp do

  subcommand "init", "Initialize the repository" do

    def execute
      # ...
    end

  end

end
```

Clamp generates an anonymous subclass of the current class, to represent the subcommand.  Alternatively, you can provide an explicit subcommand class:

```ruby
class MainCommand < Clamp::Command

  subcommand "init", "Initialize the repository", InitCommand

end

class InitCommand < Clamp::Command

  def execute
    # ...
  end

end
```

Like options, subcommands may have aliases:

```ruby
Clamp do

  subcommand ["initialize", "init"], "Initialize the repository" do
    # ...
  end

end
```

### Default subcommand

You can set a default subcommand, at the class level, as follows:

```ruby
Clamp do

  self.default_subcommand = "status"

  subcommand "status", "Display current status" do

    def execute
      # ...
    end

  end

end
```

Then, if when no SUBCOMMAND argument is provided, the default will be selected.

### Subcommand options and parameters

Options are inheritable, so any options declared for a command are supported by it's sub-classes (e.g. those created using the block form of `subcommand`).  Parameters, on the other hand, are not inherited - each subcommand must declare it's own parameter list.

Note that, if a subcommand accepts options, they must be specified on the command-line _after_ the subcommand name.

Getting help
------------

All Clamp commands support a "`--help`" option, which outputs brief usage documentation, based on those seemingly useless extra parameters that you had to pass to `option` and `parameter`.

```sh
$ speak --help
Usage:
    speak [OPTIONS] WORDS ...

Arguments:
    WORDS ...                     the thing to say

Options:
    --loud                        say it loud
    -n, --iterations N            say it N times (default: 1)
    -h, --help                    print help
```

License
-------

Copyright (C) 2011 [Mike Williams](mailto:mdub@dogbiscuit.org)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Contributing to Clamp
---------------------

Source-code for Clamp is [on Github](https://github.com/mdub/clamp).
= Backports Library {<img src="https://travis-ci.org/marcandre/backports.png?branch=master">}[https://travis-ci.org/marcandre/backports] {<img src="https://badge.fury.io/rb/backports.png" alt="Gem Version" />}[http://badge.fury.io/rb/backports] {<img alt='Click here to lend your support to: Ruby Backports and make a donation at www.pledgie.com !' src='http://www.pledgie.com/campaigns/19510.png?skin_name=chrome' border='0'}[http://www.pledgie.com/campaigns/19510]

* Yearning to use some of the new cool features in Ruby 2.0.0 while using 1.8.6?
* One of your client is stuck with Ruby 1.8.6 but you want to use a gem using some features of 1.8.7?
* Can't remember if you can use Array#sample or String#each_char on a friend's box?

This gem is for you!

The goal of 'backports' is to make it easier to write ruby code that runs across different versions of Ruby.

For example, if you want to use flat_map, even in Ruby implementations that don't include it, as well as the new bsearch method:

  require 'backports/1.9.2/enumerable/flat_map'
  require 'backports/2.0.0/array/bsearch'

This will enable Enumerable#flat_map and Array#bsearch, using the native versions if available or otherwise provide a pure Ruby version.

You can load many backports at once. For example, any version of Ruby up to today's standards:

  require 'backports'

This will bring in all the features of 1.8.7 and many features of Ruby 1.9.x and even Ruby 2.0.0 (for all versions of Ruby)!

+Note+: Although I am a Ruby committer, this gem is a personal project and is not endorsed by ruby-core.

== What's inside

Goals for backported features:
1. Won't break older code
2. Pure Ruby (no C extensions)
3. Pass RubySpec[http://github.com/rubyspec/rubyspec]

Let's be a bit more precise about the "breaking code" business. It is of course entirely possible that code will break, for example some core methods are monkeypatched or if the code relies on a certain call raising an exception. Example: <tt>[42].sample rescue "dum example"</tt> will return <tt>"dum example"</tt> without this gem and <tt>42</tt> with it.

A real incompatibility is, for example, <tt>Module::instance_methods</tt> which returns strings in 1.8 and symbols in 1.9. No change can be made without the risk of breaking existing code. Such incompatibilities are left unchanged, although you can require some of these changes in addition (see below)

All features of 1.8.7 are backported (well, almost all, see the exception list bellow), and many of the following versions up to 2.1

For historical reasons, some generic and self-contained features of active-support are also included. By simple I mean that String#camelcase is there, but #pluralize isn't. These will probably be removed in the future, so it's recommended to require those directly from active_support.

== Installation & compatibility

+backports+ is can be installed with:

  (sudo) gem install backports

To use:

  require 'rubygems'
  # For only specific backports:
  require 'backports/1.9.1/kernel/require_relative'
  require 'backports/2.0.0/enumerable/lazy'

  # For all backports up to a given version
  require 'backports/1.9.2' # All backports for Ruby 1.9.2 and below

  # Or for all backports
  require 'backports'

Note: about a dozen of backports have a dependency that will be also loaded. For example, the backport of Enumerable#flat_map uses flatten(1), so if required from Ruby 1.8.6 (where Array#flatten does not accept an argument), the backport for Ruby's 1.8.7 flatten with an argument will also be loaded.

With bundler, add to your Gemfile:

  gem 'backports', :require => false

Run <tt>bundle install</tt> and require the desired backports.

Compatible with Ruby 1.8.6, 1.8.7, 1.9.1, 1.9.2, 1.9.3, 2.0, 2.1, JRuby and Rubinius.

= Complete List of backports

== Ruby 2.1 backports

* Array
  * +to_h+
* Bignum
  * +bit_length+
* Enumerable
  * +to_h+
* Fixnum
  * +bit_length+
* Module
  * +include+ (now public)

== Ruby 2.0 backports

* Array
  * +bsearch+
* Enumerable
  * +lazy+
* Enumerator::Lazy
  * all methods
* Hash
  * <tt>default_proc=</tt> (with nil argument)
  * +to_h+
* nil.to_h
* Range
  * +bsearch+
* Struct
  * +to_h+

== Ruby 1.9.3 backports

* File
  * +NULL+
* IO
  * +advise+ (acts as a noop)
  * +write+, +binwrite+
* String
  * +byteslice+
  * +prepend+

== Ruby 1.9.2 backports

* Array
  * <tt>rotate, rotate!</tt>
  * <tt>keep_if, select!</tt>
  * +product+ (with block)
  * +repeated_combination+, +repeated_permutation+
  * <tt>sort_by!</tt>
  * <tt>uniq, uniq!</tt> (with block)

* Complex
  * +to_r+

* Dir
  * +home+

* Enumerable
  * +chunk+
  * +flat_map+, +collect_concat+
  * +join+
  * +slice_before+

* Float::INFINITY, NAN

* Hash
  * +keep_if+, <tt>select!</tt>

* Object
  * <tt>singleton_class</tt>

* Random (new class)

*Note*: The methods of +Random+ can't be required individually; the class can only be required whole with <tt>require 'backports/1.9.2/random'</tt>. The implementation is also available with <tt>require 'backports/random/implementation'</tt>.

== Ruby 1.9.1 backports

Additionally, the following Ruby 1.9 features have been backported:
* Array
  * +try_convert+
  * +sample+

* Enumerable
  * +each_with_object+
  * +each_with_index+ (with arguments)

* Enumerator
  * +new+ (with block)

* File
  * +binread+
  * +to_path+
  * All class methods accepting filenames will accept files or anything with a <tt>#to_path</tt> method.
  * <tt>File.open</tt> accepts an options hash.

* Float
  * +round+

* Hash
  * +assoc+, +rassoc+
  * +key+
  * +try_convert+
  * <tt>default_proc=</tt>

* Integer
  * +magnitude+
  * +round+

* IO
  * +bin_read+
  * +try_convert+
  * +ungetbyte+
  * <tt>IO.open</tt> accepts an options hash.

* Kernel
  * +require_relative+

* Math
  * +log+ (with base)
  * +log2+

* Numeric
  * +round+

* Object
  * +define_singleton_method+
  * +public_method+
  * +public_send+

* Proc
  * +yield+
  * +lambda?+
  * +curry+
  * <tt>===</tt>

* Range
  * <tt>cover?</tt>

* Regexp
  * +try_convert+

* String
  * <tt>ascii_only?</tt>
  * +chr+
  * +clear+
  * +codepoints+, +each_codepoint+
  * +get_byte+, +set_byte+
  * +ord+
  * +try_convert+

+Enumerator+ can be accessed directly (instead of <tt>Enumerable::Enumerator</tt>)

To include _only_ these backports and those of the 1.8 line, <tt>require "backports/1.9.1"</tt>.

Moreover, a pretty good imitation of +BasicObject+ is available,
but since it is only an imitation, it must be required explicitly:

  require 'backports/basic_object'

== Ruby 1.8.7

Complete Ruby 1.8.7 backporting (core language). Refer to the official list of changes[https://github.com/ruby/ruby/blob/ruby_1_8_7/NEWS]. That's about 130 backports!

Only exceptions:
* String#gsub (the form returning an enumerator)
* GC.stress=  (not implemented)
* Array#choice (removed in 1.9, use 1.9.1's Array#sample instead)

== Libraries

Libraries are slowly being backported. You simply require them as usual after requiring 'backports/std_lib'. Requiring 'backports/std_lib' after the standard libraries is also supported.

  require "backports/std_lib"
  require "prime"
  42.prime? # => false, even in Ruby 1.8.x

The following libraries are up to date with Ruby 1.9.3:

* Matrix
* Prime
* Set

The following library is to date with Ruby 2.0.0:

* OpenStruct (ostruct)

I am aware of the following backport gem, which probably won't make it into this gem:

* Net::SMTP for Ruby 1.8.6: smtp_tls[http://seattlerb.rubyforge.org/smtp_tls/]

Requiring the whole of 'backports', or all backports for a given version of Ruby will also load 'backports/std_lib'.

== Forcing incompatibilities

Some backports would create incompatibilities in their current Ruby version but could be useful in some projects. It is possible to request such incompatible changes. Backports currently supports the following:

* Hash
  * +select+ (returns a Hash instead of an Array)

* Enumerable / Array
  * +map+ (returns an enumerator when called without a block)

* String
  * +length+, +size+ (for UTF-8 support)

These must be imported in addition to the backports gem, for example:

  require "backports/force/hash_select"
  {}.select{} # => {}, even in Ruby 1.8


== Thanks

Thanks for the bug reports and patches, in particular the repeat offenders:

* Arto Bendiken ( bendiken[http://github.com/bendiken] )
* Konstantin Haase ( rkh[https://github.com/rkh])
* Roger Pack ( rdp[http://github.com/rdp] )

The best way to submit a patch is to also submit a patch to RubySpec[https://github.com/rubyspec/rubyspec] and then a patch to backports that make it pass the spec. To test rubyspec:

    git submodule init && git submodule update # => pulls rubyspecs
    rake spec[array/bsearch]       # => tests Array#bsearch
    rake spec[array/*]             # => tests all backported Array methods
    rake spec  (or rake spec[*/*]) # => all rubyspecs for backported methods

Failures that are acceptable are added the to `tags` file.

= License

+backports+ is released under the terms of the MIT License, see the included LICENSE file.

Author::                 Marc-André Lafortune
`rake test` will run the tests in here.
`rake spec` will run the rubyspecs.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.Clamp
=====

[![Gem Version](https://badge.fury.io/rb/clamp.png)](http://badge.fury.io/rb/clamp)
[![Build Status](https://secure.travis-ci.org/mdub/clamp.png?branch=master)](http://travis-ci.org/mdub/clamp)

"Clamp" is a minimal framework for command-line utilities.

It handles boring stuff like parsing the command-line, and generating help, so you can get on with making your command actually do stuff.

Not another one!
----------------

Yeah, sorry.  There are a bunch of existing command-line parsing libraries out there, and Clamp draws inspiration from a variety of sources, including [Thor], [optparse], and [Clip].  In the end, though, I wanted a slightly rounder wheel.  (Although, Clamp has a _lot_ in common with Ara T. Howard's [main.rb]. Had I been aware of that project at the time, I might not have written Clamp.)

[optparse]: http://ruby-doc.org/stdlib/libdoc/optparse/rdoc/index.html
[Thor]: http://github.com/wycats/thor
[Clip]: http://clip.rubyforge.org/
[main.rb]: https://github.com/ahoward/main

Quick Start
-----------

A typical Clamp script looks like this:

```ruby
require 'clamp'

Clamp do

  option "--loud", :flag, "say it loud"
  option ["-n", "--iterations"], "N", "say it N times", :default => 1 do |s|
    Integer(s)
  end

  parameter "WORDS ...", "the thing to say", :attribute_name => :words

  def execute
    the_truth = words.join(" ")
    the_truth.upcase! if loud?
    iterations.times do
      puts the_truth
    end
  end

end
```

Internally, Clamp models a command as a Ruby class (a subclass of `Clamp::Command`), and a command execution as an instance of that class.  The example above is really just syntax-sugar for:

```ruby
require 'clamp'

class SpeakCommand < Clamp::Command

  option "--loud", :flag, "say it loud"
  option ["-n", "--iterations"], "N", "say it N times", :default => 1 do |s|
    Integer(s)
  end

  parameter "WORDS ...", "the thing to say", :attribute_name => :words

  def execute
    the_truth = words.join(" ")
    the_truth.upcase! if loud?
    iterations.times do
      puts the_truth
    end
  end

end

SpeakCommand.run
```

Class-level methods like `option` and `parameter` declare attributes, in a similar way to `attr_accessor`, and arrange for them to be populated automatically based on command-line arguments.  They are also used to generate `help` documentation.

There are more examples demonstrating various features of Clamp [on Github][examples].

[examples]: https://github.com/mdub/clamp/tree/master/examples

Declaring options
-----------------

Options are declared using the `option` method.  The three required arguments are:

  1. the option switch (or switches),
  2. an option argument name
  3. a short description

For example:

```ruby
option "--flavour", "FLAVOUR", "ice-cream flavour"
```

It works a little like `attr_accessor`, defining reader and writer methods on the command class.  The attribute name is inferred from the switch (in this case, "`flavour`").  When you pass options to your command, Clamp will populate the attributes, which are then available for use in your `#execute` method.

```ruby
def execute
  puts "You chose #{flavour}.  Excellent choice!"
end
```

If you don't like the inferred attribute name, you can override it:

```ruby
option "--type", "TYPE", "type of widget", :attribute_name => :widget_type
                                           # to avoid clobbering Object#type
```

### Short/long option switches

The first argument to `option` can be an array, rather than a single string, in which case all the switches are treated as aliases:

```ruby
option ["-s", "--subject"], "SUBJECT", "email subject line"
```

### Flag options

Some options are just boolean flags.  Pass "`:flag`" as the second parameter to tell Clamp not to expect an option argument:

```ruby
option "--verbose", :flag, "be chatty"
```

For flag options, Clamp appends "`?`" to the generated reader method; ie. you get a method called "`#verbose?`", rather than just "`#verbose`".

Negatable flags are easy to generate, too:

```ruby
option "--[no-]force", :flag, "be forceful (or not)"
```

Clamp will handle both "`--force`" and "`--no-force`" options, setting the value of "`#force?`" appropriately.

### Required options

Although 'required option' is a an oxymoron, Clamp lets you mark an option as required, and will verify that a value is provided:

```ruby
option "--password", "PASSWORD", "the secret password", :required => true
```

Note that it makes no sense to mark a `:flag` option, or one with a `:default`, as `:required`.

### Multivalued options

Declaring an option "`:multivalued`" allows it to be specified multiple times on the command line.

```ruby
option "--format", "FORMAT", "output format", :multivalued => true
```

The underlying attribute becomes an Array, and the suffix "`_list`" is appended to the default attribute name.  In this case, an attribute called "`format_list`" would be generated (unless you override the default by specifying an `:attribute_name`).

Declaring parameters
--------------------

Positional parameters can be declared using `parameter`, specifying

  1. the parameter name, and
  2. a short description

For example:

```ruby
parameter "SRC", "source file"
```

Like options, parameters are implemented as attributes of the command, with the default attribute name derived from the parameter name (in this case, "`src`"). By convention, parameter names are specified in uppercase, to make them obvious in usage help.

### Optional parameters

Wrapping a parameter name in square brackets indicates that it's optional, e.g.

```ruby
parameter "[TARGET_DIR]", "target directory"
```

### Multivalued (aka "greedy") parameters

Three dots at the end of a parameter name makes it "greedy" - it will consume all remaining command-line arguments.  For example:

```ruby
parameter "FILE ...", "input files", :attribute_name => :files
```

Like multivalued options, greedy parameters are backed by an Array attribute (named with a "`_list`" suffix, by default).

Parsing and validation of options and parameters
------------------------------------------------

When you `#run` a command, it will first attempt to `#parse` command-line arguments, and map them onto the declared options and parameters, before invoking your `#execute` method.

Clamp will verify that all required (ie. non-optional) parameters are present, and signal a error if they aren't.

### Validation

Both `option` and `parameter` accept an optional block.  If present, the block will be
called with the raw string argument, and is expected to validate it.  The value returned by the block will be assigned to the underlying attribute, so it's also a good place to coerce the String to a different type, if appropriate.

For example:

```ruby
option "--port", "PORT", "port to listen on" do |s|
  Integer(s)
end
```

If the block raises an ArgumentError, Clamp will catch it, and report that the value was bad:

```ruby
!!!plain
ERROR: option '--port': invalid value for Integer: "blah"
```

For multivalued options and parameters, the validation block will be called for each value specified.

More complex validation, e.g. those involving multiple options/parameters, should be performed within the `#execute` method.  Use `#signal_usage_error` to tell the user what they did wrong, e.g.

```ruby
def execute
  if port < 1024 && user != 'root'
    signal_usage_error "port restricted for non-root users"
  end
  # ... carry on ...
end
```

### Advanced option/parameter handling

While Clamp provides an attribute-writer method for each declared option or parameter, you always have the option of overriding it to provide custom argument-handling logic, e.g.

```ruby
parameter "SERVER", "location of server"

def server=(server)
  @server_address, @server_port = server.split(":")
end
```

### Default values

Default values can be specified for options, and optional parameters:

```ruby
option "--flavour", "FLAVOUR", "ice-cream flavour", :default => "chocolate"

parameter "[HOST]", "server host", :default => "localhost"
```

For more advanced cases, you can also specify default values by defining a method called "`default_#{attribute_name}`":

```ruby
option "--http-port", "PORT", "web-server port", :default => 9000

option "--admin-port", "PORT", "admin port"

def default_admin_port
   http_port + 1
end
```

### Environment variable support

Options (and optional parameters) can also be associated with environment variables:

```ruby
option "--port", "PORT", "the port to listen on", :environment_variable => "MYAPP_PORT" do |val|
  val.to_i
end

parameter "[HOST]", "server address", :environment_variable => "MYAPP_HOST"
```

Clamp will check the specified envariables in the absence of values supplied on the command line, before looking for a default value.

Declaring Subcommands
---------------------

Subcommand support helps you wrap a number of related commands into a single script (ala tools like "`git`").  Clamp will inspect the first command-line argument (after options are parsed), and delegate to the named subcommand.

Unsuprisingly, subcommands are declared using the `subcommand` method. e.g.

```ruby
Clamp do

  subcommand "init", "Initialize the repository" do

    def execute
      # ...
    end

  end

end
```

Clamp generates an anonymous subclass of the current class, to represent the subcommand.  Alternatively, you can provide an explicit subcommand class:

```ruby
class MainCommand < Clamp::Command

  subcommand "init", "Initialize the repository", InitCommand

end

class InitCommand < Clamp::Command

  def execute
    # ...
  end

end
```

Like options, subcommands may have aliases:

```ruby
Clamp do

  subcommand ["initialize", "init"], "Initialize the repository" do
    # ...
  end

end
```

### Default subcommand

You can set a default subcommand, at the class level, as follows:

```ruby
Clamp do

  self.default_subcommand = "status"

  subcommand "status", "Display current status" do

    def execute
      # ...
    end

  end

end
```

Then, if when no SUBCOMMAND argument is provided, the default will be selected.

### Subcommand options and parameters

Options are inheritable, so any options declared for a command are supported by it's sub-classes (e.g. those created using the block form of `subcommand`).  Parameters, on the other hand, are not inherited - each subcommand must declare it's own parameter list.

Note that, if a subcommand accepts options, they must be specified on the command-line _after_ the subcommand name.

Getting help
------------

All Clamp commands support a "`--help`" option, which outputs brief usage documentation, based on those seemingly useless extra parameters that you had to pass to `option` and `parameter`.

```sh
$ speak --help
Usage:
    speak [OPTIONS] WORDS ...

Arguments:
    WORDS ...                     the thing to say

Options:
    --loud                        say it loud
    -n, --iterations N            say it N times (default: 1)
    -h, --help                    print help
```

License
-------

Copyright (C) 2011 [Mike Williams](mailto:mdub@dogbiscuit.org)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Contributing to Clamp
---------------------

Source-code for Clamp is [on Github](https://github.com/mdub/clamp).
![The HTTP Gem](https://raw.github.com/tarcieri/http/master/logo.png)
==============
[![Gem Version](https://badge.fury.io/rb/http.png)](http://rubygems.org/gems/http)
[![Build Status](https://secure.travis-ci.org/tarcieri/http.png?branch=master)](http://travis-ci.org/tarcieri/http)
[![Code Climate](https://codeclimate.com/github/tarcieri/http.png)](https://codeclimate.com/github/tarcieri/http)
[![Coverage Status](https://coveralls.io/repos/tarcieri/http/badge.png?branch=master)](https://coveralls.io/r/tarcieri/http)

SEO Note
--------

This Gem has the worst name in the history of SEO. But perhaps we can fix that if we
all refer to it as "The HTTP Gem", or even better, the "Ruby HTTP Gem".

About
-----

The HTTP Gem is an easy-to-use client library for making requests from Ruby. It uses
a simple method chaining system for building requests, similar to Python's [Requests]

Under the hood, The HTTP Gem uses [http_parser.rb], a fast HTTP parsing native
extension based on the Node.js parser and a Java port thereof.

[requests]: http://docs.python-requests.org/en/latest/
[http_parser.rb]: https://github.com/tmm1/http_parser.rb

Help and Discussion
-------------------

If you need help or just want to talk about the Ruby HTTP Gem, [visit our Google
Group][googlegroup], or join by email by sending a message to:
[ruby-http-gem+subscribe@googlegroups.com][subscribe].

[googlegroup]: https://groups.google.com/forum/#!forum/ruby-http-gem
[subscribe]:   mailto:ruby-http-gem+subscribe@googlegroups.com

If you believe you've found a bug, please report it at:

https://github.com/tarcieri/http/issues

Installation
------------

Add this line to your application's Gemfile:

    gem 'http'

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install http

Inside of your Ruby program do:

    require 'http'

...to pull it in as a dependency.

Documentation
-------------

[Please see the HTTP Gem Wiki](https://github.com/tarcieri/http/wiki)
for more detailed documentation and usage notes.

Basic Usage
-----------

Here's some simple examples to get you started:

### GET requests

```ruby
>> HTTP.get("http://www.google.com").to_s
=> "<html><head><meta http-equiv=\"content-type\" content=..."
```

That's all it takes! To obtain an `HTTP::Response` object instead of the response
body, all we have to do is omit the #to_s on the end:

```ruby
>> HTTP.get("http://www.google.com")
=> #<HTTP/1.0 200 OK @headers={"Content-Type"=>"text/html; charset=UTF-8", "Date"=>"Fri, ...>
 => #<HTTP::Response/1.1 200 OK @headers={"Content-Type"=>"text/html; ...>
```

We can also obtain an `HTTP::ResponseBody` object for this response:

```ruby
>> HTTP.get("http://www.google.com").body
 => #<HTTP::ResponseBody:814d7aac @streaming=false>
```

The response body can be streamed with `HTTP::ResponseBody#readpartial`:

```ruby
>> HTTP.get("http://www.google.com").body.readpartial
 => "<!doctype html><html "
```

In practice you'll want to bind the HTTP::ResponseBody to a local variable (e.g.
"body") and call readpartial on it repeatedly until it returns nil.

### POST requests

Making POST requests is simple too. Want to POST a form?

```ruby
HTTP.post "http://example.com/resource", :form => {:foo => "42"}
```
Making GET requests with query string parameters is as simple.

```ruby
HTTP.get "http://example.com/resource", :params => {:foo => "bar"}
```

Want to POST with a specific body, JSON for instance?

```ruby
HTTP.post "http://example.com/resource", :json => { :foo => '42' }
```

It's easy!


### Proxy Support

Making request behind proxy is as simple as making them directly. Just specify
hostname (or IP address) of your proxy server and it's port, and here you go:

```ruby
HTTP.via("proxy-hostname.local", 8080)
  .get "http://example.com/resource"
```

Proxy needs authentication? No problem:

```ruby
HTTP.via("proxy-hostname.local", 8080, "username", "password")
  .get "http://example.com/resource"
```


### Adding Headers

The HTTP gem uses the concept of chaining to simplify requests. Let's say
you want to get the latest commit of this library from Github in JSON format.
One way we could do this is by tacking a filename on the end of the URL:

```ruby
HTTP.get "https://github.com/tarcieri/http/commit/HEAD.json"
```

The Github API happens to support this approach, but really this is a bit of a
hack that makes it easy for people typing URLs into the address bars of
browsers to perform the act of content negotiation. Since we have access to
the full, raw power of HTTP, we can perform content negotiation the way HTTP
intends us to, by using the Accept header:

```ruby
HTTP.with_headers(:accept => 'application/json').
  get("https://github.com/tarcieri/http/commit/HEAD")
```

This requests JSON from Github. Github is smart enough to understand our
request and returns a response with Content-Type: application/json. If you
happen to have a library loaded which defines the JSON constant and implements
JSON.parse, the HTTP gem will attempt to parse the JSON response.

Shorter aliases exists for HTTP.with_headers:

```ruby
HTTP.with(:accept => 'application/json').
  get("https://github.com/tarcieri/http/commit/HEAD")

HTTP[:accept => 'application/json'].
  get("https://github.com/tarcieri/http/commit/HEAD")
```

### Content Negotiation

As important a concept as content negotiation is to HTTP, it sure should be easy,
right? But usually it's not, and so we end up adding ".json" onto the ends of
our URLs because the existing mechanisms make it too hard. It should be easy:

```ruby
HTTP.accept(:json).get("https://github.com/tarcieri/http/commit/HEAD")
```

This adds the appropriate Accept header for retrieving a JSON response for the
given resource.


### Celluloid::IO Support

The HTTP Gem makes it simple to make multiple concurrent HTTP requests from a
Celluloid::IO actor. Here's a parallel HTTP fetcher with the HTTP Gem and
Celluloid::IO:

```ruby
require 'celluloid/io'
require 'http'

class HttpFetcher
  include Celluloid::IO

  def fetch(url)
    HTTP.get(url, socket_class: Celluloid::IO::TCPSocket)
  end
end
```

There's a little more to it, but that's the core idea!

* [Full parallel HTTP fetcher example](https://github.com/tarcieri/http/wiki/Parallel-requests-with-Celluloid%3A%3AIO)
* See also: [Celluloid::IO](https://github.com/celluloid/celluloid-io)


Supported Ruby Versions
-----------------------

This library aims to support and is [tested against][travis] the following Ruby
versions:

* Ruby 1.8.7
* Ruby 1.9.2
* Ruby 1.9.3
* Ruby 2.0.0
* Ruby 2.1.0

If something doesn't work on one of these versions, it's a bug.

This library may inadvertently work (or seem to work) on other Ruby versions,
however support will only be provided for the versions listed above.

If you would like this library to support another Ruby version or
implementation, you may volunteer to be a maintainer. Being a maintainer
entails making sure all tests run and pass on that implementation. When
something breaks on your implementation, you will be responsible for providing
patches in a timely fashion. If critical issues for a particular implementation
exist at the time of a major release, support for that Ruby version may be
dropped.

[travis]: http://travis-ci.org/tarcieri/http


Contributing to The HTTP Gem
----------------------------

* Fork the HTTP gem on github
* Make your changes and send me a pull request
* If we like them we'll merge them
* If we've accepted a patch, feel free to ask for commit access!

Copyright
---------

Copyright (c) 2014 Tony Arcieri, Erik Michaels-Ober. See LICENSE.txt for further details.
# axiom-types

Define types with optional constraints for use within axiom and other libraries.

[![Gem Version](https://badge.fury.io/rb/axiom-types.png)][gem]
[![Build Status](https://secure.travis-ci.org/dkubb/axiom-types.png?branch=master)][travis]
[![Dependency Status](https://gemnasium.com/dkubb/axiom-types.png)][gemnasium]
[![Code Climate](https://codeclimate.com/github/dkubb/axiom-types.png)][codeclimate]
[![Coverage Status](https://coveralls.io/repos/dkubb/axiom-types/badge.png?branch=master)][coveralls]

[gem]: https://rubygems.org/gems/axiom-types
[travis]: https://travis-ci.org/dkubb/axiom-types
[gemnasium]: https://gemnasium.com/dkubb/axiom-types
[codeclimate]: https://codeclimate.com/github/dkubb/axiom-types
[coveralls]: https://coveralls.io/r/dkubb/axiom-types

## Examples

```ruby
# Setup constraints for all defined types
Axiom::Types.finalize

# Create Name subtype
Name = Axiom::Types::String.new do
  minimum_length 1
  maximum_length 30
end

# Test if the string is a member of the type
Name.include?('a')       # => true
Name.include?('a' * 30)  # => true
Name.include?('')        # => false
Name.include?('a' * 31)  # => false
```

## Contributing

See [CONTRIBUTING.md](CONTRIBUTING.md) for details.

## Copyright

Copyright &copy; 2013 Dan Kubb. See LICENSE for details.
You should use protection!

This gem protects against typical web attacks.
Should work for all Rack apps, including Rails.

# Usage

Use all protections you probably want to use:

``` ruby
# config.ru
require 'rack/protection'
use Rack::Protection
run MyApp
```

Skip a single protection middleware:

``` ruby
# config.ru
require 'rack/protection'
use Rack::Protection, :except => :path_traversal
run MyApp
```

Use a single protection middleware:

``` ruby
# config.ru
require 'rack/protection'
use Rack::Protection::AuthenticityToken
run MyApp
```

# Prevented Attacks

## Cross Site Request Forgery

Prevented by:

* `Rack::Protection::AuthenticityToken` (not included by `use Rack::Protection`)
* `Rack::Protection::FormToken` (not included by `use Rack::Protection`)
* `Rack::Protection::JsonCsrf`
* `Rack::Protection::RemoteReferrer` (not included by `use Rack::Protection`)
* `Rack::Protection::RemoteToken`
* `Rack::Protection::HttpOrigin`

## Cross Site Scripting

Prevented by:

* `Rack::Protection::EscapedParams` (not included by `use Rack::Protection`)
* `Rack::Protection::XSSHeader` (Internet Explorer only)

## Clickjacking

Prevented by:

* `Rack::Protection::FrameOptions`

## Directory Traversal

Prevented by:

* `Rack::Protection::PathTraversal`

## Session Hijacking

Prevented by:

* `Rack::Protection::SessionHijacking`

## IP Spoofing

Prevented by:

* `Rack::Protection::IPSpoofing`

# Installation

    gem install rack-protection

# Instrumentation

Instrumentation is enabled by passing in an instrumenter as an option.
```
use Rack::Protection, instrumenter: ActiveSupport::Notifications
```

The instrumenter is passed a namespace (String) and environment (Hash). The namespace is 'rack.protection' and the attack type can be obtained from the environment key 'rack.protection.attack'.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# MultiJSON

[![Gem Version](http://img.shields.io/gem/v/multi_json.svg)][gem]
[![Build Status](http://travis-ci.org/intridea/multi_json.svg)][travis]
[![Dependency Status](http://img.shields.io/gemnasium/intridea/multi_json.svg)][gemnasium]
[![Code Climate](http://img.shields.io/codeclimate/github/intridea/multi_json.svg)][codeclimate]

[gem]: https://rubygems.org/gems/multi_json
[travis]: http://travis-ci.org/intridea/multi_json
[gemnasium]: https://gemnasium.com/intridea/multi_json
[codeclimate]: https://codeclimate.com/github/intridea/multi_json

Lots of Ruby libraries parse JSON and everyone has their favorite JSON coder.
Instead of choosing a single JSON coder and forcing users of your library to be
stuck with it, you can use MultiJSON instead, which will simply choose the
fastest available JSON coder. Here's how to use it:

```ruby
require 'multi_json'

MultiJson.load('{"abc":"def"}') #=> {"abc" => "def"}
MultiJson.load('{"abc":"def"}', :symbolize_keys => true) #=> {:abc => "def"}
MultiJson.dump({:abc => 'def'}) # convert Ruby back to JSON
MultiJson.dump({:abc => 'def'}, :pretty => true) # encoded in a pretty form (if supported by the coder)
```

When loading invalid JSON, MultiJson will throw a `MultiJson::ParseError`. `MultiJson::DecodeError` and `MultiJson::LoadError` are aliases for backwards compatibility.

```ruby
begin
  MultiJson.load('{invalid json}')
rescue MultiJson::ParseError => exception
  exception.data # => "{invalid json}"
  exception.cause # => JSON::ParserError: 795: unexpected token at '{invalid json}'
end
```

`ParseError` instance has `cause` reader which contains the original exception.
It also has `data` reader with the input that caused the problem.

The `use` method, which sets the MultiJson adapter, takes either a symbol or a
class (to allow for custom JSON parsers) that responds to both `.load` and `.dump`
at the class level.

When MultiJson fails to load the specified adapter, it'll throw `MultiJson::AdapterError`
which inherits from `ArgumentError`.

MultiJSON tries to have intelligent defaulting. That is, if you have any of the
supported engines already loaded, it will utilize them before attempting to
load any. When loading, libraries are ordered by speed. First Oj, then Yajl,
then the JSON gem, then JSON pure. If no other JSON library is available,
MultiJSON falls back to [OkJson][], a simple, vendorable JSON parser.

[okjson]: https://github.com/kr/okjson

## Supported JSON Engines

* [Oj](https://github.com/ohler55/oj) Optimized JSON by Peter Ohler
* [Yajl](https://github.com/brianmario/yajl-ruby) Yet Another JSON Library by Brian Lopez
* [JSON](https://github.com/flori/json) The default JSON gem with C-extensions (ships with Ruby 1.9)
* [JSON Pure](https://github.com/flori/json) A Ruby variant of the JSON gem
* [NSJSONSerialization](https://developer.apple.com/library/ios/#documentation/Foundation/Reference/NSJSONSerialization_Class/Reference/Reference.html) Wrapper for Apple's NSJSONSerialization in the Cocoa Framework (MacRuby only)
* [gson.rb](https://github.com/avsej/gson.rb) A Ruby wrapper for google-gson library (JRuby only)
* [JrJackson](https://github.com/guyboertje/jrjackson) JRuby wrapper for Jackson (JRuby only)
* [OkJson][okjson] A simple, vendorable JSON parser

## Supported Ruby Versions
This library aims to support and is [tested against][travis] the following Ruby
implementations:

* Ruby 1.8.7
* Ruby 1.9.2
* Ruby 1.9.3
* Ruby 2.0.0
* Ruby 2.1.1
* [JRuby][]
* [Rubinius][]
* [MacRuby][] (not tested on Travis CI)

[jruby]: http://www.jruby.org/
[rubinius]: http://rubini.us/
[macruby]: http://www.macruby.org/

If something doesn't work on one of these interpreters, it's a bug.

This library may inadvertently work (or seem to work) on other Ruby
implementations, however support will only be provided for the versions listed
above.

If you would like this library to support another Ruby version, you may
volunteer to be a maintainer. Being a maintainer entails making sure all tests
run and pass on that implementation. When something breaks on your
implementation, you will be responsible for providing patches in a timely
fashion. If critical issues for a particular implementation exist at the time
of a major release, support for that Ruby version may be dropped.

## Versioning

This library aims to adhere to [Semantic Versioning 2.0.0][semver]. Violations
of this scheme should be reported as bugs. Specifically, if a minor or patch
version is released that breaks backward compatibility, that version should be
immediately yanked and/or a new version should be immediately released that
restores compatibility. Breaking changes to the public API will only be
introduced with new major versions. As a result of this policy, you can (and
should) specify a dependency on this gem using the [Pessimistic Version
Constraint][pvc] with two digits of precision. For example:

```ruby
spec.add_dependency 'multi_json', '~> 1.0'
```

[semver]: http://semver.org/
[pvc]: http://docs.rubygems.org/read/chapter/16#page74

## Copyright
Copyright (c) 2010-2013 Michael Bleigh, Josh Kalderimis, Erik Michaels-Ober,
and Pavel Pravosud. See [LICENSE][] for details.

[license]: LICENSE.md
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.= SNMP Library for Ruby

== Summary

This library implements SNMP (the Simple Network Management Protocol).  It is
implemented in pure Ruby, so there are no dependencies on external libraries
like net-snmp[http://www.net-snmp.org/].  You can run this library anywhere
that Ruby can run.

See snmplib.rubyforge.org[http://snmplib.rubyforge.org/] for more info.

This release supports the following:

* The GetRequest, GetNextRequest, GetBulkRequest, SetRequest, Response
  SNMPv1_Trap, SNMPv2_Trap, and Inform PDUs
* All of the ASN.1 data types defined by SNMPv1 and SNMPv2c
* Sending informs and v1 and v2 traps
* Trap handling for informs and v1 and v2 traps
* Symbolic OID values (ie. "ifTable" instead of "1.3.6.1.2.1.2.2") as   
  parameters to the SNMP::Manager API
* Includes symbol data files for all current IETF MIBs
* Compatible with Ruby 1.9 and higher

See the SNMP::Manager, SNMP::TrapListener, and SNMP::MIB classes and the
examples below for more details.

== Changes

Changes for version 1.2.0:
* Removed support for Ruby 1.8
* Changed license to MIT License

Changes for version 1.1.1:

* Incorporate various small pull requests

Changes for version 1.1.0:

* Added MIB support to ObjectId and Varbind, so that to_s can return symbolic information
* Added to_str method to ObjectId to return a numeric OID string (old to_s behavior)
* TrapListener can now support multiple community strings

Changes for version 1.0.4:

* New option handling and added lower-case versions of all options
* Added SNMP::VERSION constant
* Experimental support for IPv6
* Removed support for installation with setup.rb

Changes for version 1.0.3:

* Minor changes to Manager class.  The :Transport option may now be an
  object or a class.  Explicity call Timeout.timeout so that a timeout
  method may be defined in subclasses.  Thanks to Eric Monti.

Changes for version 1.0.2:

* Internal code changes to make this library compatible with both Ruby 1.8
  and Ruby 1.9.  Note that an ord() method is now added to the Fixnum class
  for Ruby 1.8.  See the ber.rb file for details.

Changes for version 1.0.1:

* Made the host configurable for the TrapListener.  Previously defaulted
  to 'localhost'.

Changes for version 1.0.0:

* Added to_s method to TimeTicks.  Displays time in human-readable form
  instead of just a number.  The to_i method can still be used to get the
  number of ticks.

== Installation

You can use RubyGems [http://rubygems.org/] to
install the latest version of the SNMP library.

  gem install snmp

== Testing

This library has received limited testing:
* The unit tests have been executed with both Ruby 1.9.3 and Ruby 2.1.2 on
  Mac OS X 10.9.
* Basic interoperability testing has been done with the
  net-snmp[http://www.net-snmp.org/] tools.

I'm very interested in hearing about successes or failures on other platforms.

Send me an email at hallidave at gmail.com.

== Examples

=== Get Request

Retrieve a system description.

  require 'snmp'
  
  SNMP::Manager.open(:host => 'localhost') do |manager|
      response = manager.get(["sysDescr.0", "sysName.0"])
      response.each_varbind do |vb|
          puts "#{vb.name.to_s}  #{vb.value.to_s}  #{vb.value.asn1_type}"
      end
  end

=== Set Request

Create a varbind for setting the system name.

  require 'snmp'
  include SNMP

  manager = Manager.new(:host => 'localhost')
  varbind = VarBind.new("1.3.6.1.2.1.1.5.0", OctetString.new("My System Name"))
  manager.set(varbind)
  manager.close

=== Table Walk

Walk the ifTable.

  require 'snmp'

  ifTable_columns = ["ifIndex", "ifDescr", "ifInOctets", "ifOutOctets"]
  SNMP::Manager.open(:host => 'localhost') do |manager|
      manager.walk(ifTable_columns) do |row|
          row.each { |vb| print "\t#{vb.value}" }
          puts
      end
  end

=== Get-Next Request

A more difficult way to walk the ifTable.
 
  require 'snmp'
  include SNMP

  Manager.open(:host => 'localhost') do |manager|
      ifTable = ObjectId.new("1.3.6.1.2.1.2.2")
      next_oid = ifTable
      while next_oid.subtree_of?(ifTable)
          response = manager.get_next(next_oid)
          varbind = response.varbind_list.first
          next_oid = varbind.name
          puts varbind.to_s
      end
  end

=== Get-Bulk Request

Get interface description and admin status for 10 rows of the ifTable.

  require 'snmp'
  include SNMP

  ifDescr_OID = ObjectId.new("1.3.6.1.2.1.2.2.1.2")
  ifAdminStatus_OID = ObjectId.new("1.3.6.1.2.1.2.2.1.7")
  MAX_ROWS = 10
  Manager.open(:host => 'localhost') do |manager|
      response = manager.get_bulk(0, MAX_ROWS, [ifDescr_OID, ifAdminStatus_OID])
      list = response.varbind_list
      until list.empty?
          ifDescr = list.shift
          ifAdminStatus = list.shift
          puts "#{ifDescr.value}    #{ifAdminStatus.value}"
      end
  end

=== Trap Handling

Log traps to STDOUT.

  require 'snmp'
  require 'logger'

  log = Logger.new(STDOUT)
  m = SNMP::TrapListener.new do |manager|
      manager.on_trap_default do |trap|
          log.info trap.inspect
      end
  end
  m.join
   
== License

This SNMP Library is released under the MIT License.

Copyright (c) 2004-2014 David R. Halliday

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

Cinch - The IRC Bot Building Framework
=====================================

Description
-----------

Cinch is an IRC Bot Building Framework for quickly creating IRC bots in
Ruby with minimal effort. It provides a simple interface based on plugins and
rules. It's as easy as creating a plugin, defining a rule, and watching your
profits flourish.

Cinch will do all of the hard work for you, so you can spend time creating cool
plugins and extensions to wow your internet peers.

For general support, join [#cinch](irc://irc.freenode.org/cinch) – but
please don't bring any bots.

Installation
------------

### RubyGems

You can install the latest Cinch gem using RubyGems

```
gem install cinch
```

### GitHub

Alternatively you can check out the latest code directly from Github

```
git clone http://github.com/cinchrb/cinch.git
```

Example
-------

Your typical Hello, World application in Cinch would go something like this:

```ruby
require 'cinch'

bot = Cinch::Bot.new do
  configure do |c|
    c.server = "irc.freenode.org"
    c.channels = ["#cinch-bots"]
  end

  on :message, "hello" do |m|
    m.reply "Hello, #{m.user.nick}"
  end
end

bot.start
```

More examples can be found in the `examples` directory.

Features
--------

### Documentation

Cinch provides a documented API, which is online for your viewing pleasure
[here](http://rubydoc.info/gems/cinch/frames).

### Object Oriented

Many IRC bots (and there are, **so** many) are great, but we see so little of
them take advantage of the awesome Object Oriented Interface which most Ruby
programmers will have become accustomed to and grown to love.

Well, Cinch uses this functionality to its advantage. Rather than having to
pass around a reference to a channel or a user, to another method, which then
passes it to another method (by which time you're confused about what's
going on) -- Cinch provides an OOP interface for even the simpliest of tasks,
making your code simple and easy to comprehend.

### Threaded

Unlike a lot of popular IRC frameworks, Cinch is threaded. But wait, don't let
that scare you. It's totally easy to grasp.

Each of Cinch's plugins and handlers are executed in their own personal thread.
This means the main thread can stay focused on what it does best, providing
non-blocking reading and writing to an IRC server. This will prevent your bot
from locking up when one of your plugins starts doing some intense operations.
Damn that's handy.

### Plugins

That's right folks, Cinch provides a modular based plugin system. This is a
feature many people have bugged us about for a long time. It's finally here,
and it's as awesome as you had hoped!

This system allows you to create feature packed plugins without interfering with
any of the Cinch internals. Everything in your plugin is self contained, meaning
you can share your favorite plugins among your friends and release a ton of
your own plugins for others to use

Want to see the same Hello, World application in plugin form? Sure you do!

```ruby
require 'cinch'

class Hello
  include Cinch::Plugin

  match "hello"

  def execute(m)
    m.reply "Hello, #{m.user.nick}"
  end
end

bot = Cinch::Bot.new do
  configure do |c|
    c.server = "irc.freenode.org"
    c.channels = ["#cinch-bots"]
    c.plugins.plugins = [Hello]
  end
end

bot.start
```

Note: Plugins take a default prefix of `/^!/` which means the actual match is `!hello`.

More information can be found in the {Cinch::Plugin} documentation.

### Numeric Replies

Do you know what IRC code 401 represents? How about 376? or perhaps 502?
Sure you don't (and if you do, you're as geeky as us!). Cinch doesn't expect you
to store the entire IRC RFC code set in your head, and rightfully so!

That's exactly why Cinch has a ton of constants representing these numbers
so you don't have to remember them. We're so nice.

### Pretty Output

Ever get fed up of watching those boring, frankly unreadable lines
flicker down your terminal screen whilst your bot is online? Help is
at hand! By default, Cinch will colorize all text it sends to a
terminal, meaning you get some pretty damn awesome readable coloured
text. Cinch also provides a way for your plugins to log custom
messages:

```ruby
on :message, /hello/ do |m|
  debug "Someone said hello"
end
```

Contribute
----------

Love Cinch? Love Ruby? Love helping? Of course you do! If you feel like Cinch
is missing that awesome jaw-dropping feature and you want to be the one to
make this magic happen, you can!

Please note that although we very much appreciate all of your efforts, Cinch
will not accept patches in aid of Ruby 1.8 compatibility. We have no intention
of supporting Ruby versions below 1.9.1.

Fork the project, implement your awesome feature in its own branch, and send
a pull request to one of the Cinch collaborators. We'll be more than happy
to check it out.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# descendants_tracker

[![Gem Version](https://badge.fury.io/rb/descendants_tracker.png)][gem]
[![Build Status](https://secure.travis-ci.org/dkubb/descendants_tracker.png?branch=master)][travis]
[![Dependency Status](https://gemnasium.com/dkubb/descendants_tracker.png)][gemnasium]
[![Code Climate](https://codeclimate.com/github/dkubb/descendants_tracker.png)][codeclimate]
[![Coverage Status](https://coveralls.io/repos/dkubb/descendants_tracker/badge.png?branch=master)][coveralls]

[gem]: https://rubygems.org/gems/descendants_tracker
[travis]: https://travis-ci.org/dkubb/descendants_tracker
[gemnasium]: https://gemnasium.com/dkubb/descendants_tracker
[codeclimate]: https://codeclimate.com/github/dkubb/descendants_tracker
[coveralls]: https://coveralls.io/r/dkubb/descendants_tracker

Small module to track descendants in an unobtrusive way.

## Examples

``` ruby
class Foo
  extend DescendantsTracker
end

class Bar < Foo
end

Foo.descendants # => [Bar]
```

## Credits

* Dan Kubb ([dkubb](https://github.com/dkubb))
* Piotr Solnica ([solnic](https://github.com/solnic))
* Markus Schirp ([mbj](https://github.com/mbj))

## Contributing

See [CONTRIBUTING.md](CONTRIBUTING.md) for details.

## Copyright

Copyright &copy; 2012-2013 Dan Kubb (author)
Copyright &copy; 2011-2012 Piotr Solnica (source maintainer)
Copyright &copy; 2012 Markus Schirp (packaging)

See LICENSE for details.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# redis-rb [![Build Status][travis-image]][travis-link] [![Inline docs][inchpages-image]][inchpages-link]

[travis-image]: https://secure.travis-ci.org/redis/redis-rb.png?branch=master
[travis-link]: http://travis-ci.org/redis/redis-rb
[travis-home]: http://travis-ci.org/
[inchpages-image]: http://inch-ci.org/github/redis/redis-rb.png
[inchpages-link]: http://inch-ci.org/github/redis/redis-rb

A Ruby client library for [Redis][redis-home].

[redis-home]: http://redis.io

A Ruby client that tries to match Redis' API one-to-one, while still
providing an idiomatic interface. It features thread-safety, client-side
sharding, pipelining, and an obsession for performance.

## Upgrading from 2.x to 3.0

Please refer to the [CHANGELOG][changelog-3.0.0] for a summary of the
most important changes, as well as a full list of changes.

[changelog-3.0.0]: https://github.com/redis/redis-rb/blob/master/CHANGELOG.md#300

## Getting started

As of version 2.0 this client only targets Redis version 2.0 and higher.
You can use an older version of this client if you need to interface
with a Redis instance older than 2.0, but this is no longer supported.

You can connect to Redis by instantiating the `Redis` class:

```ruby
require "redis"

redis = Redis.new
```

This assumes Redis was started with a default configuration, and is
listening on `localhost`, port 6379. If you need to connect to a remote
server or a different port, try:

```ruby
redis = Redis.new(:host => "10.0.1.1", :port => 6380, :db => 15)
```

You can also specify connection options as an URL:

```ruby
redis = Redis.new(:url => "redis://:p4ssw0rd@10.0.1.1:6380/15")
```

By default, the client will try to read the `REDIS_URL` environment variable
and use that as URL to connect to. The above statement is therefore equivalent
to setting this environment variable and calling `Redis.new` without arguments.

To connect to Redis listening on a Unix socket, try:

```ruby
redis = Redis.new(:path => "/tmp/redis.sock")
```

To connect to a password protected Redis instance, use:

```ruby
redis = Redis.new(:password => "mysecret")
```

The Redis class exports methods that are named identical to the commands
they execute. The arguments these methods accept are often identical to
the arguments specified on the [Redis website][redis-commands]. For
instance, the `SET` and `GET` commands can be called like this:

[redis-commands]: http://redis.io/commands

```ruby
redis.set("mykey", "hello world")
# => "OK"

redis.get("mykey")
# => "hello world"
```

All commands, their arguments and return values are documented, and
available on [rdoc.info][rdoc].

[rdoc]: http://rdoc.info/github/redis/redis-rb/

## Sentinel support

The client is able to perform automatic failovers by using [Redis
Sentinel](http://redis.io/topics/sentinel).  Make sure to run Redis 2.8+
if you want to use this feature.

To connect using Sentinel, use:

```ruby
SENTINELS = [{:host => "127.0.0.1", :port => 26380},
             {:host => "127.0.0.1", :port => 26381}]

redis = Redis.new(:url => "redis://mymaster", :sentinels => SENTINELS, :role => :master)
```

* The master name identifies a group of Redis instances composed of a master
and one or more slaves (`mymaster` in the example).

* It is possible to optionally provide a role. The allowed roles are `master`
and `slave`. When the role is `slave`, the client will try to connect to a
random slave of the specified master. If a role is not specified, the client
will connect to the master.

* When using the Sentinel support you need to specify a list of sentinels to
connect to. The list does not need to enumerate all your Sentinel instances,
but a few so that if one is down the client will try the next one. The client
is able to remember the last Sentinel that was able to reply correctly and will
use it for the next requests.

## Storing objects

Redis only stores strings as values. If you want to store an object, you
can use a serialization mechanism such as JSON:

```ruby
require "json"

redis.set "foo", [1, 2, 3].to_json
# => OK

JSON.parse(redis.get("foo"))
# => [1, 2, 3]
```

## Pipelining

When multiple commands are executed sequentially, but are not dependent,
the calls can be *pipelined*. This means that the client doesn't wait
for reply of the first command before sending the next command. The
advantage is that multiple commands are sent at once, resulting in
faster overall execution.

The client can be instructed to pipeline commands by using the
`#pipelined` method. After the block is executed, the client sends all
commands to Redis and gathers their replies. These replies are returned
by the `#pipelined` method.

```ruby
redis.pipelined do
  redis.set "foo", "bar"
  redis.incr "baz"
end
# => ["OK", 1]
```

### Executing commands atomically

You can use `MULTI/EXEC` to run a number of commands in an atomic
fashion. This is similar to executing a pipeline, but the commands are
preceded by a call to `MULTI`, and followed by a call to `EXEC`. Like
the regular pipeline, the replies to the commands are returned by the
`#multi` method.

```ruby
redis.multi do
  redis.set "foo", "bar"
  redis.incr "baz"
end
# => ["OK", 1]
```

### Futures

Replies to commands in a pipeline can be accessed via the *futures* they
emit (since redis-rb 3.0). All calls inside a pipeline block return a
`Future` object, which responds to the `#value` method. When the
pipeline has successfully executed, all futures are assigned their
respective replies and can be used.

```ruby
redis.pipelined do
  @set = redis.set "foo", "bar"
  @incr = redis.incr "baz"
end

@set.value
# => "OK"

@incr.value
# => 1
```

## Error Handling

In general, if something goes wrong you'll get an exception. For example, if
it can't connect to the server a `Redis::CannotConnectError` error will be raised.

```ruby
begin
  redis.ping
rescue Exception => e
  e.inspect
# => #<Redis::CannotConnectError: Timed out connecting to Redis on 10.0.1.1:6380>

  e.message
# => Timed out connecting to Redis on 10.0.1.1:6380
end
```

See lib/redis/errors.rb for information about what exceptions are possible.


## Expert-Mode Options

 - `inherit_socket: true`: disable safety check that prevents a forked child
   from sharing a socket with its parent; this is potentially useful in order to mitigate connection churn when:
    - many short-lived forked children of one process need to talk
      to redis, AND
    - your own code prevents the parent process from using the redis
      connection while a child is alive

   Improper use of `inherit_socket` will result in corrupted and/or incorrect
   responses.

## Alternate drivers

By default, redis-rb uses Ruby's socket library to talk with Redis.
To use an alternative connection driver it should be specified as option
when instantiating the client object. These instructions are only valid
for **redis-rb 3.0**. For instructions on how to use alternate drivers from
**redis-rb 2.2**, please refer to an [older README][readme-2.2.2].

[readme-2.2.2]: https://github.com/redis/redis-rb/blob/v2.2.2/README.md

### hiredis

The hiredis driver uses the connection facility of hiredis-rb. In turn,
hiredis-rb is a binding to the official hiredis client library. It
optimizes for speed, at the cost of portability. Because it is a C
extension, JRuby is not supported (by default).

It is best to use hiredis when you have large replies (for example:
`LRANGE`, `SMEMBERS`, `ZRANGE`, etc.) and/or use big pipelines.

In your Gemfile, include hiredis:

```ruby
gem "redis", "~> 3.0.1"
gem "hiredis", "~> 0.4.5"
```

When instantiating the client object, specify hiredis:

```ruby
redis = Redis.new(:driver => :hiredis)
```

### synchrony

The synchrony driver adds support for [em-synchrony][em-synchrony].
This makes redis-rb work with EventMachine's asynchronous I/O, while not
changing the exposed API. The hiredis gem needs to be available as
well, because the synchrony driver uses hiredis for parsing the Redis
protocol.

[em-synchrony]: https://github.com/igrigorik/em-synchrony

In your Gemfile, include em-synchrony and hiredis:

```ruby
gem "redis", "~> 3.0.1"
gem "hiredis", "~> 0.4.5"
gem "em-synchrony"
```

When instantiating the client object, specify synchrony:

```ruby
redis = Redis.new(:driver => :synchrony)
```

## Testing

This library is tested using [Travis][travis-home], where it is tested
against the following interpreters and drivers:

* MRI 1.8.7 (drivers: ruby, hiredis)
* MRI 1.9.2 (drivers: ruby, hiredis, synchrony)
* MRI 1.9.3 (drivers: ruby, hiredis, synchrony)
* MRI 2.0.0 (drivers: ruby, hiredis, synchrony)
* JRuby 1.7 (1.8 mode) (drivers: ruby)
* JRuby 1.7 (1.9 mode) (drivers: ruby)

## Contributors

(ordered chronologically with more than 5 commits, see `git shortlog -sn` for
all contributors)

* Ezra Zygmuntowicz
* Taylor Weibley
* Matthew Clark
* Brian McKinney
* Luca Guidi
* Salvatore Sanfillipo
* Chris Wanstrath
* Damian Janowski
* Michel Martens
* Nick Quaranto
* Pieter Noordhuis
* Ilya Grigorik

## Contributing

[Fork the project](https://github.com/redis/redis-rb) and send pull
requests. You can also ask for help at `#redis-rb` on Freenode.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.

LICENSE applicable to this library:

Apache License 2.0 see http://www.apache.org/licenses/LICENSE-2.0

### JrJackson:

a jruby library wrapping the JAVA Jackson jars`

__NOTE:__ Smile support has been temporarily dropped

The code has been refactored to use almost all Java.

There is now a MultiJson adapter added for JrJackson

***

#### NEWS

11th May 2014 - Added to_time method call for Ruby object serialization

26th October 2013 - Added support to serialize arbitary (non JSON datatypes)
ruby objects.  Normally the toJava internal method is called, but additionally
to_h, to_hash, to_a and finally to_json are tried.  Be aware that the to_json
method might invoke a new selialization session and impact performance. 

***

#### API

```
JrJackson::Json.load(string, options) -> hash like object
      aliased as parse
```
By default the load method will return Ruby objects (Hashes have string keys).
The options hash respects three symbol keys

+ :symbolize_keys

  Will return symbol keys in hashes

+ :raw

  Will return JRuby wrapped java objects that quack like ruby objects
  This is the fastest option

+ :use_bigdecimal

  Will return BigDecimal objects instead of Float
  If used with the :raw option you will get Java::JavaMath::BigDecimal objects
  otherwise they are Ruby BigDecimal

```
JrJackson::Json.dump(obj) -> json string
      aliased as generate
```
The dump method expects that the values of hashes or arrays are JSON data types,
the only exception to this is Ruby Symbol as values, they are converted to java strings
during serialization. __NOTE:__ All other objects should be converted to JSON data types before
serialization. See the wiki for more on this.

***

#### Internals

There are two Ruby sub modules of the JrJackson module

```JrJackson::Json```, this is the general external facade used by MultiJson, and is pure Ruby.

```JrJackson::Raw```, this is used by the Json module, it is defined in Java with annotations
exposing it as a Ruby module with module methods.

***

#### Benchmarks

Credit to Chuck Remes for the benchmark and initial
investigation when the jruby, json gem and the jackson
libraries were young.

I compared Json (java) 1.8, Gson 0.6.1 and jackson 2.2.3 on jruby 1.7.5 and OpenJDK 64-Bit Server VM 1.7.0_25-b30
All the benchmarks were run separately. A 727.9KB string of random json data is read from a file and handled 250 times, thereby attempting to balance invocation and parsing benchmarking.

```
generation/serialize

                                               user     system      total         real
json mri generate: 250                        12.02       0.00      12.02     ( 12.022)
oj mri generate: 250                           7.18       0.00       7.18     (  7.183)
json java generate: 250                        7.83       0.01       7.84     (  7.289)
gson generate: 250                             5.04       0.00       5.04     (  4.995)
jackson generate: 250                          4.94       0.08       5.02     (  4.811)
jackson generate: 250                          4.85       0.04       4.89     (  4.758)


parsing/deserialize - after jrjackson parsing profiling

                                               user     system      total         real
json mri parse: 250                            8.35       0.02       8.37     (  8.366)
oj mri parse: 250                              6.10       0.13       6.23     (  7.527)
      
gson parse: 250                               12.02       0.02      12.04     ( 11.774)
json java parse: 250                          10.35       0.01      10.36     ( 10.204)
jackson parse string keys: 250                 5.60       0.00       5.60     (  5.356)
jackson parse string + bigdecimal: 250         5.14       0.01       5.15     (  4.946)
jackson parse symbol keys: 250                 4.16       0.01       4.17     (  3.989)
jackson parse symbol + bigdecimal: 250         3.90       0.03       3.93     (  3.597)
jackson parse raw: 250                         3.08       0.01       3.09     (  2.924)
jackson parse raw + bigdecimal: 250            2.70       0.06       2.76     (  2.493)

```
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.equalizer
=========

Module to define equality, equivalence and inspection methods

[![Gem Version](http://img.shields.io/gem/v/equalizer.svg)][gem]
[![Build Status](http://img.shields.io/travis/dkubb/equalizer.svg)][travis]
[![Dependency Status](http://img.shields.io/gemnasium/dkubb/equalizer.svg)][gemnasium]
[![Code Climate](http://img.shields.io/codeclimate/github/dkubb/equalizer.svg)][codeclimate]
[![Coverage Status](http://img.shields.io/coveralls/dkubb/equalizer.svg)][coveralls]

[gem]: https://rubygems.org/gems/equalizer
[travis]: https://travis-ci.org/dkubb/equalizer
[gemnasium]: https://gemnasium.com/dkubb/equalizer
[codeclimate]: https://codeclimate.com/github/dkubb/equalizer
[coveralls]: https://coveralls.io/r/dkubb/equalizer

Examples
--------

``` ruby
class GeoLocation
  include Equalizer.new(:latitude, :longitude)

  attr_reader :latitude, :longitude

  def initialize(latitude, longitude)
    @latitude, @longitude = latitude, longitude
  end
end

point_a = GeoLocation.new(1, 2)
point_b = GeoLocation.new(1, 2)
point_c = GeoLocation.new(2, 2)

point_a.inspect    # => "#<GeoLocation latitude=1 longitude=2>"

point_a == point_b           # => true
point_a.hash == point_b.hash # => true
point_a.eql?(point_b)        # => true
point_a.equal?(point_b)      # => false

point_a == point_c           # => false
point_a.hash == point_c.hash # => false
point_a.eql?(point_c)        # => false
point_a.equal?(point_c)      # => false
```

Supported Ruby Versions
-----------------------

This library aims to support and is [tested against][travis] the following Ruby
implementations:

* Ruby 1.8.7
* Ruby 1.9.3
* Ruby 2.0.0
* Ruby 2.1
* Ruby 2.2
* [JRuby][]
* [Rubinius][]
* [Ruby Enterprise Edition][ree]

[jruby]: http://jruby.org/
[rubinius]: http://rubini.us/
[ree]: http://www.rubyenterpriseedition.com/

If something doesn't work on one of these versions, it's a bug.

This library may inadvertently work (or seem to work) on other Ruby versions or
implementations, however support will only be provided for the implementations
listed above.

If you would like this library to support another Ruby version or
implementation, you may volunteer to be a maintainer. Being a maintainer
entails making sure all tests run and pass on that implementation. When
something breaks on your implementation, you will be responsible for providing
patches in a timely fashion. If critical issues for a particular implementation
exist at the time of a major release, support for that Ruby version may be
dropped.

Credits
-------

* Dan Kubb ([dkubb](https://github.com/dkubb))
* Piotr Solnica ([solnic](https://github.com/solnic))
* Markus Schirp ([mbj](https://github.com/mbj))
* Erik Michaels-Ober ([sferik](https://github.com/sferik))

Contributing
-------------

See [CONTRIBUTING.md](CONTRIBUTING.md) for details.

Copyright
---------

Copyright &copy; 2009-2013 Dan Kubb. See LICENSE for details.
# Elasticsearch

The `elasticsearch` library provides a Ruby client and API for [Elasticsearch](http://elasticsearch.org).

Features overview:

* Pluggable logging and tracing
* Plugabble connection selection strategies (round-robin, random, custom)
* Pluggable transport implementation, customizable and extendable
* Pluggable serializer implementation
* Request retries and dead connections handling
* Node reloading (based on cluster state) on errors or on demand
* Consistent API support for the whole Elasticsearch API
* Extensive documentation and examples
* Emphasis on modularity and extendability of both the client and API libraries

(For integration with Ruby models and Rails applications,
see the <https://github.com/elasticsearch/elasticsearch-rails> project.)

## Compatibility

The library is compatible with Ruby 1.8.7 and higher.

The library is compatible with Elasticsearch 0.90 and 1.0 -- you have to install and use a matching version, though.

The 1.x versions and the master branch are compatible with **Elasticsearch 1.0** API.

To use the **Elasticsearch 0.90** API, install the **0.4.x** gem version or use the corresponding
[`0.4`](https://github.com/elasticsearch/elasticsearch-ruby/tree/0.4) branch.

## Installation

Install the package from [Rubygems](https://rubygems.org):

    gem install elasticsearch

To use an unreleased version, either add it to your `Gemfile` for [Bundler](http://gembundler.com):

    gem 'elasticsearch', git: 'git://github.com/elasticsearch/elasticsearch-ruby.git'

or install it from a source code checkout:

    git clone https://github.com/elasticsearch/elasticsearch-ruby.git
    cd elasticsearch-ruby/elasticsearch
    bundle install
    rake install

## Usage

This library is a wrapper for two separate libraries:

* [`elasticsearch-transport`](https://github.com/elasticsearch/elasticsearch-ruby/tree/master/elasticsearch-transport),
  which provides a low-level Ruby client for connecting to an [Elasticsearch](http://elasticsearch.org) cluster
* [`elasticsearch-api`](https://github.com/elasticsearch/elasticsearch-ruby/tree/master/elasticsearch-api),
  which provides a Ruby API for the Elasticsearch RESTful API

Install the `elasticsearch` package and use the API directly:

```ruby
require 'elasticsearch'

client = Elasticsearch::Client.new log: true

client.cluster.health

client.transport.reload_connections!

client.search q: 'test'

# etc.
```

Please refer to the specific library documentation for details:

* **Transport**:
   [[README]](https://github.com/elasticsearch/elasticsearch-ruby/blob/master/elasticsearch-transport/README.md)
   [[Documentation]](http://rubydoc.info/gems/elasticsearch-transport/file/README.markdown)

* **API**:
   [[README]](https://github.com/elasticsearch/elasticsearch-ruby/blob/master/elasticsearch-api/README.md)
   [[Documentation]](http://rubydoc.info/gems/elasticsearch-api/file/README.markdown)

## License

This software is licensed under the Apache 2 license, quoted below.

    Copyright (c) 2013 Elasticsearch <http://www.elasticsearch.org>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# AWS SDK for Ruby [![Build Status](https://travis-ci.org/aws/aws-sdk-ruby.png?branch=master)](https://travis-ci.org/aws/aws-sdk-ruby)

The official AWS SDK for Ruby.

## Installation

Version 1 of the AWS SDK for Ruby is available on rubygems.org as two gems:

* `aws-sdk-v1`
* `aws-sdk`

This project uses [semantic versioning](http://semver.org/). If you are using the
`aws-sdk` gem, we strongly recommend you specify a version constraint in
your Gemfile. Version 2 of the Ruby SDK will not be backwards compatible
with version 1.

    # version constraint
    gem 'aws-sdk', '< 2'

    # or use the v1 gem
    gem 'aws-sdk-v1'

If you use the `aws-sdk-v1` gem, you may also load the v2 Ruby SDK in the
same process; The v2 Ruby SDK uses a different namespace, making this possible.

    # when the v2 SDK ships, you will be able to do the following
    gem 'aws-sdk', '~> 2.0'
    gem 'aws-sdk-v1'

If you are currently using v1 of `aws-sdk` and you update to `aws-sdk-v1`, you
may need to change how your require the Ruby SDK:

    require 'aws-sdk-v1' # not 'aws-sdk'

If you are using a version of Ruby older than 1.9, you may encounter problems with Nokogiri.
The authors dropped support for Ruby 1.8.x in Nokogiri 1.6. To use aws-sdk, you'll also have
to install or specify a version of Nokogiri prior to 1.6, like this:

    gem 'nokogiri', '~> 1.5.0'

## Basic Configuration

You need to provide your AWS security credentials and choose a default region.

```
AWS.config(access_key_id: '...', secret_access_key: '...', region: 'us-west-2')
```

You can also specify these values via `ENV`:

    export AWS_ACCESS_KEY_ID='...'
    export AWS_SECRET_ACCESS_KEY='...'
    export AWS_REGION='us-west-2'

## Basic Usage

Each service provides a service interface and a client.

```
ec2 = AWS.ec2 #=> AWS::EC2
ec2.client #=> AWS::EC2::Client
```

The client provides one method for each API operation.  The client methods
accept a hash of request params and return a response with a hash of
response data. The service interfaces provide a higher level abstration built using the client.

**Example: list instance tags using a client**

```
resp = ec2.client.describe_tags(filters: [{ name: "resource-id", values: ["i-12345678"] }])
resp[:tag_set].first
#=> {:resource_id=>"i-12345678", :resource_type=>"instance", :key=>"role", :value=>"web"}
```

**Example: list instance tags using the AWS::EC2 higher level interface**

```
ec2.instances['i-12345678'].tags.to_h
#=> {"role"=>"web"}
```

See the [API Documentation](http://docs.aws.amazon.com/AWSRubySDK/latest/frames.html) for more examples.

## Testing

All HTTP requests to live services can be globally mocked (e.g. from within the `spec_helper.rb` file):

```
AWS.stub!
```

## Links of Interest

* [API Documentation](http://docs.aws.amazon.com/AWSRubySDK/latest/frames.html)
* [Release Notes](http://aws.amazon.com/releasenotes/Ruby)
* [Issues](http://github.com/aws/aws-sdk-ruby/issues)
* [Forums](https://forums.aws.amazon.com/forum.jspa?forumID=125)
* [License](http://aws.amazon.com/apache2.0/)

## Supported Services

The SDK currently supports the following services:

  <table class="supported-services" border="1">
    <thead>
      <th>Class</th>
      <th>API Version</th>
      <th>AWS Service Name</th>
    </thead>
    <tbody>
      <tr>
      <td>AWS::AutoScaling</td>
      <td>2011-01-01</td>
      <td>Auto Scaling</td>
    </tr>
    <tr>
      <td>AWS::CloudFormation</td>
      <td>2010-05-15</td>
      <td>AWS CloudFormation</td>
    </tr>
    <tr>
      <td rowspan="7">AWS::CloudFront</td>
      <td>2013-05-12</td>
      <td rowspan="7">Amazon CloudFront</td>
    </tr>
    <tr>
      <td>2013-08-26</td>
    </tr>
    <tr>
      <td>2013-09-27</td>
    </tr>
    <tr>
      <td>2013-11-11</td>
    </tr>
    <tr>
      <td>2013-11-22</td>
    </tr>
    <tr>
      <td>2014-01-31</td>
    </tr>
    <tr>
      <td>2014-05-31</td>
    </tr>
    <tr>
      <td rowspan="2">AWS::CloudSearch</td>
      <td>2011-02-01</td>
      <td rowspan="2">Amazon CloudSearch</td>
    </tr>
    <tr>
      <td>2013-01-01</td>
    </tr>
    <tr>
      <td>AWS::CloudTrail</td>
      <td>2013-11-01</td>
      <td>AWS CloudTrail</td>
    </tr>
    <tr>
      <td>AWS::CloudWatch</td>
      <td>2010-08-01</td>
      <td>Amazon CloudWatch</td>
    </tr>
    <tr>
      <td>AWS::DataPipeline</td>
      <td>2012-10-29</td>
      <td>AWS Data Pipeline</td>
    </tr>
    <tr>
      <td>AWS::DirectConnect</td>
      <td>2012-10-25</td>
      <td>AWS Direct Connect</td>
    </tr>
    <tr>
      <td rowspan="2">AWS::DynamoDB</td>
      <td>2011-12-05</td>
      <td rowspan="2">Amazon DynamoDB</td>
    </tr>
    <tr>
      <td>2012-08-10</td>
    </tr>
    <tr>
      <td rowspan="5">AWS::EC2</td>
      <td>2013-08-15</td>
      <td rowspan="5">Amazon Elastic Compute Cloud</td>
    </tr>
    <tr>
      <td>2013-10-01</td>
    </tr>
    <tr>
      <td>2013-10-15</td>
    </tr>
    <tr>
      <td>2014-02-01</td>
    </tr>
    <tr>
      <td>2014-05-01</td>
    </tr>
    <tr>
      <td rowspan="3">AWS::ElastiCache</td>
      <td>2013-06-15</td>
      <td rowspan="3">Amazon ElastiCache</td>
    </tr>
    <tr>
      <td>2014-03-24</td>
    </tr>
    <tr>
      <td>2014-07-15</td>
    </tr>
    <tr>
      <td>AWS::ElasticBeanstalk</td>
      <td>2010-12-01</td>
      <td>AWS Elastic Beanstalk</td>
    </tr>
    <tr>
      <td>AWS::ElasticTranscoder</td>
      <td>2012-09-25</td>
      <td>Amazon Elastic Transcoder</td>
    </tr>
    <tr>
      <td>AWS::ELB</td>
      <td>2012-06-01</td>
      <td>Elastic Load Balancing</td>
    </tr>
    <tr>
      <td>AWS::EMR</td>
      <td>2009-03-31</td>
      <td>Amazon Elastic MapReduce</td>
    </tr>
    <tr>
      <td>AWS::Glacier</td>
      <td>2012-06-01</td>
      <td>Amazon Glacier</td>
    </tr>
    <tr>
      <td>AWS::IAM</td>
      <td>2010-05-08</td>
      <td>AWS Identity and Access Management</td>
    </tr>
    <tr>
      <td>AWS::ImportExport</td>
      <td>2010-06-01</td>
      <td>AWS Import/Export</td>
    </tr>
    <tr>
      <td>AWS::Kinesis</td>
      <td>2013-12-02</td>
      <td>Amazon Kinesis</td>
    </tr>
    <tr>
      <td>AWS::OpsWorks</td>
      <td>2013-02-18</td>
      <td>AWS OpsWorks</td>
    </tr>
    <tr>
      <td rowspan="2">AWS::RDS</td>
      <td>2013-05-15</td>
      <td rowspan="2">Amazon Relational Database Service (Beta)</td>
    </tr>
    <tr>
      <td>2013-09-09</td>
    </tr>
    <tr>
      <td>AWS::Redshift</td>
      <td>2012-12-01</td>
      <td>Amazon Redshift</td>
    </tr>
    <tr>
      <td rowspan="2">AWS::Route53</td>
      <td>2012-12-12</td>
      <td rowspan="2">Amazon Route 53</td>
    </tr>
    <tr>
      <td>2013-04-01</td>
    </tr>
    <tr>
      <td>AWS::S3</td>
      <td>2006-03-01</td>
      <td>Amazon Simple Storage Service</td>
    </tr>
    <tr>
      <td>AWS::SimpleDB</td>
      <td>2009-04-15</td>
      <td>Amazon SimpleDB</td>
    </tr>
    <tr>
      <td>AWS::SimpleEmailService</td>
      <td>2010-12-01</td>
      <td>Amazon Simple E-mail Service</td>
    </tr>
    <tr>
      <td>AWS::SimpleWorkflow</td>
      <td>2012-01-25</td>
      <td>Amazon Simple Workflow Service</td>
    </tr>
    <tr>
      <td>AWS::SNS</td>
      <td>2010-03-31</td>
      <td>Amazon Simple Notifications Service</td>
    </tr>
    <tr>
      <td>AWS::SQS</td>
      <td>2012-11-05</td>
      <td>Amazon Simple Queue Service</td>
    </tr>
    <tr>
      <td rowspan="2">AWS::StorageGateway</td>
      <td>2012-06-30</td>
      <td rowspan="2">AWS Storage Gateway</td>
    </tr>
    <tr>
      <td>2013-06-30</td>
    </tr>
    <tr>
      <td>AWS::STS</td>
      <td>2011-06-15</td>
      <td>AWS Security Token Service</td>
    </tr>
    <tr>
      <td>AWS::Support</td>
      <td>2013-04-15</td>
      <td>AWS Support</td>
    </tr>
    </tbody>
  </table>

## License

This SDK is distributed under the
[Apache License, Version 2.0](http://www.apache.org/licenses/LICENSE-2.0).

```no-highlight
Copyright 2012. Amazon Web Services, Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```
# Sinatra

*Wichtig: Dieses Dokument ist eine Übersetzung aus dem Englischen und unter
Umständen nicht auf dem aktuellen Stand (aktuell Sinatra 1.4.5).*

Sinatra ist eine
[DSL](http://de.wikipedia.org/wiki/Domänenspezifische_Sprache), die das
schnelle Erstellen von Webanwendungen in Ruby mit minimalem Aufwand
ermöglicht:

Sinatra via `rubygems` installieren:

```shell
gem install sinatra
```

Eine Datei mit dem Namen `myapp.rb` erstellen:

```ruby
require 'sinatra'
get '/' do
  'Hallo Welt!'
end
```

und im gleichen Verzeichnis ausführen:

```shell
ruby myapp.rb
```

Die Seite kann nun unter [http://localhost:4567](http://localhost:4567)
aufgerufen werden.

## Inhalt

* [Sinatra](#sinatra)
    * [Routen](#routen)
        * [Bedingungen](#bedingungen)
        * [Rückgabewerte](#rckgabewerte)
        * [Eigene Routen-Muster](#eigene-routen-muster)
    * [Statische Dateien](#statische-dateien)
    * [Views/Templates](#viewstemplates)
        * [Direkte Templates](#direkte-templates)
        * [Verfügbare Templatesprachen](#verfgbare-templatesprachen)
            * [Haml Templates](#haml-templates)
            * [Erb Templates](#erb-templates)
            * [Builder Templates](#builder-templates)
            * [Nokogiri Templates](#nokogiri-templates)
            * [Sass Templates](#sass-templates)
            * [SCSS Templates](#scss-templates)
            * [Less Templates](#less-templates)
            * [Liquid Templates](#liquid-templates)
            * [Markdown Templates](#markdown-templates)
            * [Textile Templates](#textile-templates)
            * [RDoc Templates](#rdoc-templates)
            * [AsciiDoc Templates](#asciidoc-templates)
            * [Radius Templates](#radius-templates)
            * [Markaby Templates](#markaby-templates)
            * [RABL Templates](#rabl-templates)
            * [Slim Templates](#slim-templates)
            * [Creole Templates](#creole-templates)
            * [MediaWiki Templates](#mediawiki-templates)
            * [CoffeeScript Templates](#coffeescript-templates)
            * [Stylus Templates](#stylus-templates)
            * [Yajl Templates](#yajl-templates)
            * [WLang Templates](#wlang-templates)
        * [Auf Variablen in Templates zugreifen](#auf-variablen-in-templates-zugreifen)
        * [Templates mit `yield` und verschachtelte Layouts](#templates-mit-yield-und-verschachtelte-layouts)
        * [Inline-Templates](#inline-templates)
        * [Benannte Templates](#benannte-templates)
        * [Dateiendungen zuordnen](#dateiendungen-zuordnen)
        * [Eine eigene Template-Engine hinzufügen](#eine-eigene-template-engine-hinzufgen)
        * [Eigene Methoden zum Aufsuchen von Templates verwenden](#eigene-methoden-zum-aufsuchen-von-templates-verwenden)
    * [Filter](#filter)
    * [Helfer](#helfer)
        * [Sessions verwenden](#sessions-verwenden)
        * [Anhalten](#anhalten)
        * [Weiterspringen](#weiterspringen)
        * [Eine andere Route ansteuern](#eine-andere-route-ansteuern)
        * [Body, Status-Code und Header setzen](#body-status-code-und-header-setzen)
        * [Response-Streams](#response-streams)
        * [Logger](#logger)
        * [Mime-Types](#mime-types)
        * [URLs generieren](#urls-generieren)
        * [Browser-Umleitung](#browser-umleitung)
        * [Cache einsetzen](#cache-einsetzen)
        * [Dateien versenden](#dateien-versenden)
        * [Das Request-Objekt](#das-request-objekt)
        * [Anhänge](#anhnge)
        * [Umgang mit Datum und Zeit](#umgang-mit-datum-und-zeit)
        * [Nachschlagen von Template-Dateien](#nachschlagen-von-template-dateien)
        * [Konfiguration](#konfiguration)
            * [Einstellung des Angriffsschutzes](#einstellung-des-angriffsschutzes)
            * [Mögliche Einstellungen](#mgliche-einstellungen)
    * [Umgebungen](#umgebungen)
    * [Fehlerbehandlung](#fehlerbehandlung)
        * [Nicht gefunden](#nicht-gefunden)
        * [Fehler](#fehler)
    * [Rack-Middleware](#rack-middleware)
    * [Testen](#testen)
    * [Sinatra::Base - Middleware, Bibliotheken und modulare Anwendungen](#sinatrabase---middleware-bibliotheken-und-modulare-anwendungen)
        * [Modularer vs. klassischer Stil](#modularer-vs-klassischer-stil)
        * [Eine modulare Applikation bereitstellen](#eine-modulare-applikation-bereitstellen)
        * [Eine klassische Anwendung mit einer config.ru verwenden](#eine-klassische-anwendung-mit-einer-configru-verwenden)
        * [Wann sollte eine config.ru-Datei verwendet werden?](#wann-sollte-eine-configru-datei-verwendet-werden)
        * [Sinatra als Middleware nutzen](#sinatra-als-middleware-nutzen)
        * [Dynamische Applikationserstellung](#dynamische-applikationserstellung)
    * [Geltungsbereich und Bindung](#geltungsbereich-und-bindung)
        * [Anwendungs- oder Klassen-Scope](#anwendungs--oder-klassen-scope)
        * [Anfrage- oder Instanz-Scope](#anfrage--oder-instanz-scope)
        * [Delegation-Scope](#delegation-scope)
    * [Kommandozeile](#kommandozeile)
    * [Systemanforderungen](#systemanforderungen)
    * [Der neuste Stand (The Bleeding Edge)](#der-neuste-stand-the-bleeding-edge)
        * [Mit Bundler](#mit-bundler)
        * [Eigenes Repository](#eigenes-repository)
        * [Gem erstellen](#gem-erstellen)
    * [Versions-Verfahren](#versions-verfahren)
    * [Mehr](#mehr)

## Routen

In Sinatra wird eine Route durch eine HTTP-Methode und ein URL-Muster definiert.
Jeder dieser Routen wird ein Ruby-Block zugeordnet:

```ruby
get '/' do
  .. zeige etwas ..
end

post '/' do
  .. erstelle etwas ..
end

put '/' do
  .. update etwas ..
end

delete '/' do
  .. entferne etwas ..
end

options '/' do
  .. zeige, was wir können ..
end

link '/' do
  .. verbinde etwas ..
end

unlink '/' do
  .. trenne etwas ..
end
```

Die Routen werden in der Reihenfolge durchlaufen, in der sie definiert wurden.
Das erste Routen-Muster, das mit dem Request übereinstimmt, wird ausgeführt.

Die Muster der Routen können benannte Parameter beinhalten, die über den
`params`-Hash zugänglich gemacht werden:

```ruby
get '/hallo/:name' do
  # passt auf "GET /hallo/foo" und "GET /hallo/bar"
  # params['name'] ist dann 'foo' oder 'bar'
  "Hallo #{params['name']}!"
end
```

Man kann auf diese auch mit Block-Parametern zugreifen:

```ruby
get '/hallo/:name' do |n|
  # n entspricht hier params['name']
  "Hallo #{n}!"
end
```

Routen-Muster können auch mit sog. Splat- oder Wildcard-Parametern über das
`params['splat']`-Array angesprochen werden:

```ruby
get '/sag/*/zu/*' do
  # passt z.B. auf /sag/hallo/zu/welt
  params['splat'] # => ["hallo", "welt"]
end

get '/download/*.*' do
  # passt auf /download/pfad/zu/datei.xml
  params['splat'] # => ["pfad/zu/datei", "xml"]
end
```

Oder mit Block-Parametern:

```ruby
get '/download/*.*' do |pfad, endung|
  [pfad, endung] # => ["Pfad/zu/Datei", "xml"]
end
```

Routen mit regulären Ausdrücken sind auch möglich:

```ruby
get /\A\/hallo\/([\w]+)\z/ do
  "Hallo, #{params['captures'].first}!"
end
```

Und auch hier können Block-Parameter genutzt werden:

```ruby
get %r{/hallo/([\w]+)} do |c|
  "Hallo, #{c}!"
end
```

Routen-Muster können auch mit optionalen Parametern ausgestattet werden:

```ruby
get '/posts.?:format?' do
  # passt auf "GET /posts" sowie jegliche Erweiterung
  # wie "GET /posts.json", "GET /posts.xml" etc.
end
```

Routen können auch den query-Parameter verwenden:

``` ruby
get '/posts' do
  # matches "GET /posts?title=foo&author=bar"
  title = params['title']
  author = params['author']
  # uses title and author variables; query is optional to the /posts route
end
```

Anmerkung: Solange man den sog. Path Traversal Attack-Schutz nicht deaktiviert
(siehe weiter unten), kann es sein, dass der Request-Pfad noch vor dem
Abgleich mit den Routen modifiziert wird.

### Bedingungen

An Routen können eine Vielzahl von Bedingungen geknüpft werden, die erfüllt
sein müssen, damit der Block ausgeführt wird. Möglich wäre etwa eine
Einschränkung des User-Agents über die interne Bedingung `:agent`:

```ruby
get '/foo', :agent => /Songbird (\d\.\d)[\d\/]*?/ do
  "Du verwendest Songbird Version #{params['agent'][0]}"
end
```

Wird Songbird als Browser nicht verwendet, springt Sinatra zur nächsten Route:

```ruby
get '/foo' do
  # passt auf andere Browser
end
```

Andere mitgelieferte Bedingungen sind `:host_name` und `:provides`:

```ruby
get '/', :host_name => /^admin\./ do
  "Adminbereich, Zugriff verweigert!"
end

get '/', :provides => 'html' do
  haml :index
end

get '/', :provides => ['rss', 'atom', 'xml'] do
  builder :feed
end
```
`provides` durchsucht den Accept-Header der Anfrage

Eigene Bedingungen können relativ einfach hinzugefügt werden:

```ruby
set(:wahrscheinlichkeit) { |value| condition { rand <= value } }

get '/auto_gewinnen', :wahrscheinlichkeit => 0.1 do
  "Du hast gewonnen!"
end

get '/auto_gewinnen' do
  "Tut mir leid, verloren."
end
```

Bei Bedingungen, die mehrere Werte annehmen können, sollte ein Splat verwendet
werden:

```ruby
set(:auth) do |*roles|   # <- hier kommt der Splat ins Spiel
  condition do
    unless logged_in? && roles.any? {|role| current_user.in_role? role }
      redirect "/login/", 303
    end
  end
end

get "/mein/account/", :auth => [:user, :admin] do
  "Mein Account"
end

get "/nur/admin/", :auth => :admin do
  "Nur Admins dürfen hier rein!"
end
```

### Rückgabewerte

Durch den Rückgabewert eines Routen-Blocks wird mindestens der Response-Body
festgelegt, der an den HTTP-Client, bzw. die nächste Rack-Middleware,
weitergegeben wird. Im Normalfall handelt es sich hierbei, wie in den
vorangehenden Beispielen zu sehen war, um einen String. Es werden allerdings
auch andere Werte akzeptiert.

Es kann jedes gültige Objekt zurückgegeben werden, bei dem es sich entweder um
einen Rack-Rückgabewert, einen Rack-Body oder einen HTTP-Status-Code handelt:

*   Ein Array mit drei Elementen: `[Status (Fixnum), Headers (Hash),
    Response-Body (antwortet auf #each)]`.
*   Ein Array mit zwei Elementen: `[Status (Fixnum), Response-Body (antwortet
    auf #each)]`.
*   Ein Objekt, das auf `#each` antwortet und den an diese Methode übergebenen
    Block nur mit Strings als Übergabewerte aufruft.
*   Ein Fixnum, das den Status-Code festlegt.

Damit lässt sich relativ einfach Streaming implementieren:

```ruby
class Stream
  def each
    100.times { |i| yield "#{i}\n" }
  end
end

get('/') { Stream.new }
```

Ebenso kann die `stream`-Helfer-Methode (s.u.) verwendet werden, die Streaming
direkt in die Route integriert.

### Eigene Routen-Muster

Wie oben schon beschrieben, ist Sinatra von Haus aus mit Unterstützung für
String-Muster und Reguläre Ausdrücke zum Abgleichen von Routen ausgestattet.
Das muss aber noch nicht alles sein, es können ohne großen Aufwand eigene
Routen-Muster erstellt werden:

```ruby
class AllButPattern
  Match = Struct.new(:captures)

  def initialize(except)
    @except   = except
    @captures = Match.new([])
  end

  def match(str)
    @captures unless @except === str
  end
end

def all_but(pattern)
  AllButPattern.new(pattern)
end

get all_but("/index") do
  # ...
end
```

Beachte, dass das obige Beispiel etwas übertrieben wirkt. Es geht auch einfacher:

```ruby
get // do
  pass if request.path_info == "/index"
  # ...
end
```

Oder unter Verwendung eines negativen look ahead:

```ruby
get %r{^(?!/index$)} do
  # ...
end
```

## Statische Dateien

Statische Dateien werden im `./public`-Ordner erwartet. Es ist möglich,
einen anderen Ort zu definieren, indem man die `:public_folder`-Option setzt:

```ruby
set :public_folder, File.dirname(__FILE__) + '/static'
```

Zu beachten ist, dass der Ordnername `public` nicht Teil der URL ist. Die Datei
`./public/css/style.css` ist unter `http://example.com/css/style.css` zu finden.

Um den `Cache-Control`-Header mit Informationen zu versorgen, verwendet man
die `:static_cache_control`-Einstellung (s.u.).

## Views/Templates

Alle Templatesprachen verwenden ihre eigene Renderingmethode, die jeweils
einen String zurückgibt:

```ruby
get '/' do
  erb :index
end
```

Dieses Beispiel rendert `views/index.erb`.

Anstelle eines Templatenamens kann man auch direkt die Templatesprache verwenden:

```ruby
get '/' do
  code = "<%= Time.now %>"
  erb code
end
```

Templates nehmen ein zweite Argument an, den Options-Hash:

```ruby
get '/' do
  erb :index, :layout => :post
end
```

Dieses Beispiel rendert `views/index.erb` eingebettet in `views/post.erb`
(Voreinstellung ist `views/layout.erb`, sofern es vorhanden ist.)

Optionen, die Sinatra nicht versteht, werden an das Template weitergereicht:

```ruby
get '/' do
  haml :index, :format => :html5
end
```

Für alle Templates können auch Einstellungen, die für alle Routen gelten,
festgelegt werden:

```ruby
set :haml, :format => :html5

get '/' do
  haml :index
end
```

Optionen, die an die Rendermethode weitergegeben werden, überschreiben die
Einstellungen, die mit `set` festgelegt wurden.

Einstellungen:

<dl>
  <dt>locals</dt>
  <dd>Liste von lokalen Variablen, die an das Dokument weitergegeben werden.
    Praktisch für Partials:

    <tt>erb "<%= foo %>", :locals => {:foo => "bar"}</tt></dd>

  <dt>default_encoding</dt>
  <dd>Gibt die Stringkodierung an, die verwendet werden soll. Voreingestellt
    auf <tt>settings.default_encoding</tt>.</dd>

  <dt>views</dt>
  <dd>Ordner, aus dem die Templates geladen werden. Voreingestellt auf
    <tt>settings.views</tt>.</dd>

  <dt>layout</dt>
  <dd>Legt fest, ob ein Layouttemplate verwendet werden soll oder nicht
    (<tt>true</tt> oder<tt>false</tt>). Ist es ein Symbol, dann legt es fest,
    welches Template als Layout verwendet wird:

    <tt>erb :index, :layout => !request.xhr?</tt></dd>

  <dt>content_type</dt>
  <dd>Content-Typ den das Template ausgibt. Voreinstellung hängt von der
    Templatesprache ab.</dd>

  <dt>scope</dt>
  <dd>Scope, in dem das Template gerendert wird. Liegt standardmäßig innerhalb
    der App-Instanz. Wird Scope geändert, sind Instanzvariablen und
    Helfermethoden nicht verfügbar.</dd>

  <dt>layout_engine</dt>
  <dd>Legt fest, welcher Renderer für das Layout verantwortlich ist. Hilfreich
    für Sprachen, die sonst keine Templates unterstützen. Voreingestellt auf
    den Renderer, der für das Template verwendet wird:

    <tt>set :rdoc, :layout_engine => :erb</tt></dd>

  <dt>layout_options</dt>
  <dd>Besondere Einstellungen, die nur für das Rendering verwendet werden:

    <tt>set :rdoc, :layout_options => { :views => 'views/layouts' }</tt></dd>
</dl>

Sinatra geht davon aus, dass die Templates sich im `./views` Verzeichnis
befinden. Es kann jedoch ein anderer Ordner festgelegt werden:

```ruby
set :views, settings.root + '/templates'
```

Es ist zu beachten, dass immer mit Symbolen auf Templates verwiesen werden muss,
auch dann, wenn sie sich in einem Unterordner befinden:

```ruby
haml :'unterverzeichnis/template'
```

Rendering-Methoden rendern jeden String direkt.

### Direkte Templates

``` ruby
get '/' do
  haml '%div.title Hallo Welt'
end
```

Hier wird der String direkt gerendert.

### Verfügbare Templatesprachen

Einige Sprachen haben mehrere Implementierungen. Um festzulegen, welche
verwendet wird (und dann auch Thread-sicher ist), verwendet man am besten zu
Beginn ein `'require'`:

```ruby
require 'rdiscount' # oder require 'bluecloth'
get('/') { markdown :index }
```

#### Haml Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="http://haml.info/">haml</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.haml</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>haml :index, :format => :html5</tt></td>
  </tr>
</table>


#### Erb Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="http://www.kuwata-lab.com/erubis/">erubis</a> oder erb
    (Standardbibliothek von Ruby)</td>
  </tr>
  <tr>
    <td>Dateierweiterungen</td>
    <td><tt>.erb</tt>, <tt>.rhtml</tt> oder <tt>.erubis</tt> (nur Erubis)</td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>erb :index</tt></td>
  </tr>
</table>


#### Builder Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="https://github.com/jimweirich/builder">builder</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.builder</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>builder { |xml| xml.em "Hallo" }</tt></td>
  </tr>
</table>

Nimmt ebenso einen Block für Inline-Templates entgegen (siehe Beispiel).

#### Nokogiri Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="http://nokogiri.org/">nokogiri</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.nokogiri</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>nokogiri { |xml| xml.em "Hallo" }</tt></td>
  </tr>
</table>

Nimmt ebenso einen Block für Inline-Templates entgegen (siehe Beispiel).

#### Sass Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="http://sass-lang.com/">sass</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.sass</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>sass :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>


#### SCSS Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="http://sass-lang.com/">sass</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.scss</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>scss :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>


#### Less Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="http://www.lesscss.org/">less</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.less</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>less :stylesheet</tt></td>
  </tr>
</table>


#### Liquid Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="http://www.liquidmarkup.org/">liquid</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.liquid</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>liquid :index, :locals => { :key => 'Wert' }</tt></td>
  </tr>
</table>

Da man aus dem Liquid-Template heraus keine Ruby-Methoden aufrufen kann
(ausgenommen `yield`), wird man üblicherweise locals verwenden wollen, mit
denen man Variablen weitergibt.

#### Markdown Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td>Eine der folgenden Bibliotheken:
        <a href="https://github.com/rtomayko/rdiscount" title="RDiscount">RDiscount</a>,
        <a href="https://github.com/vmg/redcarpet" title="RedCarpet">RedCarpet</a>,
        <a href="http://deveiate.org/projects/BlueCloth" title="BlueCloth">BlueCloth</a>,
        <a href="http://kramdown.gettalong.org/" title="kramdown">kramdown</a> oder
        <a href="https://github.com/bhollis/maruku" title="maruku">maruku</a>
    </td>
  </tr>
  <tr>
    <td>Dateierweiterungen</td>
    <td><tt>.markdown</tt>, <tt>.mkd</tt> und <tt>.md</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>markdown :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

Da man aus den Markdown-Templates heraus keine Ruby-Methoden aufrufen und auch
keine locals verwenden kann, wird man Markdown üblicherweise in Kombination
mit anderen Renderern verwenden wollen:

```ruby
erb :overview, :locals => { :text => markdown(:einfuehrung) }
```

Beachte, dass man die `markdown`-Methode auch aus anderen Templates heraus
aufrufen kann:

```ruby
%h1 Gruß von Haml!
%p= markdown(:Grüße)
```

Da man Ruby nicht von Markdown heraus aufrufen kann, können auch Layouts nicht
in Markdown geschrieben werden. Es ist aber möglich, einen Renderer für die
Templates zu verwenden und einen anderen für das Layout, indem die
`:layout_engine`-Option verwendet wird.

#### Textile Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="http://redcloth.org/">RedCloth</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.textile</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>textile :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

Da man aus dem Textile-Template heraus keine Ruby-Methoden aufrufen und auch
keine locals verwenden kann, wird man Textile üblicherweise in Kombination mit
anderen Renderern verwenden wollen:

```ruby
erb :overview, :locals => { :text => textile(:einfuehrung) }
```

Beachte, dass man die `textile`-Methode auch aus anderen Templates heraus
aufrufen kann:

```ruby
%h1 Gruß von Haml!
%p= textile(:Grüße)
```

Da man Ruby nicht von Textile heraus aufrufen kann, können auch Layouts nicht
in Textile geschrieben werden. Es ist aber möglich, einen Renderer für die
Templates zu verwenden und einen anderen für das Layout, indem die
`:layout_engine`-Option verwendet wird.

#### RDoc Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="http://rdoc.sourceforge.net/">rdoc</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.rdoc</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>textile :README, :layout_engine => :erb</tt></td>
  </tr>
</table>

Da man aus dem RDoc-Template heraus keine Ruby-Methoden aufrufen und auch
keine locals verwenden kann, wird man RDoc üblicherweise in Kombination mit
anderen Renderern verwenden wollen:

```ruby
erb :overview, :locals => { :text => rdoc(:einfuehrung) }
```

Beachte, dass man die `rdoc`-Methode auch aus anderen Templates heraus
aufrufen kann:

```ruby
%h1 Gruß von Haml!
%p= rdoc(:Grüße)
```

Da man Ruby nicht von RDoc heraus aufrufen kann, können auch Layouts nicht in
RDoc geschrieben werden. Es ist aber möglich, einen Renderer für die Templates
zu verwenden und einen anderen für das Layout, indem die
`:layout_engine`-Option verwendet wird.

#### AsciiDoc Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="http://asciidoctor.org/" title="Asciidoctor">Asciidoctor</a></td>
  </tr>
  <tr>
    <td>Dateierweiterungen</td>
    <td><tt>.asciidoc</tt>, <tt>.adoc</tt> und <tt>.ad</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>asciidoc :README, :layout_engine => :erb</tt></td>
  </tr>
</table>

Da man aus dem AsciiDoc-Template heraus keine Ruby-Methoden aufrufen kann
(ausgenommen `yield`), wird man üblicherweise locals verwenden wollen, mit
denen man Variablen weitergibt.

#### Radius Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="https://github.com/jlong/radius">radius</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.radius</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>radius :index, :locals => { :key => 'Wert' }</tt></td>
  </tr>
</table>

Da man aus dem Radius-Template heraus keine Ruby-Methoden aufrufen kann, wird
man üblicherweise locals verwenden wollen, mit denen man Variablen weitergibt.

#### Markaby Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="http://markaby.github.com/">markaby</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.mab</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>markaby { h1 "Willkommen!" }</tt></td>
  </tr>
</table>

Nimmt ebenso einen Block für Inline-Templates entgegen (siehe Beispiel).

#### RABL Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="https://github.com/nesquena/rabl">rabl</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.rabl</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>rabl :index</tt></td>
  </tr>
</table>

#### Slim Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="http://slim-lang.com/">slim</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.slim</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>slim :index</tt></td>
  </tr>
</table>

#### Creole Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="https://github.com/minad/creole">creole</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.creole</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>creole :wiki, :layout_engine => :erb</tt></td>
  </tr>
</table>

Da man aus dem Creole-Template heraus keine Ruby-Methoden aufrufen und auch
keine locals verwenden kann, wird man Creole üblicherweise in Kombination mit
anderen Renderern verwenden wollen:

```ruby
erb :overview, :locals => { :text => creole(:einfuehrung) }
```

Beachte, dass man die `creole`-Methode auch aus anderen Templates heraus
aufrufen kann:

```ruby
%h1 Gruß von Haml!
%p= creole(:Grüße)
```

Da man Ruby nicht von Creole heraus aufrufen kann, können auch Layouts nicht in
Creole geschrieben werden. Es ist aber möglich, einen Renderer für die Templates
zu verwenden und einen anderen für das Layout, indem die `:layout_engine`-Option
verwendet wird.

#### MediaWiki Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="https://github.com/nricciar/wikicloth" title="WikiCloth">WikiCloth</a></td>
  </tr>
  <tr>
    <td>Dateierweiterungen</td>
    <td><tt>.mediawiki</tt> und <tt>.mw</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>mediawiki :wiki, :layout_engine => :erb</tt></td>
  </tr>
</table>

Da man aus dem Mediawiki-Template heraus keine Ruby-Methoden aufrufen und auch
keine locals verwenden kann, wird man Mediawiki üblicherweise in Kombination mit
anderen Renderern verwenden wollen:

``` ruby
erb :overview, :locals => { :text => mediawiki(:introduction) }
```

Beachte: Man kann die `mediawiki`-Methode auch aus anderen Templates
heraus aufrufen:

``` ruby
%h1 Grüße von Haml!
%p= mediawiki(:greetings)
```

Da man Ruby nicht von MediaWiki heraus aufrufen kann, können auch Layouts nicht
in MediaWiki geschrieben werden. Es ist aber möglich, einen Renderer für die
Templates zu verwenden und einen anderen für das Layout, indem die
`:layout_engine`-Option verwendet wird.

#### CoffeeScript Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="https://github.com/josh/ruby-coffee-script">coffee-script</a>
        und eine <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme">Möglichkeit JavaScript auszuführen</a>.
    </td>
  </tr>
    <td>Dateierweiterung</td>
    <td><tt>.coffee</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>coffee :index</tt></td>
  </tr>
</table>

#### Stylus Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td>
      <a href="https://github.com/lucasmazza/ruby-stylus" title="Ruby Stylus">
        Stylus
      </a> und eine Möglichkeit
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        JavaScript auszuführen
      </a>.
    </td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.styl</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>stylus :index</tt></td>
  </tr>
</table>

Um Stylus-Templates ausführen zu können, müssen `stylus` und `stylus/tilt`
zuerst geladen werden:

``` ruby
require 'sinatra'
require 'stylus'
require 'stylus/tilt'

get '/' do
  stylus :example
end
```

#### Yajl Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="https://github.com/brianmario/yajl-ruby" title="yajl-ruby">yajl-ruby</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.yajl</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td>
      <tt>
        yajl :index,
             :locals => { :key => 'qux' },
             :callback => 'present',
             :variable => 'resource'
      </tt>
    </td>
  </tr>
</table>

Die Template-Quelle wird als Ruby-String evaluiert. Die daraus resultierende
json Variable wird mit Hilfe von `#to_json` umgewandelt:

``` ruby
json = { :foo => 'bar' }
json[:baz] = key
```

Die `:callback` und `:variable` Optionen können mit dem gerenderten Objekt
verwendet werden:

``` javascript
var resource = {"foo":"bar","baz":"qux"};
present(resource);
```

#### WLang Templates

<table>
  <tr>
    <td>Abhängigkeit</td>
    <td><a href="https://github.com/blambeau/wlang/">wlang</a></td>
  </tr>
  <tr>
    <td>Dateierweiterung</td>
    <td><tt>.wlang</tt></td>
  </tr>
  <tr>
    <td>Beispiel</td>
    <td><tt>wlang :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

Ruby-Methoden in Wlang aufzurufen entspricht nicht den idiomatischen Vorgaben
von Wlang, es bietet sich deshalb an, `:locals` zu verwenden. Layouts, die
Wlang und `yield` verwenden, werden aber trotzdem unterstützt.

Rendert den eingebetteten Template-String.

### Auf Variablen in Templates zugreifen

Templates werden in demselben Kontext ausgeführt wie Routen. Instanzvariablen
in Routen sind auch direkt im Template verfügbar:

```ruby
get '/:id' do
  @foo = Foo.find(params['id'])
  haml '%h1= @foo.name'
end
```

Oder durch einen expliziten Hash von lokalen Variablen:

```ruby
get '/:id' do
  foo = Foo.find(params['id'])
  haml '%h1= bar.name', :locals => { :bar => foo }
end
```

Dies wird typischerweise bei Verwendung von Subtemplates (partials) in anderen
Templates eingesetzt.

### Templates mit `yield` und verschachtelte Layouts

Ein Layout ist üblicherweise ein Template, das ein `yield` aufruft. Ein solches
Template kann entweder wie oben beschrieben über die `:template` Option
verwendet werden oder mit einem Block gerendert werden:

``` ruby
erb :post, :layout => false do
  erb :index
end
```

Dieser Code entspricht weitestgehend `erb :index, :layout => :post`.

Blöcke an Render-Methoden weiterzugeben ist besonders bei verschachtelten
Layouts hilfreich:

``` ruby
erb :main_layout, :layout => false do
  erb :admin_layout do
    erb :user
  end
end
```

Der gleiche Effekt kann auch mit weniger Code erreicht werden:

``` ruby
erb :admin_layout, :layout => :main_layout do
  erb :user
end
```

Zur Zeit nehmen folgende Renderer Blöcke an: `erb`, `haml`, `liquid`, `slim `
und `wlang`.

Das gleich gilt auch für die allgemeine `render` Methode.

### Inline-Templates

Templates können auch am Ende der Datei definiert werden:

```ruby
require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.title Hallo Welt!!!!!
```

Anmerkung: Inline-Templates, die in der Datei definiert sind, die `require
'sinatra'` aufruft, werden automatisch geladen. Um andere Inline-Templates in
anderen Dateien aufzurufen, muss explizit `enable :inline_templates` verwendet
werden.

### Benannte Templates

Templates können auch mit der Top-Level `template`-Methode definiert werden:

```ruby
template :layout do
  "%html\n  =yield\n"
end

template :index do
  '%div.title Hallo Welt!'
end

get '/' do
  haml :index
end
```

Wenn ein Template mit dem Namen "layout" existiert, wird es bei jedem Aufruf
verwendet. Durch `:layout => false` kann das Ausführen verhindert werden:

```ruby
get '/' do
  haml :index, :layout => !request.xhr?
  # !request.xhr? prüft, ob es sich um einen asynchronen Request handelt.
  # wenn nicht, dann verwende ein Layout (negiert durch !)
end
```

### Dateiendungen zuordnen

Um eine Dateiendung einer Template-Engine zuzuordnen, kann `Tilt.register`
genutzt werden. Wenn etwa die Dateiendung `tt` für Textile-Templates genutzt
werden soll, lässt sich dies wie folgt bewerkstelligen:

```ruby
Tilt.register :tt, Tilt[:textile]
```

### Eine eigene Template-Engine hinzufügen

Zu allererst muss die Engine bei Tilt registriert und danach eine
Rendering-Methode erstellt werden:

```ruby
Tilt.register :mtt, MeineTolleTemplateEngine

helpers do
  def mtt(*args) render(:mtt, *args) end
end

get '/' do
  mtt :index
end
```

Dieser Code rendert `./views/application.mtt`. Siehe
[github.com/rtomayko/tilt](https://github.com/rtomayko/tilt), um mehr über
Tilt zu erfahren.

### Eigene Methoden zum Aufsuchen von Templates verwenden

Um einen eigenen Mechanismus zum Aufsuchen von Templates zu
implementieren, muss `#find_template` definiert werden:

``` ruby
configure do
  set :views [ './views/a', './views/b' ]
end

def find_template(views, name, engine, &block)
  Array(views).each do |v|
    super(v, name, engine, &block)
  end
end
```

## Filter

Before-Filter werden vor jedem Request in demselben Kontext, wie danach die
Routen, ausgeführt. So können etwa Request und Antwort geändert werden.
Gesetzte Instanzvariablen in Filtern können in Routen und Templates verwendet
werden:

```ruby
before do
  @note = 'Hi!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @note #=> 'Hi!'
  params['splat'] #=> 'bar/baz'
end
```

After-Filter werden nach jedem Request in demselben Kontext ausgeführt und
können ebenfalls Request und Antwort ändern. In Before-Filtern gesetzte
Instanzvariablen können in After-Filtern verwendet werden:

```ruby
after do
  puts response.status
end
```

Filter können optional auch mit einem Muster ausgestattet werden, das auf den
Request-Pfad passen muss, damit der Filter ausgeführt wird:

```ruby
before '/protected/*' do
  authenticate!
end

after '/create/:slug' do |slug|
  session[:last_slug] = slug
end
```

Ähnlich wie Routen können Filter auch mit weiteren Bedingungen eingeschränkt
werden:

```ruby
before :agent => /Songbird/ do
  # ...
end

after '/blog/*', :host_name => 'example.com' do
  # ...
end
```

## Helfer

Durch die Top-Level `helpers`-Methode werden sogenannte Helfer-Methoden
definiert, die in Routen und Templates verwendet werden können:

```ruby
helpers do
  def bar(name)
    "#{name}bar"
  end
end

get '/:name' do
  bar(params['name'])
end
```

### Sessions verwenden
Sessions werden verwendet, um Zustände zwischen den Requests zu speichern. Sind
sie aktiviert, kann ein Session-Hash je Benutzer-Session verwendet werden:

```ruby
enable :sessions

get '/' do
  "value = " << session[:value].inspect
end

get '/:value' do
  session[:value] = params['value']
end
```

Beachte, dass `enable :sessions` alle Daten in einem Cookie speichert. Unter
Umständen kann dies negative Effekte haben, z.B. verursachen viele Daten
höheren, teilweise überflüssigen Traffic. Um das zu vermeiden, kann eine Rack-
Session-Middleware verwendet werden. Dabei wird auf `enable :sessions`
verzichtet und die Middleware wie üblich im Programm eingebunden:

```ruby
use Rack::Session::Pool, :expire_after => 2592000

get '/' do
  "value = " << session[:value].inspect
end

get '/:value' do
  session[:value] = params['value']
end
```

Um die Sicherheit zu erhöhen, werden Cookies, die Session-Daten führen, mit
einem sogenannten Session-Secret signiert. Da sich dieses Geheimwort bei jedem
Neustart der Applikation automatisch ändert, ist es sinnvoll, ein eigenes zu
wählen, damit sich alle Instanzen der Applikation dasselbe Session-Secret
teilen:

```ruby
set :session_secret, 'super_geheimes_Gegeimnis'
```

Zur weiteren Konfiguration kann man einen Hash mit Optionen in den `sessions`
Einstellungen ablegen.

```ruby
set :sessions, :domain => 'foo.com'
```

Um eine Session mit anderen Apps und zwischen verschiedenen Subdomains
von foo.com zu teilen, wird ein *.* der Domain vorangestellt:

``` ruby
set :sessions, :domain => '.foo,com'
```

### Anhalten

Zum sofortigen Stoppen eines Request in einem Filter oder einer Route:

```ruby
halt
```

Der Status kann beim Stoppen mit angegeben werden:

```ruby
halt 410
```

Oder auch den Response-Body:

```ruby
halt 'Hier steht der Body'
```

Oder beides:

```ruby
halt 401, 'verschwinde!'
```

Sogar mit Headern:

```ruby
halt 402, {'Content-Type' => 'text/plain'}, 'Rache'
```

Natürlich ist es auch möglich, ein Template mit `halt` zu verwenden:

```ruby
halt erb(:error)
```

### Weiterspringen

Eine Route kann mittels `pass` zu der nächsten passenden Route springen:

```ruby
get '/raten/:wer' do
  pass unless params['wer'] == 'Frank'
  'Du hast mich!'
end

get '/raten/*' do
  'Du hast mich nicht!'
end
```

Der Block wird sofort verlassen und es wird nach der nächsten treffenden Route
gesucht. Ein 404-Fehler wird zurückgegeben, wenn kein treffendes Routen-Muster
gefunden wird.

### Eine andere Route ansteuern

Wenn nicht zu einer anderen Route gesprungen werden soll, sondern nur das
Ergebnis einer anderen Route gefordert wird, kann `call` für einen internen
Request verwendet werden:

```ruby
get '/foo' do
  status, headers, body = call env.merge("PATH_INFO" => '/bar')
  [status, headers, body.map(&:upcase)]
end

get '/bar' do
  "bar"
end
```

Beachte, dass in dem oben angegeben Beispiel die Performance erheblich erhöht
werden kann, wenn `"bar"` in eine Helfer-Methode umgewandelt wird, auf die
`/foo` und `/bar` zugreifen können.

Wenn der Request innerhalb derselben Applikations-Instanz aufgerufen und keine
Kopie der Instanz erzeugt werden soll, kann `call!` anstelle von `call`
verwendet werden.

### Body, Status-Code und Header setzen

Es ist möglich und empfohlen, den Status-Code sowie den Response-Body mit einem
Returnwert in der Route zu setzen. In manchen Situationen kann es jedoch sein,
dass der Body an anderer Stelle während der Ausführung gesetzt werden soll.
Dafür kann man die Helfer-Methode `body` einsetzen. Ist sie gesetzt, kann sie zu
einem späteren Zeitpunkt aufgerufen werden:

```ruby
get '/foo' do
  body "bar"
end

after do
  puts body
end
```

Ebenso ist es möglich, einen Block an `body` weiterzureichen, der dann vom
Rack-Handler ausgeführt wird (lässt sich z.B. zur Umsetzung von Streaming
einsetzen, siehe auch "Rückgabewerte").

Vergleichbar mit `body` lassen sich auch Status-Code und Header setzen:

```ruby
get '/foo' do
  status 418
  headers \
    "Allow"   => "BREW, POST, GET, PROPFIND, WHEN",
    "Refresh" => "Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt"
  halt "Ich bin ein Teekesselchen"
end
```

Genau wie bei `body` liest ein Aufrufen von `headers` oder `status` ohne
Argumente den aktuellen Wert aus.

### Response-Streams

In manchen Situationen sollen Daten bereits an den Client zurückgeschickt
werden, bevor ein vollständiger Response bereit steht. Manchmal will man die
Verbindung auch erst dann beenden und Daten so lange an den Client
zurückschicken, bis er die Verbindung abbricht. Für diese Fälle gibt es die
`stream`-Helfer-Methode, die es einem erspart eigene Lösungen zu schreiben:

```ruby
get '/' do
  stream do |out|
    out << "Das ist ja mal wieder fanta -\n"
    sleep 0.5
    out << " (bitte warten…) \n"
    sleep 1
    out << "- stisch!\n"
  end
end
```

Damit lassen sich Streaming-APIs realisieren, sog.
[Server Sent Events](http://dev.w3.org/html5/eventsource/), die als Basis für
[WebSockets](http://en.wikipedia.org/wiki/WebSocket) dienen. Ebenso können sie
verwendet werden, um den Durchsatz zu erhöhen, wenn ein Teil der Daten von
langsamen Ressourcen abhängig ist.

Es ist zu beachten, dass das Verhalten beim Streaming, insbesondere die Anzahl
nebenläufiger Anfragen, stark davon abhängt, welcher Webserver für die
Applikation verwendet wird. Einige Server, z.B. WEBRick, unterstützen
Streaming nicht oder nur teilweise. Sollte der Server Streaming nicht
unterstützen, wird ein vollständiger Response-Body zurückgeschickt, sobald der
an `stream` weitergegebene Block abgearbeitet ist. Mit Shotgun funktioniert
Streaming z.B. überhaupt nicht.

Ist der optionale Parameter `keep_open` aktiviert, wird beim gestreamten Objekt
`close` nicht aufgerufen und es ist einem überlassen dies an einem beliebigen
späteren Zeitpunkt nachholen. Die Funktion ist jedoch nur bei Event-gesteuerten
Serven wie Thin oder Rainbows möglich, andere Server werden trotzdem den Stream
beenden:

```ruby
# Durchgehende Anfrage (long polling)

set :server, :thin
connections = []

get '/subscribe' do
  # Client-Registrierung beim Server, damit Events mitgeteilt werden können
  stream(:keep_open) do |out|
    connections << out
    # tote Verbindungen entfernen
    connections.reject!(&:closed?)
  end
end

post '/:message' do
  connections.each do |out|
    # Den Client über eine neue Nachricht in Kenntnis setzen
    # notify client that a new message has arrived
    out << params['message'] << "\n"

    # Den Client zur erneuten Verbindung auffordern
    out.close
  end

  # Rückmeldung
  "Mitteiling erhalten"
end
```

### Logger

Im Geltungsbereich eines Request stellt die `logger` Helfer-Methode eine `Logger`
Instanz zur Verfügung:

```ruby
get '/' do
  logger.info "es passiert gerade etwas"
  # ...
end
```

Der Logger übernimmt dabei automatisch alle im Rack-Handler eingestellten
Log-Vorgaben. Ist Loggen ausgeschaltet, gibt die Methode ein Leerobjekt zurück.
In den Routen und Filtern muss man sich also nicht weiter darum kümmern.

Beachte, dass das Loggen standardmäßig nur für `Sinatra::Application`
voreingestellt ist. Wird über `Sinatra::Base` vererbt, muss es erst aktiviert
werden:

```ruby
class MyApp < Sinatra::Base
  configure :production, :development  do
    enable :logging
  end
end
```

Damit auch keine Middleware das Logging aktivieren kann, muss die `logging`
Einstellung auf `nil` gesetzt werden. Das heißt aber auch, dass `logger` in
diesem Fall `nil` zurückgeben wird. Üblicherweise wird das eingesetzt, wenn ein
eigener Logger eingerichtet werden soll. Sinatra wird dann verwenden, was in
`env['rack.logger']` eingetragen ist.

### Mime-Types

Wenn `send_file` oder statische Dateien verwendet werden, kann es vorkommen,
dass Sinatra den Mime-Typ nicht kennt. Registriert wird dieser mit `mime_type`
per Dateiendung:

```ruby
configure do
  mime_type :foo, 'text/foo'
end
```

Es kann aber auch der `content_type`-Helfer verwendet werden:

```ruby
get '/' do
  content_type :foo
  "foo foo foo"
end
```

### URLs generieren

Zum Generieren von URLs sollte die `url`-Helfer-Methode genutzen werden, so z.B.
beim Einsatz von Haml:

```ruby
%a{:href => url('/foo')} foo
```

Soweit vorhanden, wird Rücksicht auf Proxys und Rack-Router genommen.

Diese Methode ist ebenso über das Alias `to` zu erreichen (siehe Beispiel unten).

### Browser-Umleitung

Eine Browser-Umleitung kann mithilfe der `redirect`-Helfer-Methode erreicht
werden:

```ruby
get '/foo' do
  redirect to('/bar')
end
```

Weitere Parameter werden wie Argumente der `halt`-Methode behandelt:

```ruby
redirect to('/bar'), 303
redirect 'http://google.com', 'Hier bist du falsch'
```

Ebenso leicht lässt sich ein Schritt zurück mit dem Alias `redirect back`
erreichen:

```ruby
get '/foo' do
  "<a href='/bar'>mach was</a>"
end

get '/bar' do
  mach_was
  redirect back
end
```

Um Argumente an ein Redirect weiterzugeben, können sie entweder dem Query
übergeben:

```ruby
redirect to('/bar?summe=42')
```

oder eine Session verwendet werden:

```ruby
enable :sessions

get '/foo' do
  session[:secret] = 'foo'
  redirect to('/bar')
end

get '/bar' do
  session[:secret]
end
```

### Cache einsetzen

Ein sinnvolles Einstellen von Header-Daten ist die Grundlage für ein
ordentliches HTTP-Caching.

Der Cache-Control-Header lässt sich ganz einfach einstellen:

```ruby
get '/' do
  cache_control :public
  "schon gecached!"
end
```

Profitipp: Caching im before-Filter aktivieren

```ruby
before do
  cache_control :public, :must_revalidate, :max_age => 60
end
```

Bei Verwendung der `expires`-Helfermethode zum Setzen des gleichnamigen Headers,
wird `Cache-Control` automatisch eigestellt:

```ruby
before do
  expires 500, :public, :must_revalidate
end
```

Um alles richtig zu machen, sollten auch `etag` oder `last_modified` verwendet
werden. Es wird empfohlen, dass diese Helfer aufgerufen werden **bevor** die
eigentliche Arbeit anfängt, da sie sofort eine Antwort senden, wenn der Client
eine aktuelle Version im Cache vorhält:

```ruby
get '/article/:id' do
  @article = Article.find params['id']
  last_modified @article.updated_at
  etag @article.sha1
  erb :article
end
```

ebenso ist es möglich einen
[schwachen ETag](http://de.wikipedia.org/wiki/HTTP_ETag) zu verwenden:

```ruby
etag @article.sha1, :weak
```

Diese Helfer führen nicht das eigentliche Caching aus, sondern geben die dafür
notwendigen Informationen an den Cache weiter. Für schnelle Reverse-Proxy
Cache-Lösungen bietet sich z.B.
[rack-cache](https://github.com/rtomayko/rack-cache) an:

```ruby
require "rack/cache"
require "sinatra"

use Rack::Cache

get '/' do
  cache_control :public, :max_age => 36000
  sleep 5
  "hello"
end
```

Um den `Cache-Control`-Header mit Informationen zu versorgen, verwendet man die
`:static_cache_control`-Einstellung (s.u.).

Nach RFC 2616 sollte sich die Anwendung anders verhalten, wenn ein If-Match oder
ein If-None_match Header auf `*` gesetzt wird in Abhängigkeit davon, ob die
Resource bereits existiert. Sinatra geht davon aus, dass Ressourcen bei sicheren
Anfragen (z.B. bei get oder Idempotenten Anfragen wie put) bereits existieren,
wobei anderen Ressourcen (besipielsweise bei post), als neue Ressourcen
behandelt werden. Dieses Verhalten lässt sich mit der `:new_resource` Option
ändern:

```ruby
get '/create' do
  etag '', :new_resource => true
  Article.create
  erb :new_article
end
```

Soll das schwache ETag trotzdem verwendet werden, verwendet man die `:kind`
Option:

```ruby
etag '', :new_resource => true, :kind => :weak
```

### Dateien versenden

Um den Inhalt einer Datei als Response zurückzugeben, kann die
`send_file`-Helfer-Methode verwendet werden:

```ruby
get '/' do
  send_file 'foo.png'
end
```

Für `send_file` stehen einige Hash-Optionen zur Verfügung:

```ruby
send_file 'foo.png', :type => :jpg
```

<dl>
  <dt>filename</dt>
  <dd>Dateiname als Response. Standardwert ist der eigentliche Dateiname.</dd>

  <dt>last_modified</dt>
  <dd>Wert für den Last-Modified-Header, Standardwert ist <tt>mtime</tt> der
    Datei.</dd>

  <dt>type</dt>
  <dd>Content-Type, der verwendet werden soll. Wird, wenn nicht angegeben, von
    der Dateiendung abgeleitet.</dd>

  <dt>disposition</dt>
  <dd>Verwendet für Content-Disposition. Mögliche Werte sind: <tt>nil</tt>
    (Standard), <tt>:attachment</tt> und <tt>:inline</tt>.</dd>

  <dt>length</dt>
  <dd>Content-Length-Header. Standardwert ist die Dateigröße.</dd>
</dl>

Soweit vom Rack-Handler unterstützt, werden neben der Übertragung über den
Ruby-Prozess auch andere Möglichkeiten genutzt. Bei Verwendung der
`send_file`-Helfer-Methode kümmert sich Sinatra selbstständig um die
Range-Requests.

### Das Request-Objekt

Auf das `request`-Objekt der eigehenden Anfrage kann vom Anfrage-Scope aus
zugegriffen werden:

```ruby
# App läuft unter http://example.com/example
get '/foo' do
  t = %w[text/css text/html application/javascript]
  request.accept              # ['text/html', '*/*']
  request.accept? 'text/xml'  # true
  request.preferred_type(t)   # 'text/html'
  request.body                # Request-Body des Client (siehe unten)
  request.scheme              # "http"
  request.script_name         # "/example"
  request.path_info           # "/foo"
  request.port                # 80
  request.request_method      # "GET"
  request.query_string        # ""
  request.content_length      # Länge des request.body
  request.media_type          # Medientypus von request.body
  request.host                # "example.com"
  request.get?                # true (ähnliche Methoden für andere Verben)
  request.form_data?          # false
  request["irgendein_param"]  # Wert von einem Parameter; [] ist die Kurzform für den params Hash
  request.referrer            # Der Referrer des Clients oder '/'
  request.user_agent          # User-Agent (verwendet in der :agent Bedingung)
  request.cookies             # Hash des Browser-Cookies
  request.xhr?                # Ist das hier ein Ajax-Request?
  request.url                 # "http://example.com/example/foo"
  request.path                # "/example/foo"
  request.ip                  # IP-Adresse des Clients
  request.secure?             # false (true wenn SSL)
  request.forwarded?          # true (Wenn es hinter einem Reverse-Proxy verwendet wird)
  request.env                 # vollständiger env-Hash von Rack übergeben
end
```

Manche Optionen, wie etwa `script_name` oder `path_info`, sind auch
schreibbar:

```ruby
before { request.path_info = "/" }

get "/" do
  "Alle Anfragen kommen hier an!"
end
```

Der `request.body` ist ein IO- oder StringIO-Objekt:

```ruby
post "/api" do
  request.body.rewind # falls schon jemand davon gelesen hat
  daten = JSON.parse request.body.read
  "Hallo #{daten['name']}!"
end
```

### Anhänge

Damit der Browser erkennt, dass ein Response gespeichert und nicht im Browser
angezeigt werden soll, kann der `attachment`-Helfer verwendet werden:

```ruby
get '/' do
  attachment
  "Speichern!"
end
```

Ebenso kann eine Dateiname als Parameter hinzugefügt werden:

```ruby
get '/' do
  attachment "info.txt"
  "Speichern!"
end
```

### Umgang mit Datum und Zeit

Sinatra bietet eine `time_for`-Helfer-Methode, die aus einem gegebenen Wert ein
Time-Objekt generiert. Ebenso kann sie nach `DateTime`, `Date` und ähnliche
Klassen konvertieren:

```ruby
get '/' do
  pass if Time.now > time_for('Dec 23, 2012')
  "noch Zeit"
end
```

Diese Methode wird intern für +expires, `last_modiefied` und ihresgleichen
verwendet. Mit ein paar Handgriffen lässt sich diese Methode also in ihrem
Verhalten erweitern, indem man `time_for` in der eigenen Applikation
überschreibt:

```ruby
helpers do
  def time_for(value)
    case value
    when :yesterday then Time.now - 24*60*60
    when :tomorrow  then Time.now + 24*60*60
    else super
    end
  end
end

get '/' do
  last_modified :yesterday
  expires :tomorrow
  "Hallo"
end
```

### Nachschlagen von Template-Dateien

Die `find_template`-Helfer-Methode wird genutzt, um Template-Dateien zum Rendern
aufzufinden:

```ruby
find_template settings.views, 'foo', Tilt[:haml] do |file|
  puts "könnte diese hier sein: #{file}"
end
```

Das ist zwar nicht wirklich brauchbar, aber wenn man sie überschreibt, kann sie
nützlich werden, um eigene Nachschlage-Mechanismen einzubauen. Zum Beispiel
dann, wenn mehr als nur ein view-Verzeichnis verwendet werden soll:

```ruby
set :views, ['views', 'templates']

helpers do
  def find_template(views, name, engine, &block)
    Array(views).each { |v| super(v, name, engine, &block) }
  end
end
```

Ein anderes Beispiel wäre, verschiedene Vereichnisse für verschiedene Engines
zu verwenden:

```ruby
set :views, :sass => 'views/sass', :haml => 'templates', :default => 'views'

helpers do
  def find_template(views, name, engine, &block)
    _, folder = views.detect { |k,v| engine == Tilt[k] }
    folder ||= views[:default]
    super(folder, name, engine, &block)
  end
end
```

Ebensogut könnte eine Extension aber auch geschrieben und mit anderen geteilt
werden!

Beachte, dass `find_template` nicht prüft, ob eine Datei tatsächlich existiert.
Es wird lediglich der angegebene Block aufgerufen und nach allen möglichen
Pfaden gesucht. Das ergibt kein Performance-Problem, da `render` `block`
verwendet, sobald eine Datei gefunden wurde. Ebenso werden Template-Pfade samt
Inhalt gecached, solange nicht im Entwicklungsmodus gearbeitet wird. Das sollte
im Hinterkopf behalten werden, wenn irgendwelche verrückten Methoden
zusammenbastelt werden.

### Konfiguration

Wird einmal beim Starten in jedweder Umgebung ausgeführt:

```ruby
configure do
  # setze eine Option
  set :option, 'wert'

  # setze mehrere Optionen
  set :a => 1, :b => 2

  # das gleiche wie `set :option, true`
  enable :option

  # das gleiche wie `set :option, false`
  disable :option

  # dynamische Einstellungen mit Blöcken
  set(:css_dir) { File.join(views, 'css') }
end
```

Läuft nur, wenn die Umgebung (RACK_ENV-Umgebungsvariable) auf `:production`
gesetzt ist:

```ruby
configure :production do
  ...
end
```

Läuft nur, wenn die Umgebung auf `:production` oder auf `:test` gesetzt ist:

```ruby
configure :production, :test do
  ...
end
```

Diese Einstellungen sind über `settings` erreichbar:

```ruby
configure do
  set :foo, 'bar'
end

get '/' do
  settings.foo? # => true
  settings.foo  # => 'bar'
  ...
end
```

#### Einstellung des Angriffsschutzes

Sinatra verwendet
[Rack::Protection](https://github.com/rkh/rack-protection#readme), um die
Anwendung vor häufig vorkommenden Angriffen zu schützen. Diese Voreinstellung
lässt sich selbstverständlich deaktivieren, der damit verbundene
Geschwindigkeitszuwachs steht aber in keinem Verhätnis zu den möglichen
Risiken.

```ruby
disable :protection
```

Um einen bestimmten Schutzmechanismus zu deaktivieren, fügt man `protection`
einen Hash mit Optionen hinzu:

```ruby
set :protection, :except => :path_traversal
```

Neben Strings akzeptiert `:except` auch Arrays, um gleich mehrere
Schutzmechanismen zu deaktivieren:

```ruby
set :protection, :except => [:path_traversal, :session_hijacking]
```

#### Mögliche Einstellungen

<dl>
  <dt>absolute_redirects</dt>
  <dd>Wenn ausgeschaltet, wird Sinatra relative Redirects zulassen. Jedoch ist
  Sinatra dann nicht mehr mit RFC 2616 (HTTP 1.1) konform, das nur absolute
  Redirects zulässt. Sollte eingeschaltet werden, wenn die Applikation hinter
  einem Reverse-Proxy liegt, der nicht ordentlich eingerichtet ist. Beachte,
  dass die <tt>url</tt>-Helfer-Methode nach wie vor absolute URLs erstellen
  wird, es sei denn, es wird als zweiter Parameter <tt>false</tt> angegeben.
  Standardmäßig nicht aktiviert.</dd>

  <dt>add_charset</dt>
  <dd>Mime-Types werden hier automatisch der Helfer-Methode
  <tt>content_type</tt> zugeordnet. Es empfielt sich, Werte hinzuzufügen statt
  sie zu überschreiben: <tt>settings.add_charset << "application/foobar"</tt>
  </dd>

  <dt>app_file</dt>
  <dd>Pfad zur Hauptdatei der Applikation. Wird verwendet, um das Wurzel-,
  Inline-, View- und öffentliche Verzeichnis des Projekts festzustellen.</dd>

  <dt>bind</dt>
  <dd>IP-Address, an die gebunden wird (Standardwert: <tt>0.0.0.0</tt>
  <em>oder</em> <tt>localhost</tt>). Wird  nur für den eingebauten Server
  verwendet.</dd>

  <dt>default_encoding</dt>
  <dd>Das Encoding, falls keines angegeben wurde. Standardwert ist
  <tt>"utf-8"</tt>.</dd>

  <dt>dump_errors</dt>
  <dd>Fehler im Log anzeigen.</dd>

  <dt>environment</dt>
  <dd>Momentane Umgebung. Standardmäßig auf <tt>content_type</tt> oder
  <tt>"development"</tt> eingestellt, soweit ersteres nicht vorhanden.</dd>

  <dt>logging</dt>
  <dd>Den Logger verwenden.</dd>

  <dt>lock</dt>
  <dd>Jeder Request wird gelocked. Es kann nur ein Request pro Ruby-Prozess
  gleichzeitig verarbeitet werden. Eingeschaltet, wenn die Applikation
  threadsicher ist. Standardmäßig nicht aktiviert.</dd>

  <dt>method_override</dt>
  <dd>Verwende <tt>_method</tt>, um put/delete-Formulardaten in Browsern zu
  verwenden, die dies normalerweise nicht unterstützen.</dd>

  <dt>port</dt>
  <dd>Port für die Applikation. Wird nur im internen Server verwendet.</dd>

  <dt>prefixed_redirects</dt>
  <dd>Entscheidet, ob <tt>request.script_name</tt> in Redirects eingefügt wird
  oder nicht, wenn kein absoluter Pfad angegeben ist. Auf diese Weise verhält
  sich <tt>redirect '/foo'</tt> so, als wäre es ein <tt>redirect
  to('/foo')</tt>. Standardmäßig nicht aktiviert.</dd>

  <dt>protection</dt>
  <dd>Legt fest, ob der Schutzmechanismus für häufig Vorkommende Webangriffe
  auf Webapplikationen aktiviert wird oder nicht. Weitere Informationen im
  vorhergehenden Abschnitt.</dd>

  <dt>public_folder</dt>
  <dd>Das öffentliche Verzeichnis, aus dem Daten zur Verfügung gestellt werden
  können. Wird nur dann verwendet, wenn statische Daten zur Verfügung gestellt
  werden können (s.u. <tt>static</tt> Option). Leitet sich von der
  <tt>app_file</tt> Einstellung ab, wenn nicht gesetzt.</dd>

  <dt>public_dir</dt>
  <dd>Alias für <tt>public_folder</tt>, s.o.</dd>

  <dt>reload_templates</dt>
  <dd>Im development-Modus aktiviert.</dd>

  <dt>root</dt>
  <dd>Wurzelverzeichnis des Projekts. Leitet sich von der <tt>app_file</tt>
  Einstellung ab, wenn nicht gesetzt.</dd>

  <dt>raise_errors</dt>
  <dd>Einen Ausnahmezustand aufrufen. Beendet die Applikation. Ist automatisch
  aktiviert, wenn die Umgebung auf <tt>"test"</tt> eingestellt ist. Ansonsten
  ist diese Option deaktiviert.</dd>

  <dt>run</dt>
  <dd>Wenn aktiviert, wird Sinatra versuchen, den Webserver zu starten. Nicht
  verwenden, wenn Rackup oder anderes verwendet werden soll.</dd>

  <dt>running</dt>
  <dd>Läuft der eingebaute Server? Diese Einstellung nicht ändern!</dd>

  <dt>server</dt>
  <dd>Server oder Liste von Servern, die als eingebaute Server zur Verfügung
  stehen. Die Reihenfolge gibt die Priorität vor, die Voreinstellung hängt von
  der verwendenten Ruby Implementierung ab.</dd>

  <dt>sessions</dt>
  <dd>Sessions auf Cookiebasis mittels
  <tt>Rack::Session::Cookie</tt>aktivieren. Für weitere Infos bitte in der
  Sektion ‘Sessions verwenden’ nachschauen.</dd>

  <dt>show_exceptions</dt>
  <dd>Bei Fehlern einen Stacktrace im Browseranzeigen. Ist automatisch
  aktiviert, wenn die Umgebung auf <tt>"development"</tt> eingestellt ist.
  Ansonsten ist diese Option deaktiviert. Kann auch auf <tt>:after_handler</tt>
  gestellt werden, um eine anwendungsspezifische Fehlerbehandlung auszulösen,
  bevor der Fehlerverlauf im Browser angezeigt wird.</dd>

  <dt>static</dt>
  <dd>Entscheidet, ob Sinatra statische Dateien zur Verfügung stellen soll oder
  nicht. Sollte nicht aktiviert werden, wenn ein Server verwendet wird, der
  dies auch selbstständig erledigen kann. Deaktivieren wird die Performance
  erhöhen. Standardmäßig aktiviert.</dd>

  <dt>static_cache_control</dt>
  <dd>Wenn Sinatra statische Daten zur Verfügung stellt, können mit dieser
  Einstellung die <tt>Cache-Control</tt> Header zu den Responses hinzugefügt
  werden. Die Einstellung verwendet dazu die <tt>cache_control</tt>
  Helfer-Methode. Standardmäßig deaktiviert. Ein Array wird verwendet, um
  mehrere Werte gleichzeitig zu übergeben: <tt>set :static_cache_control,
  [:public, :max_age => 300]</tt></dd>

  <dt>threaded</dt>
  <dd>Wird es auf <tt>true</tt> gesetzt, wird Thin aufgefordert
  <tt>EventMachine.defer</tt> zur Verarbeitung des Requests einzusetzen.</dd>

  <dt>traps</dt>
  <dd>Einstellung, Sinatra System signalen umgehen soll.</dd>

  <dt>views</dt>
  <dd>Verzeichnis der Views. Leitet sich von der <tt>app_file</tt> Einstellung
  ab, wenn nicht gesetzt.</dd>

  <dt>x_cascade</dt>
  <dd>Einstellung, ob der X-Cascade Header bei fehlender Route gesetzt wird oder
  nicht. Standardeinstellung ist <tt>true</tt>.</dd>
</dl>

## Umgebungen

Es gibt drei voreingestellte Umgebungen in Sinatra: `"development"`,
`"production"` und `"test"`. Umgebungen können über die `RACK_ENV`
Umgebungsvariable gesetzt werden. Die Standardeinstellung ist `"development"`.
In diesem Modus werden alle Templates zwischen Requests neu geladen. Dazu gibt
es besondere Fehlerseiten für 404 Stati und Fehlermeldungen. In `"production"`
und `"test"` werden Templates automatisch gecached.

Um die Anwendung in einer anderen Umgebung auszuführen kann man die `-e`
Option verwenden:

```shell
ruby my_app.rb -e [ENVIRONMENT]
```

In der Anwendung kann man die die Methoden  `development?`, `test?` und
`production?` verwenden, um die aktuelle Umgebung zu erfahren.

## Fehlerbehandlung

Error-Handler laufen in demselben Kontext wie Routen und Filter, was bedeutet,
dass alle Goodies wie `haml`, `erb`, `halt`, etc. verwendet werden können.

### Nicht gefunden

Wenn eine `Sinatra::NotFound`-Exception geworfen wird oder der Statuscode 404
ist, wird der `not_found`-Handler ausgeführt:

```ruby
not_found do
  'Seite kann nirgendwo gefunden werden.'
end
```

### Fehler

Der `error`-Handler wird immer ausgeführt, wenn eine Exception in einem
Routen-Block oder in einem Filter geworfen wurde. In der
`development`-Umgebung wird es nur dann funktionieren, wenn die
`:show_exceptions`-Option auf `:after_handler` eingestellt wurde:

```ruby
set :show_exceptions, :after_handler
```

Die Exception kann über die `sinatra.error`-Rack-Variable angesprochen werden:

```ruby
error do
  'Entschuldige, es gab einen hässlichen Fehler - ' + env['sinatra.error'].message
end
```

Benutzerdefinierte Fehler:

```ruby
error MeinFehler do
  'Au weia, ' + env['sinatra.error'].message
end
```

Dann, wenn das passiert:

```ruby
get '/' do
  raise MeinFehler, 'etwas Schlimmes ist passiert'
end
```

bekommt man dieses:

```shell
Au weia, etwas Schlimmes ist passiert
```

Alternativ kann ein Error-Handler auch für einen Status-Code definiert werden:

```ruby
error 403 do
  'Zugriff verboten'
end

get '/geheim' do
  403
end
```

Oder ein Status-Code-Bereich:

```ruby
error 400..510 do
  'Hallo?'
end
```

Sinatra setzt verschiedene `not_found`- und `error`-Handler in der
Development-Umgebung ein, um hilfreiche Debugging Informationen und Stack Traces
anzuzeigen.

## Rack-Middleware

Sinatra baut auf [Rack](http://rack.github.io/), einem minimalistischen
Standard-Interface für Ruby-Webframeworks. Eines der interessantesten Features
für Entwickler ist der Support von Middlewares, die zwischen den Server und
die Anwendung geschaltet werden und so HTTP-Request und/oder Antwort
überwachen und/oder manipulieren können.

Sinatra macht das Erstellen von Middleware-Verkettungen mit der
Top-Level-Methode `use` zu einem Kinderspiel:

```ruby
require 'sinatra'
require 'meine_middleware'

use Rack::Lint
use MeineMiddleware

get '/hallo' do
  'Hallo Welt'
end
```

Die Semantik von `use` entspricht der gleichnamigen Methode der
[Rack::Builder](http://rubydoc.info/github/rack/rack/master/Rack/Builder)-DSL
(meist verwendet in Rackup-Dateien). Ein Beispiel dafür ist, dass die
`use`-Methode mehrere/verschiedene Argumente und auch Blöcke entgegennimmt:

```ruby
use Rack::Auth::Basic do |username, password|
  username == 'admin' && password == 'geheim'
end
```

Rack bietet eine Vielzahl von Standard-Middlewares für Logging, Debugging,
URL-Routing, Authentifizierung und Session-Verarbeitung. Sinatra verwendet
viele von diesen Komponenten automatisch, abhängig von der Konfiguration. So
muss `use` häufig nicht explizit verwendet werden.

Hilfreiche Middleware gibt es z.B. hier:
[rack](https://github.com/rack/rack/tree/master/lib/rack),
[rack-contrib](https://github.com/rack/rack-contrib#readme),
oder im [Rack wiki](https://github.com/rack/rack/wiki/List-of-Middleware).

## Testen

Sinatra-Tests können mit jedem auf Rack aufbauendem Test-Framework geschrieben
werden. [Rack::Test](http://rdoc.info/github/brynary/rack-test/master/frames)
wird empfohlen:

```ruby
require 'my_sinatra_app'
require 'minitest/autorun'
require 'rack/test'

class MyAppTest < Minitest::Test
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_my_default
    get '/'
    assert_equal 'Hallo Welt!', last_response.body
  end

  def test_with_params
    get '/meet', :name => 'Frank'
    assert_equal 'Hallo Frank!', last_response.body
  end

  def test_with_rack_env
    get '/', {}, 'HTTP_USER_AGENT' => 'Songbird'
    assert_equal "Du verwendest Songbird!", last_response.body
  end
end
```

Hinweis: Wird Sinatra modular verwendet, muss <tt>Sinatra::Application</tt> mit
dem Namen der Applikations-Klasse ersetzt werden.

## Sinatra::Base - Middleware, Bibliotheken und modulare Anwendungen

Das Definieren einer Top-Level-Anwendung funktioniert gut für
Mikro-Anwendungen, hat aber Nachteile, wenn wiederverwendbare Komponenten wie
Middleware, Rails Metal, einfache Bibliotheken mit Server-Komponenten oder
auch Sinatra-Erweiterungen geschrieben werden sollen.

Das Top-Level geht von einer Konfiguration für eine Mikro-Anwendung aus (wie
sie z.B. bei einer einzelnen Anwendungsdatei, `./public` und `./views` Ordner,
Logging, Exception-Detail-Seite, usw.). Genau hier kommt `Sinatra::Base` ins
Spiel:

```ruby
require 'sinatra/base'

class MyApp < Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Hallo Welt!'
  end
end
```

Die MyApp-Klasse ist eine unabhängige Rack-Komponente, die als Middleware,
Endpunkt oder via Rails Metal verwendet werden kann. Verwendet wird sie durch
`use` oder `run` von einer Rackup-`config.ru`-Datei oder als Server-Komponente
einer Bibliothek:

```ruby
MyApp.run! :host => 'localhost', :port => 9090
```

Die Methoden der `Sinatra::Base`-Subklasse sind genau dieselben wie die der
Top-Level-DSL. Die meisten Top-Level-Anwendungen können mit nur zwei
Veränderungen zu `Sinatra::Base` konvertiert werden:

*   Die Datei sollte `require 'sinatra/base'` anstelle von `require
    'sinatra/base'` aufrufen, ansonsten werden alle von Sinatras DSL-Methoden
    in den Top-Level-Namespace importiert.
*   Alle Routen, Error-Handler, Filter und Optionen der Applikation müssen in
    einer Subklasse von `Sinatra::Base` definiert werden.

`Sinatra::Base` ist ein unbeschriebenes Blatt. Die meisten Optionen sind per
Standard deaktiviert. Das betrifft auch den eingebauten Server. Siehe
[Optionen und Konfiguration](http://sinatra.github.com/configuration.html) für
Details über mögliche Optionen.

Damit eine App sich ähnlich wie eine klassische App verhält, kann man
auch eine Subclass von `Sinatra::Application` erstellen:

``` ruby
require 'sinatra/base'

class MyApp < Sinatra::Application
  get '/' do
    'Hello world!'
  end
end
```

### Modularer vs. klassischer Stil

Entgegen häufiger Meinungen gibt es nichts gegen den klassischen Stil
einzuwenden. Solange es die Applikation nicht beeinträchtigt, besteht kein
Grund, eine modulare Applikation zu erstellen.

Der größte Nachteil der klassischen Sinatra Anwendung gegenüber einer
modularen ist die Einschränkung auf eine Sinatra Anwendung pro Ruby-Prozess.
Sollen mehrere zum Einsatz kommen, muss auf den modularen Stil umgestiegen
werden. Dabei ist es kein Problem klassische und modulare Anwendungen
miteinander zu vermischen.

Bei einem Umstieg, sollten einige Unterschiede in den Einstellungen beachtet
werden:

<table>
  <tr>
    <th>Szenario</th>
    <th>Classic</th>
    <th>Modular</th>
    <th>Modular</th>
  </tr>

  <tr>
    <td>app_file</td>
    <td>Sinatra ladende Datei</td>
    <td>Sinatra::Base subklassierende Datei</td>
    <td>Sinatra::Application subklassierende Datei</td>
  </tr>

  <tr>
    <td>run</td>
    <td>$0 == app_file</td>
    <td>false</td>
    <td>false</td>
  </tr>

  <tr>
    <td>logging</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>method_override</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>inline_templates</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>static</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>
</table>

### Eine modulare Applikation bereitstellen

Es gibt zwei übliche Wege, eine modulare Anwendung zu starten. Zum einen über
`run!`:

```ruby
# mein_app.rb
require 'sinatra/base'

class MeinApp < Sinatra::Base
  # ... Anwendungscode hierhin ...

  # starte den Server, wenn die Ruby-Datei direkt ausgeführt wird
  run! if app_file == $0
end
```

Starte mit:

```shell
ruby mein_app.rb
```

Oder über eine `config.ru`-Datei, die es erlaubt, einen beliebigen
Rack-Handler zu verwenden:

```ruby
# config.ru (mit rackup starten)
require './mein_app'
run MeineApp
```

Starte:

```shell
rackup -p 4567
```

### Eine klassische Anwendung mit einer config.ru verwenden

Schreibe eine Anwendungsdatei:

```ruby
# app.rb
require 'sinatra'

get '/' do
  'Hallo Welt!'
end
```

sowie eine dazugehörige `config.ru`-Datei:

```ruby
require './app'
run Sinatra::Application
```

### Wann sollte eine config.ru-Datei verwendet werden?

Anzeichen dafür, dass eine `config.ru`-Datei gebraucht wird:

*   Es soll ein anderer Rack-Handler verwendet werden (Passenger, Unicorn,
    Heroku, ...).
*   Es gibt mehr als nur eine Subklasse von `Sinatra::Base`.
*   Sinatra soll als Middleware verwendet werden, nicht als Endpunkt.


**Es gibt keinen Grund, eine `config.ru`-Datei zu verwenden, nur weil eine
Anwendung im modularen Stil betrieben werden soll. Ebenso wird keine Anwendung
mit modularem Stil benötigt, um eine `config.ru`-Datei zu verwenden.**

### Sinatra als Middleware nutzen

Es ist nicht nur möglich, andere Rack-Middleware mit Sinatra zu nutzen, es
kann außerdem jede Sinatra-Anwendung selbst als Middleware vor jeden
beliebigen Rack-Endpunkt gehangen werden. Bei diesem Endpunkt muss es sich
nicht um eine andere Sinatra-Anwendung handeln, es kann jede andere
Rack-Anwendung sein (Rails/Ramaze/Camping/...):

```ruby
require 'sinatra/base'

class LoginScreen < Sinatra::Base
  enable :sessions

  get('/login') { haml :login }

  post('/login') do
    if params['name'] == 'admin' && params['password'] == 'admin'
      session['user_name'] = params['name']
    else
      redirect '/login'
    end
  end
end

class MyApp < Sinatra::Base
  # Middleware wird vor Filtern ausgeführt
  use LoginScreen

  before do
    unless session['user_name']
      halt "Zugriff verweigert, bitte <a href='/login'>einloggen</a>."
    end
  end

  get('/') { "Hallo #{session['user_name']}." }
end
```

### Dynamische Applikationserstellung

Manche Situationen erfordern die Erstellung neuer Applikationen zur Laufzeit,
ohne dass sie einer Konstanten zugeordnet werden. Dies lässt sich mit
`Sinatra.new` erreichen:

```ruby
require 'sinatra/base'
my_app = Sinatra.new { get('/') { "hallo" } }
my_app.run!
```

Die Applikation kann mit Hilfe eines optionalen Parameters erstellt werden:

```ruby
# config.ru
require 'sinatra/base'

controller = Sinatra.new do
  enable :logging
  helpers MyHelpers
end

map('/a') do
  run Sinatra.new(controller) { get('/') { 'a' } }
end

map('/b') do
  run Sinatra.new(controller) { get('/') { 'b' } }
end
```

Das ist besonders dann interessant, wenn Sinatra-Erweiterungen getestet werden
oder Sinatra in einer Bibliothek Verwendung findet.

Ebenso lassen sich damit hervorragend Sinatra-Middlewares erstellen:

```ruby
require 'sinatra/base'

use Sinatra do
  get('/') { ... }
end

run RailsProject::Application
```

## Geltungsbereich und Bindung

Der Geltungsbereich (Scope) legt fest, welche Methoden und Variablen zur
Verfügung stehen.

### Anwendungs- oder Klassen-Scope

Jede Sinatra-Anwendung entspricht einer `Sinatra::Base`-Subklasse. Falls die
Top- Level-DSL verwendet wird (`require 'sinatra'`), handelt es sich um
`Sinatra::Application`, andernfalls ist es jene Subklasse, die explizit
angelegt wurde. Auf Klassenebene stehen Methoden wie `get` oder `before` zur
Verfügung, es gibt aber keinen Zugriff auf das `request`-Object oder die
`session`, da nur eine einzige Klasse für alle eingehenden Anfragen genutzt
wird.

Optionen, die via `set` gesetzt werden, sind Methoden auf Klassenebene:

```ruby
class MyApp < Sinatra::Base
  # Hey, ich bin im Anwendungsscope!
  set :foo, 42
  foo # => 42

  get '/foo' do
    # Hey, ich bin nicht mehr im Anwendungs-Scope!
  end
end
```

Im Anwendungs-Scope befindet man sich:

*   In der Anwendungs-Klasse.
*   In Methoden, die von Erweiterungen definiert werden.
*   Im Block, der an `helpers` übergeben wird.
*   In Procs und Blöcken, die an `set` übergeben werden.
*   Der an `Sinatra.new` übergebene Block


Auf das Scope-Objekt (die Klasse) kann wie folgt zugegriffen werden:

*   Über das Objekt, das an den `configure`-Block übergeben wird (`configure {
    |c| ... }`).
*   `settings` aus den anderen Scopes heraus.


### Anfrage- oder Instanz-Scope

Für jede eingehende Anfrage wird eine neue Instanz der Anwendungs-Klasse
erstellt und alle Handler in diesem Scope ausgeführt. Aus diesem Scope heraus
kann auf `request` oder `session` zugegriffen und Methoden wie `erb` oder
`haml` aufgerufen werden. Außerdem kann mit der `settings`-Method auf den
Anwendungs-Scope zugegriffen werden:

```ruby
class MyApp < Sinatra::Base
  # Hey, ich bin im Anwendungs-Scope!
  get '/neue_route/:name' do
    # Anfrage-Scope für '/neue_route/:name'
    @value = 42

    settings.get "/#{params['name']}" do
      # Anfrage-Scope für "/#{params['name']}"
      @value # => nil (nicht dieselbe Anfrage)
    end

    "Route definiert!"
  end
end
```

Im Anfrage-Scope befindet man sich:

*   In get, head, post, put, delete, options, patch, link und unlink Blöcken
*   In before und after Filtern
*   In Helfer-Methoden
*   In Templates


### Delegation-Scope

Vom Delegation-Scope aus werden Methoden einfach an den Klassen-Scope
weitergeleitet. Dieser verhält sich jedoch nicht 100%ig wie der Klassen-Scope,
da man nicht die Bindung der Klasse besitzt: Nur Methoden, die explizit als
delegierbar markiert wurden, stehen hier zur Verfügung und es kann nicht auf
die Variablen des Klassenscopes zugegriffen werden (mit anderen Worten: es
gibt ein anderes `self`). Weitere Delegationen können mit
`Sinatra::Delegator.delegate :methoden_name` hinzugefügt werden.

Im Delegation-Scop befindet man sich:

*   Im Top-Level, wenn `require 'sinatra'` aufgerufen wurde.
*   In einem Objekt, das mit dem `Sinatra::Delegator`-Mixin erweitert wurde.


Schau am besten im Code nach: Hier ist [Sinatra::Delegator
mixin](http://github.com/sinatra/sinatra/blob/master/lib/sinatra/base.rb#L1064
) definiert und wird in den [globalen Namespace
eingebunden](http://github.com/sinatra/sinatra/blob/master/lib/sinatra/main.rb

## Kommandozeile

Sinatra-Anwendungen können direkt von der Kommandozeile aus gestartet werden:

```shell
ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-h HOST] [-s HANDLER]
```

Die Optionen sind:

```
-h # Hilfe
-p # Port setzen (Standard ist 4567)
-h # Host setzen (Standard ist 0.0.0.0)
-e # Umgebung setzen (Standard ist development)
-s # Rack-Server/Handler setzen (Standard ist thin)
-x # Mutex-Lock einschalten (Standard ist off)
```

## Systemanforderungen

Die folgenden Versionen werden offiziell unterstützt:

<dl>
<dt>Ruby 1.8.7</dt>
<dd>1.8.7 wird vollständig unterstützt, ein Wechsel zu JRuby oder Rubinius wird
aber empfohlen. Ruby 1.8.7 wird noch bis Sinatra 2.0 unterstützt werden. Frühere
Versionen von Ruby sind nicht kompatibel mit Sinatra.</dd>

<dt>Ruby 1.9.2</dt>
<dd>1.9.2 wird mindestens bis Sinatra 1.5 voll unterstützt. Version 1.9.2p0
sollte nicht verwendet werden, da unter Sinatra immer wieder Segfaults
auftreten.</dd>

<dt>Ruby 1.9.3</dt>
<dd>1.9.3 wird vollständig unterstützt und empfohlen. Achtung, bei einem
Upgrade von einer früheren Version von Ruby zu Ruby 1.9.3 werden alle Sessions
ungültig. Ruby 1.9.3 wird bis Sinatra 2.0 unterstützt werden.</dd>

<dt>Ruby 2.x</dt>
<dd>2.x wird vollständig unterstützt.</dd>

<dt>Rubinius</dt>
<dd>Rubinius (Version >= 2.x) wird offiziell unterstützt. Es wird empfohlen, den
<a href="http://puma.io">Puma Server</a> zu installieren (<tt>gem install puma
</tt>)</dd>

<dt>JRuby</dt>
<dd>Aktuelle JRuby Versionen werden offiziell unterstützt. Es wird empfohlen,
keine C-Erweiterungen zu verwenden und als Server Trinidad zu verwenden
(<tt>gem install trinidad</tt>).</dd>
</dl>

Die nachfolgend aufgeführten Ruby-Implementierungen werden offiziell nicht von
Sinatra unterstützt, funktionieren aber normalerweise:

*   Ruby Enterprise Edition
*   Ältere Versionen von JRuby und Rubinius
*   MacRuby (<tt>gem install control_tower</tt> wird empfohlen), Maglev, IronRuby
*   Ruby 1.9.0 und 1.9.1

Nicht offiziell unterstützt bedeutet, dass wenn Sachen nicht funktionieren,
wir davon ausgehen, dass es nicht an Sinatra sondern an der jeweiligen
Implementierung liegt.

Im Rahmen unserer CI (Kontinuierlichen Integration) wird bereits ruby-head
(zukünftige Versionen von MRI) mit eingebunden. Es kann davon ausgegangen
werden, dass Sinatra MRI auch weiterhin vollständig unterstützen wird.

Sinatra sollte auf jedem Betriebssystem laufen, dass einen funktionierenden
Ruby-Interpreter aufweist.

Sinatra läuft aktuell nicht unter Cardinal, SmallRuby, BlueRuby oder Ruby <= 1.8.7.

## Der neuste Stand (The Bleeding Edge)

Um auf dem neusten Stand zu bleiben, kann der Master-Branch verwendet werden.
Er sollte recht stabil sein. Ebenso gibt es von Zeit zu Zeit prerelease Gems,
die so installiert werden:

```shell
gem install sinatra --pre
```

### Mit Bundler

Wenn die Applikation mit der neuesten Version von Sinatra und
[Bundler](http://gembundler.com/) genutzt werden soll, empfehlen wir den
nachfolgenden Weg.

Soweit Bundler noch nicht installiert ist:

```shell
gem install bundler
```

Anschließend wird eine `Gemfile`-Datei im Projektverzeichnis mit folgendem
Inhalt erstellt:

```ruby
source :rubygems
gem 'sinatra', :git => "git://github.com/sinatra/sinatra.git"

# evtl. andere Abhängigkeiten
gem 'haml'                    # z.B. wenn du Haml verwendest...
gem 'activerecord', '~> 3.0'  # ...oder ActiveRecord 3.x
```

Beachte: Hier sollten alle Abhängigkeiten eingetragen werden. Sinatras eigene,
direkte Abhängigkeiten (Tilt und Rack) werden von Bundler automatisch aus dem
Gemfile von Sinatra hinzugefügt.

Jetzt kannst du deine Applikation starten:

```shell
bundle exec ruby myapp.rb
```

### Eigenes Repository
Um auf dem neuesten Stand von Sinatras Code zu sein, kann eine lokale Kopie
angelegt werden. Gestartet wird in der Anwendung mit dem `sinatra/lib`-Ordner
im `LOAD_PATH`:

```shell
cd myapp
git clone git://github.com/sinatra/sinatra.git
ruby -Isinatra/lib myapp.rb
```

Alternativ kann der `sinatra/lib`-Ordner zum `LOAD_PATH` in der Anwendung
hinzugefügt werden:

```ruby
$LOAD_PATH.unshift File.dirname(__FILE__) + '/sinatra/lib'
require 'rubygems'
require 'sinatra'

get '/ueber' do
  "Ich laufe auf Version " + Sinatra::VERSION
end
```

Um Sinatra-Code von Zeit zu Zeit zu aktualisieren:

```shell
cd myproject/sinatra
git pull
```

### Gem erstellen

Aus der eigenen lokalen Kopie kann nun auch ein globales Gem gebaut werden:

```shell
git clone git://github.com/sinatra/sinatra.git
cd sinatra
rake sinatra.gemspec
rake install
```

Falls Gems als Root installiert werden sollen, sollte die letzte Zeile
folgendermaßen lauten:

```shell
sudo rake install
```

## Versions-Verfahren

Sinatra folgt dem sogenannten [Semantic Versioning](http://semver.org/), d.h.
SemVer und SemVerTag.

## Mehr

*   [Projekt-Website](http://sinatra.github.com/) - Ergänzende Dokumentation,
    News und Links zu anderen Ressourcen.
*   [Mitmachen](http://sinatra.github.com/contributing.html) - Einen Fehler
    gefunden? Brauchst du Hilfe? Hast du einen Patch?
*   [Issue-Tracker](http://github.com/sinatra/sinatra/issues)
*   [Twitter](http://twitter.com/sinatra)
*   [Mailing-Liste](http://groups.google.com/group/sinatrarb)
*   [#sinatra](irc://chat.freenode.net/#sinatra) auf http://freenode.net Es
    gibt dort auch immer wieder deutschsprachige Entwickler, die gerne weiterhelfen.
*   [Sinatra Book](https://github.com/sinatra/sinatra-book/) Kochbuch Tutorial
*   [Sinatra Recipes](http://recipes.sinatrarb.com/) Sinatra-Rezepte aus der
    Community
*   API Dokumentation für die [aktuelle
    Version](http://rubydoc.info/gems/sinatra) oder für
    [HEAD](http://rubydoc.info/github/sinatra/sinatra) auf http://rubydoc.info
*   [CI Server](http://travis-ci.org/sinatra/sinatra)
# Sinatra

*注）
本文書は英語から翻訳したものであり、その内容が最新でない場合もあります。最新の情報はオリジナルの英語版を参照して下さい。*

Sinatraは最小の労力でRubyによるWebアプリケーションを手早く作るための[DSL](http://ja.wikipedia.org/wiki/ドメイン固有言語)です。

``` ruby
# myapp.rb
require 'sinatra'

get '/' do
  'Hello world!'
end
```

gemをインストールし、

``` shell
gem install sinatra
```

次のように実行します。

``` shell
ruby myapp.rb
```

[localhost:4567](http://localhost:4567) を開きます。

ThinがあればSinatraはこれを利用するので、`gem install thin`することをお薦めします。

## 目次

* [Sinatra](#sinatra)
    * [目次](#目次)
    * [ルーティング(Routes)](#ルーティングroutes)
    * [条件(Conditions)](#条件conditions)
    * [戻り値(Return Values)](#戻り値return-values)
    * [カスタムルーティングマッチャー(Custom Route Matchers)](#カスタムルーティングマッチャーcustom-route-matchers)
    * [静的ファイル(Static Files)](#静的ファイルstatic-files)
    * [ビュー / テンプレート(Views / Templates)](#ビュー--テンプレートviews--templates)
        * [リテラルテンプレート(Literal Templates)](#リテラルテンプレートliteral-templates)
        * [利用可能なテンプレート言語](#利用可能なテンプレート言語)
            * [Haml テンプレート](#haml-テンプレート)
            * [Erb テンプレート](#erb-テンプレート)
            * [Builder テンプレート](#builder-テンプレート)
            * [Nokogiri テンプレート](#nokogiri-テンプレート)
            * [Sass テンプレート](#sass-テンプレート)
            * [SCSS テンプレート](#scss-テンプレート)
            * [Less テンプレート](#less-テンプレート)
            * [Liquid テンプレート](#liquid-テンプレート)
            * [Markdown テンプレート](#markdown-テンプレート)
            * [Textile テンプレート](#textile-テンプレート)
            * [RDoc テンプレート](#rdoc-テンプレート)
            * [AsciiDoc テンプレート](#asciidoc-テンプレート)
            * [Radius テンプレート](#radius-テンプレート)
            * [Markaby テンプレート](#markaby-テンプレート)
            * [RABL テンプレート](#rabl-テンプレート)
            * [Slim テンプレート](#slim-テンプレート)
            * [Creole テンプレート](#creole-テンプレート)
            * [MediaWiki テンプレート](#mediawiki-テンプレート)
            * [CoffeeScript テンプレート](#coffeescript-テンプレート)
            * [Stylus テンプレート](#stylus-テンプレート)
            * [Yajl テンプレート](#yajl-テンプレート)
            * [WLang テンプレート](#wlang-テンプレート)
        * [テンプレート内での変数へのアクセス](#テンプレート内での変数へのアクセス)
        * [`yield`を伴うテンプレートとネストしたレイアウト](#yieldを伴うテンプレートとネストしたレイアウト)
        * [インラインテンプレート(Inline Templates)](#インラインテンプレートinline-templates)
        * [名前付きテンプレート(Named Templates)](#名前付きテンプレートnamed-templates)
        * [ファイル拡張子の関連付け](#ファイル拡張子の関連付け)
        * [オリジナルテンプレートエンジンの追加](#オリジナルテンプレートエンジンの追加)
    * [フィルタ(Filters)](#フィルタfilters)
    * [ヘルパー(Helpers)](#ヘルパーhelpers)
        * [セッションの使用](#セッションの使用)
        * [停止(Halting)](#停止halting)
        * [パッシング(Passing)](#パッシングpassing)
        * [別ルーティングの誘発](#別ルーティングの誘発)
        * [ボディ、ステータスコードおよびヘッダの設定](#ボディステータスコードおよびヘッダの設定)
        * [ストリーミングレスポンス(Streaming Responses)](#ストリーミングレスポンスstreaming-responses)
        * [ロギング(Logging)](#ロギングlogging)
        * [MIMEタイプ(Mime Types)](#mimeタイプmime-types)
        * [URLの生成](#urlの生成)
        * [ブラウザリダイレクト(Browser Redirect)](#ブラウザリダイレクトbrowser-redirect)
        * [キャッシュ制御(Cache Control)](#キャッシュ制御cache-control)
        * [ファイルの送信](#ファイルの送信)
        * [リクエストオブジェクトへのアクセス](#リクエストオブジェクトへのアクセス)
        * [アタッチメント(Attachments)](#アタッチメントattachments)
        * [日付と時刻の取り扱い](#日付と時刻の取り扱い)
        * [テンプレートファイルの探索](#テンプレートファイルの探索)
    * [コンフィギュレーション(Configuration)](#コンフィギュレーションconfiguration)
        * [攻撃防御に対する設定](#攻撃防御に対する設定)
        * [利用可能な設定](#利用可能な設定)
    * [環境設定(Environments)](#環境設定environments)
    * [エラーハンドリング(Error Handling)](#エラーハンドリングerror-handling)
        * [Not Found](#not-found)
        * [エラー(Error)](#エラーerror)
    * [Rackミドルウェア(Rack Middleware)](#rackミドルウェアrack-middleware)
    * [テスト(Testing)](#テストtesting)
    * [Sinatra::Base - ミドルウェア、ライブラリおよびモジュラーアプリ](#sinatrabase---ミドルウェアライブラリおよびモジュラーアプリ)
        * [モジュラースタイル vs クラッシックスタイル](#モジュラースタイル-vs-クラッシックスタイル)
        * [モジュラーアプリケーションの提供](#モジュラーアプリケーションの提供)
        * [config.ruを用いたクラッシックスタイルアプリケーションの使用](#configruを用いたクラッシックスタイルアプリケーションの使用)
        * [config.ruはいつ使うのか？](#configruはいつ使うのか)
        * [Sinatraのミドルウェアとしての利用](#sinatraのミドルウェアとしての利用)
        * [動的なアプリケーションの生成](#動的なアプリケーションの生成)
    * [スコープとバインディング(Scopes and Binding)](#スコープとバインディングscopes-and-binding)
        * [アプリケーション/クラスのスコープ](#アプリケーションクラスのスコープ)
        * [リクエスト/インスタンスのスコープ](#リクエストインスタンスのスコープ)
        * [デリゲートスコープ](#デリゲートスコープ)
    * [コマンドライン](#コマンドライン)
    * [必要環境](#必要環境)
    * [最新開発版](#最新開発版)
        * [Bundlerを使う場合](#bundlerを使う場合)
        * [直接組み込む場合](#直接組み込む場合)
        * [グローバル環境にインストールする場合](#グローバル環境にインストールする場合)
    * [バージョニング(Versioning)](#バージョニングversioning)
    * [参考文献](#参考文献)

## ルーティング(Routes)

Sinatraでは、ルーティングはHTTPメソッドとURLマッチングパターンがペアになっています。
ルーティングはブロックに結び付けられています。

``` ruby
get '/' do
  .. 何か見せる ..
end

post '/' do
  .. 何か生成する ..
end

put '/' do
  .. 何か更新する ..
end

patch '/' do
  .. 何か修正する ..
end

delete '/' do
  .. 何か削除する ..
end

options '/' do
  .. 何か満たす ..
end

link '/' do
  .. 何かリンクを張る ..
end

unlink '/' do
  .. 何かアンリンクする ..
end
```

ルーティングは定義された順番にマッチします。
リクエストに最初にマッチしたルーティングが呼び出されます。

ルーティングのパターンは名前付きパラメータを含むことができ、
`params`ハッシュで取得できます。

``` ruby
get '/hello/:name' do
  # "GET /hello/foo" と "GET /hello/bar" にマッチ
  # params['name'] は 'foo' か 'bar'
  "Hello #{params['name']}!"
end
```

また、ブロックパラメータで名前付きパラメータにアクセスすることもできます。

``` ruby
get '/hello/:name' do |n|
  # "GET /hello/foo" と "GET /hello/bar" にマッチ
  # params['name'] は 'foo' か 'bar'
  # n が params['name'] を保持
  "Hello #{n}!"
end
```

ルーティングパターンはアスタリスク(すなわちワイルドカード)を含むこともでき、
`params['splat']` で取得できます。

``` ruby
get '/say/*/to/*' do
  # /say/hello/to/world にマッチ
  params['splat'] # => ["hello", "world"]
end

get '/download/*.*' do
  # /download/path/to/file.xml にマッチ
  params['splat'] # => ["path/to/file", "xml"]
end
```

ここで、ブロックパラメータを使うこともできます。

``` ruby
get '/download/*.*' do |path, ext|
  [path, ext] # => ["path/to/file", "xml"]
end
```

ルーティングを正規表現にマッチさせることもできます。

``` ruby
get /\A\/hello\/([\w]+)\z/ do
  "Hello, #{params['captures'].first}!"
end
```

ここでも、ブロックパラメータが使えます。

``` ruby
get %r{/hello/([\w]+)} do |c|
  "Hello, #{c}!"
end
```

ルーティングパターンは、オプショナルパラメータを取ることもできます。

``` ruby
get '/posts.?:format?' do
  # "GET /posts" と "GET /posts.json", "GET /posts.xml" の拡張子などにマッチ
end
```

ところで、ディレクトリトラバーサル攻撃防御設定を無効にしないと（下記参照）、
ルーティングにマッチする前にリクエストパスが修正される可能性があります。

## 条件(Conditions)

ルーティングにはユーザエージェントのようなさまざまな条件を含めることができます。

``` ruby
get '/foo', :agent => /Songbird (\d\.\d)[\d\/]*?/ do
  "Songbirdのバージョン #{params['agent'][0]}を使ってます。"
end

get '/foo' do
  # Songbird以外のブラウザにマッチ
end
```

ほかに`host_name`と`provides`条件が利用可能です。

``` ruby
get '/', :host_name => /^admin\./ do
  "Adminエリアです。アクセスを拒否します!"
end

get '/', :provides => 'html' do
  haml :index
end

get '/', :provides => ['rss', 'atom', 'xml'] do
  builder :feed
end
```

独自の条件を定義することも簡単にできます。

``` ruby
set(:probability) { |value| condition { rand <= value } }

get '/win_a_car', :probability => 0.1 do
  "あなたの勝ちです!"
end

get '/win_a_car' do
  "残念、あなたの負けです。"
end
```

複数の値を取る条件には、アスタリスクを使います。

``` ruby
set(:auth) do |*roles|   # <- ここでアスタリスクを使う
  condition do
    unless logged_in? && roles.any? {|role| current_user.in_role? role }
      redirect "/login/", 303
    end
  end
end

get "/my/account/", :auth => [:user, :admin] do
  "アカウントの詳細"
end

get "/only/admin/", :auth => :admin do
  "ここは管理者だけ!"
end
```

## 戻り値(Return Values)

ルーティングブロックの戻り値は、HTTPクライアントまたはRackスタックでの次のミドルウェアに渡されるレスポンスボディを決定します。

これは大抵の場合、上の例のように文字列ですが、それ以外の値も使用することができます。

Rackレスポンス、Rackボディオブジェクト、HTTPステータスコードのいずれかとして妥当なオブジェクトであればどのようなオブジェクトでも返すことができます。

* 3つの要素を含む配列:
  `[ステータス(Fixnum), ヘッダ(Hash), レスポンスボディ(#eachに応答する)]`
* 2つの要素を含む配列:
  `[ステータス(Fixnum), レスポンスボディ(#eachに応答する)]`
* `#each`に応答するオブジェクト。通常はそのまま何も返さないが、
与えられたブロックに文字列を渡す。
* ステータスコードを表現する整数(Fixnum)

これにより、例えばストリーミングを簡単に実装することができます。

``` ruby
class Stream
  def each
    100.times { |i| yield "#{i}\n" }
  end
end

get('/') { Stream.new }
```

後述する`stream`ヘルパーメソッドを使って、定型パターンを減らしつつストリーミングロジックをルーティングに埋め込むこともできます。

## カスタムルーティングマッチャー(Custom Route Matchers)

先述のようにSinatraはルーティングマッチャーとして、文字列パターンと正規表現を使うことをビルトインでサポートしています。しかしこれに留まらず、独自のマッチャーを簡単に定義することもできるのです。

``` ruby
class AllButPattern
  Match = Struct.new(:captures)

  def initialize(except)
    @except   = except
    @captures = Match.new([])
  end

  def match(str)
    @captures unless @except === str
  end
end

def all_but(pattern)
  AllButPattern.new(pattern)
end

get all_but("/index") do
  # ...
end
```

ノート: この例はオーバースペックであり、以下のようにも書くことができます。

``` ruby
get // do
  pass if request.path_info == "/index"
  # ...
end
```

または、否定先読みを使って:

``` ruby
get %r{^(?!/index$)} do
  # ...
end
```


## 静的ファイル(Static Files)

静的ファイルは`./public`ディレクトリから配信されます。
`:public_folder`オプションを指定することで別の場所を指定することができます。

``` ruby
set :public_folder, File.dirname(__FILE__) + '/static'
```

ノート: この静的ファイル用のディレクトリ名はURL中に含まれません。
例えば、`./public/css/style.css`は`http://example.com/css/style.css`でアクセスできます。

`Cache-Control`の設定をヘッダーへ追加するには`:static_cache_control`の設定(下記参照)を加えてください。

## ビュー / テンプレート(Views / Templates)

各テンプレート言語はそれ自身のレンダリングメソッドを通して展開されます。それらのメソッドは単に文字列を返します。

``` ruby
get '/' do
  erb :index
end
```

これは、`views/index.erb`をレンダリングします。

テンプレート名を渡す代わりに、直接そのテンプレートの中身を渡すこともできます。

``` ruby
get '/' do
  code = "<%= Time.now %>"
  erb code
end
```

テンプレートのレイアウトは第２引数のハッシュ形式のオプションをもとに表示されます。

``` ruby
get '/' do
  erb :index, :layout => :post
end
```

これは、`views/post.erb`内に埋め込まれた`views/index.erb`をレンダリングします（デフォルトは`views/layout.erb`があればそれになります）。

Sinatraが理解できないオプションは、テンプレートエンジンに渡されることになります。


``` ruby
get '/' do
  haml :index, :format => :html5
end
```

テンプレート言語ごとにオプションをセットすることもできます。

``` ruby
set :haml, :format => :html5

get '/' do
  haml :index
end
```

レンダリングメソッドに渡されたオプションは`set`で設定されたオプションを上書きします。

利用可能なオプション:

<dl>
  <dt>locals</dt>
  <dd>
    ドキュメントに渡されるローカルのリスト。パーシャルに便利。
    例: <tt>erb "<%= foo %>", :locals => {:foo => "bar"}</tt>
  </dd>

  <dt>default_encoding</dt>
  <dd>
    文字エンコーディング（不確かな場合に使用される）。デフォルトは、<tt>settings.default_encoding</tt>。
  </dd>

  <dt>views</dt>
  <dd>
    テンプレートを読み出すビューのディレクトリ。デフォルトは、<tt>settings.views</tt>。
  </dd>

  <dt>layout</dt>
  <dd>
    レイアウトを使うかの指定(<tt>true</tt> または <tt>false</tt>)。値がシンボルの場合は、使用するテンプレートが指定される。例: <tt>erb :index, :layout => !request.xhr?</tt>
  </dd>

  <dt>content_type</dt>
  <dd>
    テンプレートが生成するContent-Type。デフォルトはテンプレート言語ごとに異なる。
  </dd>

  <dt>scope</dt>
  <dd>
    テンプレートをレンダリングするときのスコープ。デフォルトは、アプリケーションのインスタンス。これを変更した場合、インスタンス変数およびヘルパーメソッドが利用できなくなる。
  </dd>

  <dt>layout_engine</dt>
  <dd>
    レイアウトをレンダリングするために使用するテンプレートエンジン。レイアウトをサポートしない言語で有用。デフォルトはテンプレートに使われるエンジン。例: <tt>set :rdoc, :layout_engine => :erb</tt>
  </dd>

  <dt>layout_options</dt>
  <dd>
    レイアウトをレンダリングするときだけに使う特別なオプション。例:
    <tt>set :rdoc, :layout_options => { :views => 'views/layouts' }</tt>
  </dd>
</dl>

テンプレートは`./views`ディレクトリ下に配置されています。
他のディレクトリを使用する場合の例:

``` ruby
set :views, settings.root + '/templates'
```

テンプレートはシンボルを使用して参照させることを覚えておいて下さい。
サブディレクトリでもこの場合は`:'subdir/template'`のようにします。
レンダリングメソッドは文字列が渡されると、それをそのまま文字列として出力するので、シンボルを使ってください。

### リテラルテンプレート(Literal Templates)

``` ruby
get '/' do
  haml '%div.title Hello World'
end
```

これはそのテンプレート文字列をレンダリングします。

### 利用可能なテンプレート言語

いくつかの言語には複数の実装があります。使用する（そしてスレッドセーフにする）実装を指定するには、それを最初にrequireしてください。


``` ruby
require 'rdiscount' # または require 'bluecloth'
get('/') { markdown :index }
```

#### Haml テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="http://haml.info/" title="haml">haml</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.haml</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>haml :index, :format => :html5</tt></td>
  </tr>
</table>


#### Erb テンプレート

<table>
  <tr>
    <td>依存</td>
    <td>
      <a href="http://www.kuwata-lab.com/erubis/" title="erubis">erubis</a>
      または erb (Rubyに同梱)
    </td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.erb</tt>, <tt>.rhtml</tt> or <tt>.erubis</tt> (Erubisだけ)</td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>erb :index</tt></td>
  </tr>
</table>

#### Builder テンプレート

<table>
  <tr>
    <td>依存</td>
    <td>
      <a href="https://github.com/jimweirich/builder" title="builder">builder</a>
    </td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.builder</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>builder { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

インラインテンプレート用にブロックを取ることもできます（例を参照）。

#### Nokogiri テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="http://nokogiri.org/" title="nokogiri">nokogiri</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.nokogiri</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>nokogiri { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

インラインテンプレート用にブロックを取ることもできます（例を参照）。


#### Sass テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.sass</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>sass :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>


#### Scss テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.scss</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>scss :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>

#### Less テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="http://www.lesscss.org/" title="less">less</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.less</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>less :stylesheet</tt></td>
  </tr>
</table>

#### Liquid テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="http://www.liquidmarkup.org/" title="liquid">liquid</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.liquid</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>liquid :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

LiquidテンプレートからRubyのメソッド(`yield`を除く)を呼び出すことができないため、ほぼ全ての場合にlocalsを指定する必要があるでしょう。

#### Markdown テンプレート

<table>
  <tr>
    <td>依存</td>
    <td>
      次の何れか:
        <a href="https://github.com/rtomayko/rdiscount" title="RDiscount">RDiscount</a>,
        <a href="https://github.com/vmg/redcarpet" title="RedCarpet">RedCarpet</a>,
        <a href="http://deveiate.org/projects/BlueCloth" title="BlueCloth">BlueCloth</a>,
        <a href="http://kramdown.gettalong.org/" title="kramdown">kramdown</a>,
        <a href="https://github.com/bhollis/maruku" title="maruku">maruku</a>
    </td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.markdown</tt>, <tt>.mkd</tt> and <tt>.md</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>markdown :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

Markdownからメソッドを呼び出すことも、localsに変数を渡すこともできません。
それゆえ、他のレンダリングエンジンとの組み合わせで使うのが普通です。

``` ruby
erb :overview, :locals => { :text => markdown(:introduction) }
```

ノート: 他のテンプレート内で`markdown`メソッドを呼び出せます。

``` ruby
%h1 Hello From Haml!
%p= markdown(:greetings)
```

MarkdownからはRubyを呼ぶことができないので、Markdownで書かれたレイアウトを使うことはできません。しかしながら、`:layout_engine`オプションを渡すことでテンプレートのものとは異なるレンダリングエンジンをレイアウトのために使うことができます。


#### Textile テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="http://redcloth.org/" title="RedCloth">RedCloth</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.textile</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>textile :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

Textileからメソッドを呼び出すことも、localsに変数を渡すこともできません。
それゆえ、他のレンダリングエンジンとの組み合わせで使うのが普通です。

``` ruby
erb :overview, :locals => { :text => textile(:introduction) }
```

ノート: 他のテンプレート内で`textile`メソッドを呼び出せます。

``` ruby
%h1 Hello From Haml!
%p= textile(:greetings)
```

TexttileからはRubyを呼ぶことができないので、Textileで書かれたレイアウトを使うことはできません。しかしながら、`:layout_engine`オプションを渡すことでテンプレートのものとは異なるレンダリングエンジンをレイアウトのために使うことができます。

#### RDoc テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="http://rdoc.sourceforge.net/" title="RDoc">RDoc</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.rdoc</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>rdoc :README, :layout_engine => :erb</tt></td>
  </tr>
</table>

RDocからメソッドを呼び出すことも、localsに変数を渡すこともできません。
それゆえ、他のレンダリングエンジンとの組み合わせで使うのが普通です。

``` ruby
erb :overview, :locals => { :text => rdoc(:introduction) }
```

ノート: 他のテンプレート内で`rdoc`メソッドを呼び出せます。


``` ruby
%h1 Hello From Haml!
%p= rdoc(:greetings)
```

RDocからはRubyを呼ぶことができないので、RDocで書かれたレイアウトを使うことはできません。しかしながら、`:layout_engine`オプションを渡すことでテンプレートのものとは異なるレンダリングエンジンをレイアウトのために使うことができます。

#### AsciiDoc テンプレート

<table>
 <tr>
   <td>依存</td>
   <td><a href="http://asciidoctor.org/" title="Asciidoctor">Asciidoctor</a></td>
 </tr>
 <tr>
   <td>ファイル拡張子</td>
   <td><tt>.asciidoc</tt>, <tt>.adoc</tt> and <tt>.ad</tt></td>
 </tr>
 <tr>
   <td>例</td>
   <td><tt>asciidoc :README, :layout_engine => :erb</tt></td>
 </tr>
</table>

AsciiDocテンプレートからRubyのメソッドを直接呼び出すことができないため、ほぼ全ての場合にlocalsを指定する必要があるでしょう。

#### Radius テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="https://github.com/jlong/radius" title="Radius">Radius</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.radius</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>radius :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

RadiusテンプレートからRubyのメソッドを直接呼び出すことができないため、ほぼ全ての場合にlocalsを指定する必要があるでしょう。


#### Markaby テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="http://markaby.github.com/" title="Markaby">Markaby</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.mab</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>markaby { h1 "Welcome!" }</tt></td>
  </tr>
</table>

インラインテンプレート用にブロックを取ることもできます（例を参照）。

#### RABL テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="https://github.com/nesquena/rabl" title="Rabl">Rabl</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.rabl</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>rabl :index</tt></td>
  </tr>
</table>

#### Slim テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="http://slim-lang.com/" title="Slim Lang">Slim Lang</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.slim</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>slim :index</tt></td>
  </tr>
</table>

#### Creole テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="https://github.com/minad/creole" title="Creole">Creole</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.creole</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>creole :wiki, :layout_engine => :erb</tt></td>
  </tr>
</table>

Creoleからメソッドを呼び出すことも、localsに変数を渡すこともできません。
それゆえ、他のレンダリングエンジンとの組み合わせで使うのが普通です。

``` ruby
erb :overview, :locals => { :text => creole(:introduction) }
```

ノート: 他のテンプレート内で`creole`メソッドを呼び出せます。

``` ruby
%h1 Hello From Haml!
%p= creole(:greetings)
```

CreoleからはRubyを呼ぶことができないので、Creoleで書かれたレイアウトを使うことはできません。しかしながら、`:layout_engine`オプションを渡すことでテンプレートのものとは異なるレンダリングエンジンをレイアウトのために使うことができます。

#### MediaWiki テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="https://github.com/nricciar/wikicloth" title="WikiCloth">WikiCloth</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.mediawiki</tt> および <tt>.mw</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>mediawiki :wiki, :layout_engine => :erb</tt></td>
  </tr>
</table>

MediaWikiのテンプレートは直接メソッドから呼び出したり、ローカル変数を通すことはできません。それゆえに、通常は別のレンダリングエンジンと組み合わせて利用します。

```ruby
erb :overview, :locals => { :text => mediawiki(:introduction) }
```

ノート: 他のテンプレートから部分的に`mediawiki`メソッドを呼び出すことも可能です。

#### CoffeeScript テンプレート

<table>
  <tr>
    <td>依存</td>
    <td>
      <a href="https://github.com/josh/ruby-coffee-script" title="Ruby CoffeeScript">
        CoffeeScript
      </a> および
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        JavaScriptの起動方法
      </a>
    </td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.coffee</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>coffee :index</tt></td>
  </tr>
</table>

#### Stylus テンプレート

<table>
  <tr>
    <td>依存</td>
    <td>
      <a href="https://github.com/lucasmazza/ruby-stylus" title="Ruby Stylus">
        Stylus
      </a> および
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        JavaScriptの起動方法
      </a>
    </td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.styl</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>stylus :index</tt></td>
  </tr>
</table>

Stylusテンプレートを使えるようにする前に、まず`stylus`と`stylus/tilt`を読み込む必要があります。

``` ruby
require 'sinatra'
require 'stylus'
require 'stylus/tilt'

get '/' do
  stylus :example
end
```

#### Yajl テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="https://github.com/brianmario/yajl-ruby" title="yajl-ruby">yajl-ruby</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.yajl</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td>
      <tt>
        yajl :index,
             :locals => { :key => 'qux' },
             :callback => 'present',
             :variable => 'resource'
      </tt>
    </td>
  </tr>
</table>


テンプレートのソースはRubyの文字列として評価され、その結果のJSON変数は`#to_json`を使って変換されます。

``` ruby
json = { :foo => 'bar' }
json[:baz] = key
```

`:callback`および`:variable`オプションは、レンダリングされたオブジェクトを装飾するために使うことができます。

``` ruby
var resource = {"foo":"bar","baz":"qux"}; present(resource);
```

#### WLang テンプレート

<table>
  <tr>
    <td>依存</td>
    <td><a href="https://github.com/blambeau/wlang/" title="wlang">wlang</a></td>
  </tr>
  <tr>
    <td>ファイル拡張子</td>
    <td><tt>.wlang</tt></td>
  </tr>
  <tr>
    <td>例</td>
    <td><tt>wlang :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

WLang内でのRubyメソッドの呼び出しは一般的ではないので、ほとんどの場合にlocalsを指定する必要があるでしょう。しかしながら、WLangで書かれたレイアウトは`yield`をサポートしています。

### テンプレート内での変数へのアクセス

テンプレートはルーティングハンドラと同じコンテキストの中で評価されます。ルーティングハンドラでセットされたインスタンス変数はテンプレート内で直接使うことができます。

``` ruby
get '/:id' do
  @foo = Foo.find(params['id'])
  haml '%h1= @foo.name'
end
```

また、ローカル変数のハッシュで明示的に指定することもできます。

``` ruby
get '/:id' do
  foo = Foo.find(params['id'])
  haml '%h1= bar.name', :locals => { :bar => foo }
end
```

このやり方は他のテンプレート内で部分テンプレートとして表示する時に典型的に使用されます。

### `yield`を伴うテンプレートとネストしたレイアウト

レイアウトは通常、`yield`を呼ぶ単なるテンプレートに過ぎません。
そのようなテンプレートは、既に説明した`:template`オプションを通して使われるか、または次のようなブロックを伴ってレンダリングされます。

``` ruby
erb :post, :layout => false do
  erb :index
end
```

このコードは、`erb :index, :layout => :post`とほぼ等価です。

レンダリングメソッドにブロックを渡すスタイルは、ネストしたレイアウトを作るために最も役立ちます。

``` ruby
erb :main_layout, :layout => false do
  erb :admin_layout do
    erb :user
  end
end
```

これはまた次のより短いコードでも達成できます。

``` ruby
erb :admin_layout, :layout => :main_layout do
  erb :user
end
```

現在、次のレンダリングメソッドがブロックを取れます: `erb`, `haml`,
`liquid`, `slim `, `wlang`。
また汎用の`render`メソッドもブロックを取れます。


### インラインテンプレート(Inline Templates)

テンプレートはソースファイルの最後で定義することもできます。

``` ruby
require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.title Hello world!!!!!
```

ノート: Sinatraをrequireするソースファイル内で定義されたインラインテンプレートは自動的に読み込まれます。他のソースファイル内にインラインテンプレートがある場合には`enable :inline_templates`を明示的に呼んでください。

### 名前付きテンプレート(Named Templates)

テンプレートはトップレベルの`template`メソッドで定義することもできます。

``` ruby
template :layout do
  "%html\n  =yield\n"
end

template :index do
  '%div.title Hello World!'
end

get '/' do
  haml :index
end
```

「layout」というテンプレートが存在する場合、そのテンプレートファイルは他のテンプレートがレンダリングされる度に使用されます。`:layout => false`で個別に、または`set :haml, :layout => false`でデフォルトとして、レイアウトを無効にすることができます。

``` ruby
get '/' do
  haml :index, :layout => !request.xhr?
end
```

### ファイル拡張子の関連付け

任意のテンプレートエンジンにファイル拡張子を関連付ける場合は、`Tilt.register`を使います。例えば、Textileテンプレートに`tt`というファイル拡張子を使いたい場合は、以下のようにします。

``` ruby
Tilt.register :tt, Tilt[:textile]
```

### オリジナルテンプレートエンジンの追加

まず、Tiltでそのエンジンを登録し、次にレンダリングメソッドを作ります。

``` ruby
Tilt.register :myat, MyAwesomeTemplateEngine

helpers do
  def myat(*args) render(:myat, *args) end
end

get '/' do
  myat :index
end
```

これは、`./views/index.myat`をレンダリングします。Tiltについての詳細は、https://github.com/rtomayko/tilt を参照してください。

## フィルタ(Filters)

beforeフィルタは、リクエストのルーティングと同じコンテキストで各リクエストの前に評価され、それによってリクエストとレスポンスを変更可能にします。フィルタ内でセットされたインスタンス変数はルーティングとテンプレートからアクセスすることができます。

``` ruby
before do
  @note = 'Hi!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @note #=> 'Hi!'
  params['splat'] #=> 'bar/baz'
end
```

afterフィルタは、リクエストのルーティングと同じコンテキストで各リクエストの後に評価され、それによってこれもリクエストとレスポンスを変更可能にします。beforeフィルタとルーティング内でセットされたインスタンス変数はafterフィルタからアクセスすることができます。

``` ruby
after do
  puts response.status
end
```

ノート: `body`メソッドを使わずにルーティングから文字列を返すだけの場合、その内容はafterフィルタでまだ利用できず、その後に生成されることになります。

フィルタにはオプションとしてパターンを渡すことができ、この場合はリクエストのパスがパターンにマッチした場合にのみフィルタが評価されるようになります。

``` ruby
before '/protected/*' do
  authenticate!
end

after '/create/:slug' do |slug|
  session[:last_slug] = slug
end
```

ルーティング同様、フィルタもまた条件を取ることができます。

``` ruby
before :agent => /Songbird/ do
  # ...
end

after '/blog/*', :host_name => 'example.com' do
  # ...
end
```

## ヘルパー(Helpers)

トップレベルの`helpers`メソッドを使用してルーティングハンドラやテンプレートで使うヘルパーメソッドを定義できます。

``` ruby
helpers do
  def bar(name)
    "#{name}bar"
  end
end

get '/:name' do
  bar(params['name'])
end
```

あるいは、ヘルパーメソッドをモジュール内で個別に定義することもできます。

``` ruby
module FooUtils
  def foo(name) "#{name}foo" end
end

module BarUtils
  def bar(name) "#{name}bar" end
end

helpers FooUtils, BarUtils
```

その効果は、アプリケーションクラスにモジュールをインクルードするのと同じです。


### セッションの使用

セッションはリクエスト間での状態維持のために使用されます。その起動により、ユーザセッションごとに一つのセッションハッシュが与えられます。

``` ruby
enable :sessions

get '/' do
  "value = " << session[:value].inspect
end

get '/:value' do
  session[:value] = params['value']
end
```

ノート: `enable :sessions`は実際にはすべてのデータをクッキーに保持します。これは必ずしも期待通りのものにならないかもしれません（例えば、大量のデータを保持することでトラフィックが増大するなど）。Rackセッションミドルウェアの利用が可能であり、その場合は`enable :sessions`を呼ばずに、選択したミドルウェアを他のミドルウェアのときと同じようにして取り込んでください。

``` ruby
use Rack::Session::Pool, :expire_after => 2592000

get '/' do
  "value = " << session[:value].inspect
end

get '/:value' do
  session[:value] = params['value']
end
```

セキュリティ向上のため、クッキー内のセッションデータはセッション秘密鍵(session secret)で署名されます。Sinatraによりランダムな秘密鍵が個別に生成されます。しかし、この秘密鍵はアプリケーションの立ち上げごとに変わってしまうので、すべてのアプリケーションのインスタンスで共有できる秘密鍵をセットしたくなるかもしれません。

``` ruby
set :session_secret, 'super secret'
```

更に、設定変更をしたい場合は、`sessions`の設定においてオプションハッシュを保持することもできます。

``` ruby
set :sessions, :domain => 'foo.com'
```

foo.comのサブドメイン上のアプリ間でセッションを共有化したいときは、代わりにドメインの前に *.* を付けます。

``` ruby
set :sessions, :domain => '.foo.com'
```

### 停止(Halting)

フィルタまたはルーティング内で直ちにリクエストを止める場合

``` ruby
halt
```

この際、ステータスを指定することもできます。

``` ruby
halt 410
```

body部を指定することも、

``` ruby
halt 'ここにbodyを書く'
```

ステータスとbody部を指定することも、

``` ruby
halt 401, '立ち去れ!'
```

ヘッダを付けることもできます。

``` ruby
halt 402, {'Content-Type' => 'text/plain'}, 'リベンジ'
```

もちろん、テンプレートを`halt`に結びつけることも可能です。

``` ruby
halt erb(:error)
```

### パッシング(Passing)

ルーティングは`pass`を使って次のルーティングに飛ばすことができます。

``` ruby
get '/guess/:who' do
  pass unless params['who'] == 'Frank'
  "見つかっちゃった!"
end

get '/guess/*' do
  "はずれです!"
end
```

ルーティングブロックからすぐに抜け出し、次にマッチするルーティングを実行します。マッチするルーティングが見当たらない場合は404が返されます。

### 別ルーティングの誘発

`pass`を使ってルーティングを飛ばすのではなく、他のルーティングを呼んだ結果を得たいというときがあります。これを実現するには`call`を使えばいいです。

``` ruby
get '/foo' do
  status, headers, body = call env.merge("PATH_INFO" => '/bar')
  [status, headers, body.map(&:upcase)]
end

get '/bar' do
  "bar"
end
```

ノート: 先の例において、テストを楽にしパフォーマンスを改善するには、`"bar"`を単にヘルパーに移し、`/foo`および`/bar`から使えるようにするのがいいです。

リクエストが、その複製物でない同じアプリケーションのインスタンスに送られるようにしたいときは、`call`に代えて`call!`を使ってください。

`call`についての詳細はRackの仕様書を参照してください。


### ボディ、ステータスコードおよびヘッダの設定

ステータスコードおよびレスポンスボディを、ルーティングブロックの戻り値にセットすることが可能であり、これは推奨されています。しかし、あるケースでは実行フローの任意のタイミングでボディをセットしたくなるかもしれません。`body`ヘルパーメソッドを使えばそれができます。そうすると、それ以降、ボディにアクセスするためにそのメソッドを使うことができるようになります。

``` ruby
get '/foo' do
  body "bar"
end

after do
  puts body
end
```

また、`body`にはブロックを渡すことができ、これはRackハンドラにより実行されることになります(これはストリーミングを実装するのに使われます。"戻り値"の項を参照してください。)

ボディと同様に、ステータスコードおよびヘッダもセットできます。

``` ruby
get '/foo' do
  status 418
  headers \
    "Allow"   => "BREW, POST, GET, PROPFIND, WHEN",
    "Refresh" => "Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt"
  body "I'm a tea pot!"
end
```

引数を伴わない`body`、`headers`、`status`などは、それらの現在の値にアクセスするために使えます。

### ストリーミングレスポンス(Streaming Responses)

レスポンスボディの部分を未だ生成している段階で、データを送り出したいということがあります。極端な例では、クライアントがコネクションを閉じるまでデータを送り続けたいことがあります。`stream`ヘルパーを使えば、独自ラッパーを作る必要はありません。

``` ruby
get '/' do
  stream do |out|
    out << "それは伝 -\n"
    sleep 0.5
    out << " (少し待つ) \n"
    sleep 1
    out << "- 説になる！\n"
  end
end
```

これはストリーミングAPI、[Server Sent Events](http://dev.w3.org/html5/eventsource/)の実装を可能にし、[WebSockets](http://en.wikipedia.org/wiki/WebSocket)の土台に使うことができます。また、一部のコンテンツが遅いリソースに依存しているときに、スループットを上げるために使うこともできます。

ノート: ストリーミングの挙動、特に並行リクエスト(cuncurrent requests)の数は、アプリケーションを提供するのに使われるWebサーバに強く依存します。WEBRickを含むいくつかのサーバは、ストリーミングを全くサポートしません。サーバがストリーミングをサポートしない場合、ボディは`stream`に渡されたブロックの実行が終了した後、一度に全部送られることになります。ストリーミングは、Shotgunを使った場合は全く動作しません。

オプション引数が`keep_open`にセットされている場合、ストリームオブジェクト上で`close`は呼ばれず、実行フローの任意の遅れたタイミングでユーザがこれを閉じることを可能にします。これはThinやRainbowsのようなイベント型サーバ上でしか機能しません。他のサーバでは依然ストリームは閉じられます。

``` ruby
# ロングポーリング

set :server, :thin
connections = []

get '/subscribe' do
  # サーバイベントにおけるクライアントの関心を登録
  stream(:keep_open) do |out|
    connections << out
    # 死んでいるコネクションを排除
    connections.reject!(&:closed?)
  end
end

post '/message' do
  connections.each do |out|
    # クライアントへ新規メッセージ到着の通知
    out << params['message'] << "\n"

    # クライアントへの再接続の指示
    out.close
  end

  # 肯定応答
  "message received"
end
```

### ロギング(Logging)

リクエストスコープにおいて、`logger`ヘルパーは`Logger`インスタンスを作り出します。


``` ruby
get '/' do
  logger.info "loading data"
  # ...
end
```

このロガーは、自動でRackハンドラのロギング設定を参照します。ロギングが無効(disabled)にされている場合、このメソッドはダミーオブジェクトを返すので、ルーティングやフィルタにおいて特に心配することはありません。

ノート: ロギングは、`Sinatra::Application`に対してのみデフォルトで有効にされているので、`Sinatra::Base`を継承している場合は、ユーザがこれを有効化する必要があります。

``` ruby
class MyApp < Sinatra::Base
  configure :production, :development do
    enable :logging
  end
end
```

ロギングミドルウェアが設定されてしまうのを避けるには、`logging`設定を`nil`にセットします。しかしこの場合、`logger`が`nil`を返すことを忘れないように。よくあるユースケースは、オリジナルのロガーをセットしたいときです。Sinatraは、とにかく`env['rack.logger']`で見つかるものを使います。

### MIMEタイプ(Mime Types)

`send_file`か静的ファイルを使う時、SinatraがMIMEタイプを理解できない場合があります。その時は `mime_type` を使ってファイル拡張子毎に登録して下さい。

``` ruby
configure do
  mime_type :foo, 'text/foo'
end
```

これは`content_type`ヘルパーで利用することができます:

``` ruby
get '/' do
  content_type :foo
  "foo foo foo"
end
```

### URLの生成

URLを生成するためには`url`ヘルパーメソッドが使えます。Hamlではこのようにします。

``` ruby
%a{:href => url('/foo')} foo
```

これはリバースプロキシおよびRackルーティングを、それらがあれば考慮に入れます。

このメソッドには`to`というエイリアスがあります(以下の例を参照)。

### ブラウザリダイレクト(Browser Redirect)

`redirect` ヘルパーメソッドを使うことで、ブラウザをリダイレクトさせることができます。

``` ruby
get '/foo' do
  redirect to('/bar')
end
```

他に追加されるパラメータは、`halt`に渡される引数と同様に取り扱われます。

``` ruby
redirect to('/bar'), 303
redirect 'http://google.com', 'wrong place, buddy'
```

また、`redirect back`を使えば、簡単にユーザが来たページへ戻るリダイレクトを作れます。

``` ruby
get '/foo' do
  "<a href='/bar'>do something</a>"
end

get '/bar' do
  do_something
  redirect back
end
```

redirectに引数を渡すには、それをクエリーに追加するか、


``` ruby
redirect to('/bar?sum=42')
```

または、セッションを使います。

``` ruby
enable :sessions

get '/foo' do
  session[:secret] = 'foo'
  redirect to('/bar')
end

get '/bar' do
  session[:secret]
end
```

### キャッシュ制御(Cache Control)

ヘッダを正しく設定することが、適切なHTTPキャッシングのための基礎となります。

キャッシュ制御ヘッダ(Cache-Control header)は、次のように簡単に設定できます。

``` ruby
get '/' do
  cache_control :public
  "キャッシュしました!"
end
```

ヒント: キャッシングをbeforeフィルタ内で設定します。

``` ruby
before do
  cache_control :public, :must_revalidate, :max_age => 60
end
```

`expires`ヘルパーを対応するヘッダに使っている場合は、キャッシュ制御は自動で設定されます。

``` ruby
before do
  expires 500, :public, :must_revalidate
end
```

キャッシュを適切に使うために、`etag`または`last_modified`を使うことを検討してください。これらのヘルパーを、重い仕事をさせる *前* に呼ぶことを推奨します。そうすれば、クライアントが既にキャッシュに最新版を持っている場合はレスポンスを直ちに破棄するようになります。

``` ruby
get '/article/:id' do
  @article = Article.find params['id']
  last_modified @article.updated_at
  etag @article.sha1
  erb :article
end
```

また、[weak ETag](http://ja.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation)を使うこともできます。

``` ruby
etag @article.sha1, :weak
```

これらのヘルパーは、キャッシングをしてくれませんが、必要な情報をキャッシュに与えてくれます。もし手早いリバースプロキシキャッシングの解決策をお探しなら、 [rack-cache](https://github.com/rtomayko/rack-cache)を試してください。


``` ruby
require "rack/cache"
require "sinatra"

use Rack::Cache

get '/' do
  cache_control :public, :max_age => 36000
  sleep 5
  "hello"
end
```

`:static_cache_control`設定(以下を参照)を、キャッシュ制御ヘッダ情報を静的ファイルに追加するために使ってください。

RFC 2616によれば、アプリケーションは、If-MatchまたはIf-None-Matchヘッダが`*`に設定されている場合には、要求されたリソースが既に存在するか否かに応じて、異なる振る舞いをすべきとなっています。Sinatraは、getのような安全なリクエストおよびputのような冪等なリクエストは既に存在しているものとして仮定し、一方で、他のリソース(例えば、postリクエスト)は新たなリソースとして取り扱われるよう仮定します。この振る舞いは、`:new_resource`オプションを渡すことで変更できます。

``` ruby
get '/create' do
  etag '', :new_resource => true
  Article.create
  erb :new_article
end
```

ここでもWeak ETagを使いたい場合は、`:kind`オプションを渡してください。

``` ruby
etag '', :new_resource => true, :kind => :weak
```

### ファイルの送信

ファイルを送信するには、`send_file`ヘルパーメソッドを使います。

``` ruby
get '/' do
  send_file 'foo.png'
end
```

これはオプションを取ることもできます。

``` ruby
send_file 'foo.png', :type => :jpg
```

オプション一覧

<dl>
  <dt>filename</dt>
    <dd>ファイル名。デフォルトは実際のファイル名。</dd>

  <dt>last_modified</dt>
    <dd>Last-Modifiedヘッダの値。デフォルトはファイルのmtime。</dd>

  <dt>type</dt>
    <dd>コンテンツの種類。設定がない場合、ファイル拡張子から類推される。</dd>

  <dt>disposition</dt>
    <dd>
      Content-Dispositionに使われる。許容値: <tt>nil</tt> (デフォルト)、
      <tt>:attachment</tt> および <tt>:inline</tt>
    </dd>

  <dt>length</dt>
    <dd>Content-Lengthヘッダ。デフォルトはファイルサイズ。</dd>

  <dt>status</dt>
    <dd>
      送られるステータスコード。静的ファイルをエラーページとして送るときに便利。

      Rackハンドラでサポートされている場合は、Rubyプロセスからのストリーミング以外の手段が使われる。このヘルパーメソッドを使うと、Sinatraは自動で範囲リクエスト(range requests)を扱う。
    </dd>
</dl>


### リクエストオブジェクトへのアクセス

受信するリクエストオブジェクトは、`request`メソッドを通じてリクエストレベル(フィルタ、ルーティング、エラーハンドラ)からアクセスすることができます。

``` ruby
# アプリケーションが http://example.com/example で動作している場合
get '/foo' do
  t = %w[text/css text/html application/javascript]
  request.accept              # ['text/html', '*/*']
  request.accept? 'text/xml'  # true
  request.preferred_type(t)   # 'text/html'
  request.body                # クライアントによって送信されたリクエストボディ(下記参照)
  request.scheme              # "http"
  request.script_name         # "/example"
  request.path_info           # "/foo"
  request.port                # 80
  request.request_method      # "GET"
  request.query_string        # ""
  request.content_length      # request.bodyの長さ
  request.media_type          # request.bodyのメディアタイプ
  request.host                # "example.com"
  request.get?                # true (他の動詞にも同種メソッドあり)
  request.form_data?          # false
  request["some_param"]       # some_param変数の値。[]はパラメータハッシュのショートカット
  request.referrer            # クライアントのリファラまたは'/'
  request.user_agent          # ユーザエージェント (:agent 条件によって使用される)
  request.cookies             # ブラウザクッキーのハッシュ
  request.xhr?                # Ajaxリクエストかどうか
  request.url                 # "http://example.com/example/foo"
  request.path                # "/example/foo"
  request.ip                  # クライアントのIPアドレス
  request.secure?             # false (sslではtrueになる)
  request.forwarded?          # true (リバースプロキシの裏で動いている場合)
  request.env                 # Rackによって渡された生のenvハッシュ
end
```

`script_name`や`path_info`などのオプションは次のように利用することもできます。

``` ruby
before { request.path_info = "/" }

get "/" do
  "全てのリクエストはここに来る"
end
```

`request.body`はIOまたはStringIOのオブジェクトです。

``` ruby
post "/api" do
  request.body.rewind  # 既に読まれているときのため
  data = JSON.parse request.body.read
  "Hello #{data['name']}!"
end
```

### アタッチメント(Attachments)

`attachment`ヘルパーを使って、レスポンスがブラウザに表示されるのではなく、ディスクに保存されることをブラウザに対し通知することができます。

``` ruby
get '/' do
  attachment
  "保存しました!"
end
```

ファイル名を渡すこともできます。

``` ruby
get '/' do
  attachment "info.txt"
  "保存しました!"
end
```

### 日付と時刻の取り扱い

Sinatraは`time_for`ヘルパーメソッドを提供しており、それは与えられた値からTimeオブジェクトを生成します。これはまた`DateTime`、`Date`および類似のクラスを変換できます。

``` ruby
get '/' do
  pass if Time.now > time_for('Dec 23, 2012')
  "まだ時間がある"
end
```

このメソッドは、`expires`、`last_modified`といった種類のものの内部で使われています。そのため、アプリケーションにおいて、`time_for`をオーバーライドすることでそれらのメソッドの挙動を簡単に拡張できます。

``` ruby
helpers do
  def time_for(value)
    case value
    when :yesterday then Time.now - 24*60*60
    when :tomorrow  then Time.now + 24*60*60
    else super
    end
  end
end

get '/' do
  last_modified :yesterday
  expires :tomorrow
  "hello"
end
```

### テンプレートファイルの探索

`find_template`ヘルパーは、レンダリングのためのテンプレートファイルを見つけるために使われます。

``` ruby
find_template settings.views, 'foo', Tilt[:haml] do |file|
  puts "could be #{file}"
end
```

この例はあまり有益ではありません。しかし、このメソッドを、独自の探索機構で働くようオーバーライドするなら有益になります。例えば、複数のビューディレクトリを使えるようにしたいときがあります。


``` ruby
set :views, ['views', 'templates']

helpers do
  def find_template(views, name, engine, &block)
    Array(views).each { |v| super(v, name, engine, &block) }
  end
end
```

他の例としては、異なるエンジン用の異なるディレクトリを使う場合です。

``` ruby
set :views, :sass => 'views/sass', :haml => 'templates', :default => 'views'

helpers do
  def find_template(views, name, engine, &block)
    _, folder = views.detect { |k,v| engine == Tilt[k] }
    folder ||= views[:default]
    super(folder, name, engine, &block)
  end
end
```

これをエクステンションとして書いて、他の人と簡単に共有することもできます！

ノート: `find_template`はファイルが実際に存在するかのチェックをしませんが、与えられたブロックをすべての可能なパスに対し呼び出します。これがパフォーマンス上の問題にはならないのは、`render`はファイルを見つけると直ちに`break`を使うからです。また、テンプレートの場所（および内容）は、developmentモードでの起動でない限りはキャッシュされます。このことは、複雑なメソッド(a really crazy method)を書いた場合は記憶しておく必要があります。

## コンフィギュレーション(Configuration)

どの環境でも起動時に１回だけ実行されます。

``` ruby
configure do
  # １つのオプションをセット
  set :option, 'value'

  # 複数のオプションをセット
  set :a => 1, :b => 2

  # `set :option, true`と同じ
  enable :option

  # `set :option, false`と同じ
  disable :option

  # ブロックを使って動的な設定をすることもできます。
  set(:css_dir) { File.join(views, 'css') }
end
```

環境設定(`RACK_ENV`環境変数)が`:production`に設定されている時だけ実行する方法:

``` ruby
configure :production do
  ...
end
```

環境設定が`:production`か`:test`に設定されている時だけ実行する方法:

``` ruby
configure :production, :test do
  ...
end
```

設定したオプションには`settings`からアクセスできます:

``` ruby
configure do
  set :foo, 'bar'
end

get '/' do
  settings.foo? # => true
  settings.foo  # => 'bar'
  ...
end
```

### 攻撃防御に対する設定

Sinatraは、[Rack::Protection](https://github.com/rkh/rack-protection#readme)を使って、アプリケーションを多発する日和見的攻撃から守っています。この挙動は簡単に無効化できます(これはアプリケーションを大量の脆弱性攻撃に晒すことになります)。

``` ruby
disable :protection
```

単一の防御層を外すためには、`protection`をオプションハッシュにセットします。

``` ruby
set :protection, :except => :path_traversal
```
また配列を渡して、複数の防御を無効にすることもできます。

``` ruby
set :protection, :except => [:path_traversal, :session_hijacking]
```

デフォルトでSinatraは、`:sessions`が有効になっている場合、セッションベースの防御だけを設定します。しかし、自身でセッションを設定したい場合があります。その場合は、`:session`オプションを渡すことにより、セッションベースの防御を設定することができます。

``` ruby
use Rack::Session::Pool
set :protection, :session => true
```

### 利用可能な設定

<dl>
  <dt>absolute_redirects</dt>
  <dd>
    無効のとき、Sinatraは相対リダイレクトを許容するが、RFC 2616 (HTTP 1.1)は絶対リダイレクトのみを許容するので、これには準拠しなくなる。
  </dd>
  <dd>
    アプリケーションが、適切に設定されていないリバースプロキシの裏で走っている場合は有効。ノート: <tt>url</tt>ヘルパーは、第２引数に<tt>false</tt>を渡さない限り、依然として絶対URLを生成する。
  </dd>
  <dd>デフォルトは無効。</dd>

  <dt>add_charset</dt>
  <dd>
    Mimeタイプ <tt>content_type</tt>ヘルパーが自動的にキャラクタセット情報をここに追加する。このオプションは書き換えるのではなく、値を追加するようにすること。
    <tt>settings.add_charset << "application/foobar"</tt>
  </dd>

  <dt>app_file</dt>
  <dd>
    メインのアプリケーションファイルのパスであり、プロジェクトのルート、viewsおよびpublicフォルダを見つけるために使われる。
  </dd>

  <dt>bind</dt>
  <dd>バインドするIPアドレス(デフォルト: `environment`がdevelopmentにセットされているときは、<tt>0.0.0.0</tt> <em>または</em> <tt>localhost</tt>)。ビルトインサーバでのみ使われる。</dd>

  <dt>default_encoding</dt>
  <dd>不明なときに仮定されるエンコーディング(デフォルトは<tt>"utf-8"</tt>)。</dd>

  <dt>dump_errors</dt>
  <dd>ログにおけるエラーの表示。</dd>

  <dt>environment</dt>
  <dd>
    現在の環境。デフォルトは<tt>ENV['RACK_ENV']</tt>、それが無い場合は<tt>"development"</tt>。
  </dd>

  <dt>logging</dt>
  <dd>ロガーの使用。</dd>

  <dt>lock</dt>
  <dd>
    各リクエスト周りのロックの配置で、Rubyプロセスごとにリクエスト処理を並行して走らせるようにする。
  </dd>
  <dd>アプリケーションがスレッドセーフでなければ有効。デフォルトは無効。</dd>

  <dt>method_override</dt>
  <dd>
    put/deleteフォームを、それらをサポートしないブラウザで使えるように<tt>_method</tt>のおまじないを使えるようにする。
  </dd>

  <dt>port</dt>
  <dd>待ち受けポート。ビルトインサーバのみで有効。</dd>

  <dt>prefixed_redirects</dt>
  <dd>
    絶対パスが与えられていないときに、リダイレクトに<tt>request.script_name</tt>を挿入するか否かの設定。これにより<tt>redirect '/foo'</tt>は、<tt>redirect to('/foo')</tt>のように振る舞う。デフォルトは無効。
  </dd>

  <dt>protection</dt>
  <dd>Web攻撃防御を有効にするか否かの設定。上述の攻撃防御の項を参照。</dd>

  <dt>public_dir</dt>
  <dd><tt>public_folder</tt>のエイリアス。以下を参照。</dd>

  <dt>public_folder</dt>
  <dd>
    publicファイルが提供されるディレクトリのパス。静的ファイルの提供が有効になっている場合にのみ使われる (以下の<tt>static</tt>設定を参照)。設定されていない場合、<tt>app_file</tt>設定から推定。
  </dd>

  <dt>reload_templates</dt>
  <dd>
    リクエスト間でテンプレートを再ロードするか否かの設定。developmentモードでは有効。
  </dd>

  <dt>root</dt>
  <dd>
    プロジェクトのルートディレクトリのパス。設定されていない場合、<tt>app_file</tt>設定から推定。
  </dd>

  <dt>raise_errors</dt>
  <dd>
    例外発生の設定(アプリケーションは止まる)。<tt>environment</tt>が<tt>"test"</tt>に設定されているときはデフォルトは有効。それ以外は無効。
  </dd>

  <dt>run</dt>
  <dd>
    有効のとき、SinatraがWebサーバの起動を取り扱う。rackupまたは他の手段を使うときは有効にしないこと。
  </dd>

  <dt>running</dt>
  <dd>ビルトインサーバが稼働中か？この設定を変更しないこと！</dd>

  <dt>server</dt>
  <dd>
    ビルトインサーバとして使用するサーバまたはサーバ群の指定。指定順位は優先度を表し、デフォルトはRuby実装に依存。
  </dd>

  <dt>sessions</dt>
  <dd>
    <tt>Rack::Session::Cookie</tt>を使ったクッキーベースのセッションサポートの有効化。詳しくは、'セッションの使用'の項を参照のこと。
  </dd>

  <dt>show_exceptions</dt>
  <dd>
    例外発生時にブラウザにスタックトレースを表示する。<tt>environment</tt>が<tt>"development"</tt>に設定されているときは、デフォルトで有効。それ以外は無効。
  </dd>
  <dd>
    また、<tt>:after_handler</tt>をセットすることができ、これにより、ブラウザにスタックトレースを表示する前に、アプリケーション固有のエラーハンドリングを起動させられる。
  </dd>

  <dt>static</dt>
  <dd>Sinatraが静的ファイルの提供を取り扱うかの設定。</dd>
  <dd>その取り扱いができるサーバを使う場合は無効。</dd>
  <dd>無効化でパフォーマンスは改善する</dd>
  <dd>
    クラッシックスタイルではデフォルトで有効。モジュラースタイルでは無効。
  </dd>

  <dt>static_cache_control</dt>
  <dd>
    Sinatraが静的ファイルを提供するときこれをセットして、レスポンスに<tt>Cache-Control</tt>ヘッダを追加するようにする。<tt>cache_control</tt>ヘルパーを使うこと。デフォルトは無効。
  </dd>
  <dd>
    複数の値をセットするときは明示的に配列を使う:
    <tt>set :static_cache_control, [:public, :max_age => 300]</tt>
  </dd>

  <dt>threaded</dt>
  <dd>
    <tt>true</tt>に設定されているときは、Thinにリクエストを処理するために<tt>EventMachine.defer</tt>を使うことを通知する。
  </dd>

  <dt>views</dt>
  <dd>
    ビューディレクトリのパス。設定されていない場合、<tt>app_file</tt>設定から推定する。
  </dd>

  <dt>x_cascade</dt>
  <dd>
    マッチするルーティングが無い場合に、X-Cascadeヘッダをセットするか否かの設定。デフォルトは<tt>true</tt>。
  </dd>
</dl>

## 環境設定(Environments)

３種類の既定環境、`"development"`、`"production"`および`"test"`があります。環境は、`RACK_ENV`環境変数を通して設定できます。デフォルト値は、`"development"`です。`"development"`環境において、すべてのテンプレートは、各リクエスト間で再ロードされ、そして、特別の`not_found`および`error`ハンドラがブラウザにスタックトレースを表示します。`"production"`および`"test"`環境においては、テンプレートはデフォルトでキャッシュされます。

異なる環境を走らせるには、`RACK_ENV`環境変数を設定します。

``` shell
RACK_ENV=production ruby my_app.rb
```

既定メソッド、`development?`、`test?`および`production?`を、現在の環境設定を確認するために使えます。

``` ruby
get '/' do
  if settings.development?
    "development!"
  else
    "not development!"
  end
end
```

## エラーハンドリング(Error Handling)

エラーハンドラはルーティングおよびbeforeフィルタと同じコンテキストで実行されます。すなわちこれは、`haml`、`erb`、`halt`といった便利なものが全て使えることを意味します。

### 未検出(Not Found)

`Sinatra::NotFound`例外が発生したとき、またはレスポンスのステータスコードが404のときに、`not_found`ハンドラが発動します。

``` ruby
not_found do
  'ファイルが存在しません'
end
```

### エラー(Error)

`error`ハンドラはルーティングブロックまたはフィルタ内で例外が発生したときはいつでも発動します。例外オブジェクトはRack変数`sinatra.error`から取得できます。

``` ruby
error do
  'エラーが発生しました。 - ' + env['sinatra.error'].message
end
```

エラーをカスタマイズする場合は、

``` ruby
error MyCustomError do
  'エラーメッセージ...' + env['sinatra.error'].message
end
```

と書いておいて、下記のように呼び出します。

``` ruby
get '/' do
  raise MyCustomError, '何かがまずかったようです'
end
```

そうするとこうなります。

```
エラーメッセージ... 何かがまずかったようです
```

あるいは、ステータスコードに対応するエラーハンドラを設定することもできます。

``` ruby
error 403 do
  'Access forbidden'
end

get '/secret' do
  403
end
```

範囲指定もできます。

``` ruby
error 400..510 do
  'Boom'
end
```

Sinatraを開発環境の下で実行している場合は、特別な`not_found`および`error`ハンドラが導入され、これは親切なスタックトレースと追加のデバッギング情報をブラウザに表示します。


## Rackミドルウェア(Rack Middleware)

SinatraはRuby製Webフレームワークのミニマルな標準的インタフェースである[Rack](http://rack.github.io/)上に構築されています。アプリケーションデベロッパーにとってRackにおける最も興味深い機能は、「ミドルウェア(middleware)」をサポートしていることであり、これは、サーバとアプリケーションとの間に置かれ、HTTPリクエスト/レスポンスを監視および/または操作することで、各種の汎用的機能を提供するコンポーネントです。

Sinatraはトップレベルの`use`メソッドを通して、Rackミドルウェアパイプラインの構築を楽にします。

``` ruby
require 'sinatra'
require 'my_custom_middleware'

use Rack::Lint
use MyCustomMiddleware

get '/hello' do
  'Hello World'
end
```

`use`の文法は、[Rack::Builder](http://rubydoc.info/github/rack/rack/master/Rack/Builder)DSLで定義されているそれ（rackupファイルで最もよく使われる）と同じです。例えば `use`メソッドは複数の引数、そしてブロックも取ることができます。

``` ruby
use Rack::Auth::Basic do |username, password|
  username == 'admin' && password == 'secret'
end
```

Rackは、ロギング、デバッギング、URLルーティング、認証、セッション管理など、多様な標準的ミドルウェアを共に配布されています。Sinatraはその多くのコンポーネントを自動で使うよう基本設定されているため、通常、それらを`use`で明示的に指定する必要はありません。

便利なミドルウェアを以下で見つけられます。

[rack](https://github.com/rack/rack/tree/master/lib/rack)、
[rack-contrib](https://github.com/rack/rack-contrib#readm)、
または[Rack wiki](https://github.com/rack/rack/wiki/List-of-Middleware)。

## テスト(Testing)

SinatraでのテストはRackベースのテストライブラリまたはフレームワークを使って書くことができます。[Rack::Test](http://rdoc.info/github/brynary/rack-test/master/frames)をお薦めします。

``` ruby
require 'my_sinatra_app'
require 'minitest/autorun'
require 'rack/test'

class MyAppTest < Minitest::Test
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_my_default
    get '/'
    assert_equal 'Hello World!', last_response.body
  end

  def test_with_params
    get '/meet', :name => 'Frank'
    assert_equal 'Hello Frank!', last_response.body
  end

  def test_with_rack_env
    get '/', {}, 'HTTP_USER_AGENT' => 'Songbird'
    assert_equal "Songbirdを使ってます!", last_response.body
  end
end
```

ノート: モジュラースタイルでSinatraを使う場合は、上記`Sinatra::Application`をアプリケーションのクラス名に置き換えてください。

## Sinatra::Base - ミドルウェア、ライブラリおよびモジュラーアプリ

軽量なアプリケーションであれば、トップレベルでアプリケーションを定義していくことはうまくいきますが、再利用性可能なコンポーネント、例えばRackミドルウェア、RailsのMetal、サーバコンポーネントを含むシンプルなライブラリ、あるいはSinatraの拡張プログラムを構築するような場合、これは無視できない欠点を持つものとなります。トップレベルは、軽量なアプリケーションのスタイルにおける設定（例えば、単一のアプリケーションファイル、`./public`および`./views`ディレクトリ、ロギング、例外詳細ページなど）を仮定しています。そこで`Sinatra::Base`の出番です。

``` ruby
require 'sinatra/base'

class MyApp < Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Hello world!'
  end
end
```

`Sinatra::Base`のサブクラスで利用できるメソッドは、トップレベルDSLで利用できるものと全く同じです。ほとんどのトップレベルで記述されたアプリは、以下の２点を修正することで`Sinatra::Base`コンポーネントに変えることができます。

* `sinatra`の代わりに`sinatra/base`を読み込む
  (そうしない場合、SinatraのDSLメソッドの全てがmainの名前空間にインポートされます)
* ルーティング、エラーハンドラ、フィルタ、オプションを`Sinatra::Base`のサブクラスに書く

`Sinatra::Base`はまっさらです。ビルトインサーバを含む、ほとんどのオプションがデフォルトで無効になっています。利用可能なオプションとその挙動の詳細については[Configuring Settings](http://sinatra.github.com/configuration.html)(英語)をご覧下さい。

もしもクラシックスタイルと同じような挙動のアプリケーションをトップレベルで定義させる必要があれば、`Sinatra::Application`をサブクラス化させてください。

```ruby
require "sinatra/base"

class MyApp < Sinatra::Application
  get "/" do
    'Hello world!'
  end
end
```

### モジュラースタイル vs クラッシックスタイル

一般的認識と違って、クラッシックスタイルを使うことに問題はなにもありません。それがそのアプリケーションに合っているのであれば、モジュラーアプリケーションに移行する必要はありません。

モジュラースタイルを使わずにクラッシックスタイルを使った場合の一番の不利な点は、Rubyプロセスごとにただ一つのSinatraアプリケーションしか持てない点です。複数が必要な場合はモジュラースタイルに移行してください。モジュラースタイルとクラッシックスタイルを混合できないということはありません。

一方のスタイルから他方へ移行する場合、デフォルト設定がわずかに異なる点に注意が必要です。

<table>
  <tr>
    <th>設定</th>
    <th>クラッシック</th>
    <th>モジュラー</th>
    <th>モジュラー</th>
  </tr>

  <tr>
    <td>app_file</td>
    <td>sinatraを読み込むファイル</td>
    <td>Sinatra::Baseをサブクラス化したファイル</td>
    <td>Sinatra::Applicationをサブクラス化したファイル</td>
  </tr>

  <tr>
    <td>run</td>
    <td>$0 == app_file</td>
    <td>false</td>
    <td>false</td>
  </tr>

  <tr>
    <td>logging</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>method_override</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>inline_templates</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>static</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>
</table>

### モジュラーアプリケーションの提供

モジュラーアプリケーションを開始、つまり`run!`を使って開始させる二種類のやり方があります。

``` ruby
# my_app.rb
require 'sinatra/base'

class MyApp < Sinatra::Base
  # ... アプリケーションのコードを書く ...

  # Rubyファイルが直接実行されたらサーバを立ち上げる
  run! if app_file == $0
end
```

として、次のように起動するか、

``` shell
ruby my_app.rb
```

または、Rackハンドラを使えるようにする`config.ru`ファイルを書いて、

``` ruby
# config.ru (rackupで起動)
require './my_app'
run MyApp
```

起動します。

``` shell
rackup -p 4567
```

### config.ruを用いたクラッシックスタイルアプリケーションの使用

アプリケーションファイルと、

``` ruby
# app.rb
require 'sinatra'

get '/' do
  'Hello world!'
end
```

対応する`config.ru`を書きます。

``` ruby
require './app'
run Sinatra::Application
```

### config.ruはいつ使うのか？

`config.ru`ファイルは、以下の場合に適しています。

* 異なるRackハンドラ(Passenger, Unicorn, Herokuなど)でデプロイしたいとき
* `Sinatra::Base`の複数のサブクラスを使いたいとき
* Sinatraをミドルウェアとして利用し、エンドポイントとしては利用しないとき

**モジュラースタイルに移行したという理由だけで、`config.ru`に移行する必要はなく、`config.ru`で起動するためにモジュラースタイルを使う必要はありません。**

### Sinatraのミドルウェアとしての利用

Sinatraは他のRackミドルウェアを利用することができるだけでなく、
全てのSinatraアプリケーションは、それ自体ミドルウェアとして別のRackエンドポイントの前に追加することが可能です。

このエンドポイントには、別のSinatraアプリケーションまたは他のRackベースのアプリケーション(Rails/Ramaze/Camping/…)が用いられるでしょう。

``` ruby
require 'sinatra/base'

class LoginScreen < Sinatra::Base
  enable :sessions

  get('/login') { haml :login }

  post('/login') do
    if params['name'] = 'admin' and params['password'] = 'admin'
      session['user_name'] = params['name']
    else
      redirect '/login'
    end
  end
end

class MyApp < Sinatra::Base
  # ミドルウェアはbeforeフィルタの前に実行される
  use LoginScreen

  before do
    unless session['user_name']
      halt "アクセスは拒否されました。<a href='/login'>ログイン</a>してください。"
    end
  end

  get('/') { "Hello #{session['user_name']}." }
end
```

### 動的なアプリケーションの生成

新しいアプリケーションを実行時に、定数に割り当てることなく生成したくなる場合があるでしょう。`Sinatra.new`を使えばそれができます。

``` ruby
require 'sinatra/base'
my_app = Sinatra.new { get('/') { "hi" } }
my_app.run!
```

これは省略できる引数として、それが継承するアプリケーションを取ります。

```ruby
# config.ru (rackupで起動)
require 'sinatra/base'

controller = Sinatra.new do
  enable :logging
  helpers MyHelpers
end

map('/a') do
  run Sinatra.new(controller) { get('/') { 'a' } }
end

map('/b') do
  run Sinatra.new(controller) { get('/') { 'b' } }
end
```

これは特にSinatraのextensionをテストするときや、Sinatraを自身のライブラリで利用する場合に役立ちます。

これはまた、Sinatraをミドルウェアとして利用することを極めて簡単にします。

``` ruby
require 'sinatra/base'

use Sinatra do
  get('/') { ... }
end

run RailsProject::Application
```

## スコープとバインディング(Scopes and Binding)

現在のスコープはどのメソッドや変数が利用可能かを決定します。

### アプリケーション/クラスのスコープ

全てのSinatraアプリケーションはSinatra::Baseのサブクラスに相当します。
もしトップレベルDSLを利用しているならば(`require 'sinatra'`)このクラスはSinatra::Applicationであり、
そうでなければ、あなたが明示的に作成したサブクラスです。
クラスレベルでは`get`や`before`のようなメソッドを持っています。
しかし`request`や`session`オブジェクトには、全てのリクエストに対する単一のアプリケーションクラスがあるだけなので、アクセスできません。

`set`によって作られたオプションはクラスレベルのメソッドです。

``` ruby
class MyApp < Sinatra::Base
  # アプリケーションスコープの中だよ!
  set :foo, 42
  foo # => 42

  get '/foo' do
    # もうアプリケーションスコープの中にいないよ!
  end
end
```

次の場所ではアプリケーションスコープバインディングを持ちます。

* アプリケーションクラス本体
* 拡張によって定義されたメソッド
* `helpers`に渡されたブロック
* `set`の値として使われるProcまたはブロック
* `Sinatra.new`に渡されたブロック

このスコープオブジェクト(クラス)は次のように利用できます。

* configureブロックに渡されたオブジェクト経由(`configure { |c| ... }`)
* リクエストスコープの中での`settings`

### リクエスト/インスタンスのスコープ

やってくるリクエストごとに、あなたのアプリケーションクラスの新しいインスタンスが作成され、全てのハンドラブロックがそのスコープで実行されます。
このスコープの内側からは`request`や`session`オブジェクトにアクセスすることができ、`erb`や`haml`のようなレンダリングメソッドを呼び出すことができます。
リクエストスコープの内側からは、`settings`ヘルパーによってアプリケーションスコープにアクセスすることができます。

``` ruby
class MyApp < Sinatra::Base
  # アプリケーションスコープの中だよ!
  get '/define_route/:name' do
    # '/define_route/:name'のためのリクエストスコープ
    @value = 42

    settings.get("/#{params['name']}") do
      # "/#{params['name']}"のためのリクエストスコープ
      @value # => nil (not the same request)
    end

    "ルーティングが定義された!"
  end
end
```

次の場所ではリクエストスコープバインディングを持ちます。

* get/head/post/put/delete/options/patch/link/unlink ブロック
* before/after フィルタ
* helper メソッド
* テンプレート/ビュー

### デリゲートスコープ

デリゲートスコープは、単にクラススコープにメソッドを転送します。
しかしながら、クラスのバインディングを持っていないため、クラススコープと全く同じふるまいをするわけではありません。
委譲すると明示的に示されたメソッドのみが利用可能であり、またクラススコープと変数/状態を共有することはできません(注:
異なった`self`を持っています)。
`Sinatra::Delegator.delegate :method_name`を呼び出すことによってデリゲートするメソッドを明示的に追加することができます。

次の場所ではデリゲートスコープを持ちます。

* もし`require "sinatra"`しているならば、トップレベルバインディング
* `Sinatra::Delegator` mixinでextendされたオブジェクト

コードをご覧ください: ここでは [Sinatra::Delegator
mixin](https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/base.rb#L1609-1633)は[mainオブジェクトにextendされています](https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/main.rb#L28-30)。

## コマンドライン

Sinatraアプリケーションは直接実行できます。

``` shell
ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-o HOST] [-s HANDLER]
```

オプション:

```
-h # ヘルプ
-p # ポート指定(デフォルトは4567)
-o # ホスト指定(デフォルトは0.0.0.0)
-e # 環境を指定 (デフォルトはdevelopment)
-s # rackserver/handlerを指定 (デフォルトはthin)
-x # mutex lockを付ける (デフォルトはoff)
```

## 必要環境

次のRubyバージョンが公式にサポートされています。

<dl>
  <dt>Ruby 1.8.7</dt>
  <dd>
    1.8.7は完全にサポートされていますが、特にそれでなければならないという理由がないのであれば、アップグレードまたはJRubyまたはRubiniusへの移行を薦めます。1.8.7のサポートがSinatra 2.0の前に終わることはないでしょう。Ruby 1.8.6はサポート対象外です。
  </dd>

  <dt>Ruby 1.9.2</dt>
  <dd>
    1.9.2は完全にサポートされています。1.9.2p0は、Sinatraを起動したときにセグメントフォルトを引き起こすことが分かっているので、使わないでください。公式なサポートは、少なくともSinatra 1.5のリリースまでは続きます。
  </dd>

  <dt>Ruby 1.9.3</dt>
  <dd>
    1.9.3は完全にサポート、そして推奨されています。以前のバージョンからの1.9.3への移行は全セッションを無効にする点、覚えておいてください。
  </dd>

  <dt>Ruby 2.0.0</dt>
  <dd>
    2.0.0は完全にサポート、そして推奨されています。現在、その公式サポートを終了する計画はありません。
  </dd>

  <dt>Rubinius</dt>
  <dd>
    Rubiniusは公式にサポートされています(Rubinius >= 2.x)。
    <tt>gem install puma</tt>することが推奨されています。
  </dd>

  <dt>JRuby</dt>
  <dd>
    JRubyの最新安定版が公式にサポートされています。JRubyでC拡張を使うことは推奨されていません。
    <tt>gem install trinidad</tt>することが推奨されています。
  </dd>
</dl>

開発チームは常に最新となるRubyバージョンに注視しています。

次のRuby実装は公式にはサポートされていませんが、Sinatraが起動すると報告されています。

* JRubyとRubiniusの古いバージョン
* Ruby Enterprise Edition
* MacRuby, Maglev, IronRuby
* Ruby 1.9.0と1.9.1 (これらの使用はお薦めしません)

公式サポートをしないという意味は、問題がそこだけで起こり、サポートされているプラットフォーム上では起きない場合に、開発チームはそれはこちら側の問題ではないとみなすということです。

開発チームはまた、ruby-head(最新となる2.1.0)に対しCIを実行していますが、それが一貫して動くようになるまで何も保証しません。2.1.0が完全にサポートされればその限りではありません。

Sinatraは、利用するRuby実装がサポートしているオペレーティングシステム上なら動作するはずです。

MacRubyを使う場合は、`gem install control_tower`してください。

Sinatraは現在、Cardinal、SmallRuby、BlueRubyまたは1.8.7以前のバージョンのRuby上では動作しません。

## 最新開発版

Sinatraの最新開発版のコードを使いたい場合は、マスターブランチに対してアプリケーションを走らせて構いません。ある程度安定しています。また、適宜プレリリース版gemをpushしているので、

``` shell
gem install sinatra --pre
```

すれば、最新の機能のいくつかを利用できます。

### Bundlerを使う場合

最新のSinatraでアプリケーションを動作させたい場合には、[Bundler](http://gembundler.com/)を使うのがお薦めのやり方です。

まず、Bundlerがなければそれをインストールします。

``` shell
gem install bundler
```

そして、プロジェクトのディレクトリで、`Gemfile`を作ります。

```ruby
source 'https://rubygems.org'
gem 'sinatra', :github => "sinatra/sinatra"

# 他の依存ライブラリ
gem 'haml'                    # Hamlを使う場合
gem 'activerecord', '~> 3.0'  # ActiveRecord 3.xが必要かもしれません
```

ノート: `Gemfile`にアプリケーションの依存ライブラリのすべてを並べる必要があります。しかし、Sinatraが直接依存するもの(RackおよびTile)はBundlerによって自動的に取り込まれ、追加されます。

これで、以下のようにしてアプリケーションを起動することができます。

``` shell
bundle exec ruby myapp.rb
```

### 直接組み込む場合

ローカルにクローンを作って、`sinatra/lib`ディレクトリを`$LOAD_PATH`に追加してアプリケーションを起動します。

``` shell
cd myapp
git clone git://github.com/sinatra/sinatra.git
ruby -I sinatra/lib myapp.rb
```

追ってSinatraのソースを更新する方法。

``` shell
cd myapp/sinatra
git pull
```

### グローバル環境にインストールする場合

Sinatraのgemを自身でビルドすることもできます。

``` shell
git clone git://github.com/sinatra/sinatra.git
cd sinatra
rake sinatra.gemspec
rake install
```

gemをルートとしてインストールする場合は、最後のステップはこうなります。

``` shell
sudo rake install
```

## バージョニング(Versioning)

Sinatraは、[Semantic Versioning](http://semver.org/)におけるSemVerおよびSemVerTagの両方に準拠しています。

## 参考文献

* [プロジェクトサイト](http://sinatra.github.com/) - ドキュメント、ニュース、他のリソースへのリンクがあります。
* [プロジェクトに参加(貢献)する](http://sinatra.github.com/contributing.html) - バグレポート パッチの送信、サポートなど
* [Issue tracker](http://github.com/sinatra/sinatra/issues)
* [Twitter](http://twitter.com/sinatra)
* [メーリングリスト](http://groups.google.com/group/sinatrarb/topics)
* http://freenode.net上のIRC: [#sinatra](irc://chat.freenode.net/#sinatra)
* [Sinatra Book](https://github.com/sinatra/sinatra-book/) クックブック、チュートリアル
* [Sinatra Recipes](http://recipes.sinatrarb.com/) コミュニティによるレシピ集
* http://rubydoc.info上のAPIドキュメント: [最新版(latest release)用](http://rubydoc.info/gems/sinatra)または[現在のHEAD用](http://rubydoc.info/github/sinatra/sinatra)
* [CIサーバ](http://travis-ci.org/sinatra/sinatra)
* [Greenbear Laboratory Rack日本語マニュアル](http://route477.net/w/RackReferenceJa.html)
# Sinatra
*Fontos megjegyzés: Ez a dokumentum csak egy fordítása az angol nyelvű
változatnak, és lehet, hogy nem naprakész.*

A Sinatra egy [DSL](http://en.wikipedia.org/wiki/Domain-specific_language)
webalkalmazások Ruby nyelven történő fejlesztéséhez, minimális
energiabefektetéssel:

```ruby
  # myapp.rb
  require 'sinatra'
  get '/' do
    'Helló Világ!'
  end
```

Telepítsd a gem-et és indítsd el az alkalmazást a következőképpen:

```ruby
  sudo gem install sinatra
  ruby myapp.rb
```

Az alkalmazás elérhető lesz itt: `http://localhost:4567`

## Útvonalak (routes)

A Sinatrában az útvonalat egy HTTP metódus és egy URL-re illeszkedő minta
párosa alkotja. Minden egyes útvonalhoz tartozik egy blokk:

```ruby
  get '/' do
    .. megjelenítünk valamit ..
  end

  post '/' do
    .. létrehozunk valamit ..
  end

  put '/' do
    .. frissítünk valamit ..
  end

  delete '/' do
    .. törlünk valamit ..
  end
```

Az útvonalak illeszkedését a rendszer a definiálásuk sorrendjében
ellenőrzi. Sorrendben mindig az első illeszkedő útvonalhoz tartozó metódus kerül
meghívásra.

Az útvonalminták tartalmazhatnak paramétereket is, melyeket a `params`
hash-ből érhetünk el:

```ruby
  get '/hello/:name' do
    # illeszkedik a "GET /hello/foo" és a "GET /hello/bar" útvonalakra
    # ekkor params['name'] értéke 'foo' vagy 'bar' lesz
    "Helló #{params['name']}!"
  end
```

A kulcsszavas argumentumokat (named parameters) blokk paraméterek útján
is el tudod érni:

```ruby
  get '/hello/:name' do |n|
    "Helló #{n}!"
  end
```

Az útvonalmintákban szerepelhetnek joker paraméterek is, melyeket a
`params['splat']` tömbön keresztül tudunk elérni.

```ruby
  get '/say/*/to/*' do
    # illeszkedik a /say/hello/to/world mintára
    params['splat'] # => ["hello", "world"]
  end

  get '/download/*.*' do
    # illeszkedik a /download/path/to/file.xml mintára
    params['splat'] # => ["path/to/file", "xml"]
  end
```

Reguláris kifejezéseket is felvehetünk az útvonalba:

```ruby
  get /\A\/hello\/([\w]+)\z/ do
    "Helló, #{params['captures'].first}!"
  end
```

Vagy blokk paramétereket:

```ruby
  get %r{/hello/([\w]+)} do |c|
    "Helló, #{c}!"
  end
```

Az útvonalak azonban számos egyéb illeszkedési feltétel szerint is
tervezhetők, így például az user agent karakterláncot alapul véve:

```ruby
  get '/foo', :agent => /Songbird (\d\.\d)[\d\/]*?/ do
    "A Songbird #{params['agent'][0]} verzióját használod"
  end

  get '/foo' do
    # illeszkedik az egyéb user agentekre
  end
```

## Statikus állományok

A statikus fájlok kiszolgálása a `./public` könyvtárból
történik, de természetesen más könyvtárat is megadhatsz erre a célra,
mégpedig a :public_folder kapcsoló beállításával:

  set :public_folder, File.dirname(__FILE__) + '/static'

Fontos megjegyezni, hogy a nyilvános könyvtár neve nem szerepel az URL-ben.
A ./public/css/style.css fájl az
`http://example.com/css/style.css` URL-en lesz elérhető.

## Nézetek és Sablonok

A sablonfájlokat rendszerint a  `./views` könyvtárba helyezzük, de
itt is lehetőség nyílik egyéb könyvtár használatára:

  set :views, File.dirname(__FILE__) + '/templates'

Nagyon fontos észben tartani, hogy a sablononkra mindig szimbólumokkal
hivatkozunk, még akkor is, ha egyéb (ebben az esetben a
:'subdir/template') könyvtárban tároljuk őket. A renderelő
metódusok minden, nekik közvetlenül átadott karakterláncot megjelenítenek.

### Haml sablonok

HAML sablonok rendereléséhez szükségünk lesz a haml gem-re vagy könyvtárra:

```ruby
  # Importáljuk be a haml-t az alkalmazásba
  require 'haml'

  get '/' do
    haml :index
  end
```

Ez szépen lerendereli a `./views/index.haml` sablont.

A [Haml kapcsolói](http://haml.hamptoncatlin.com/docs/rdoc/classes/Haml.html)
globálisan is beállíthatók a Sinatra konfigurációi között, lásd az
[Options and Configurations](http://www.sinatrarb.com/configuration.html) lapot.
A globális beállításokat lehetőségünk van felülírni metódus szinten is.

```ruby
  set :haml, {:format => :html5 } # az alapértelmezett Haml formátum az :xhtml

  get '/' do
    haml :index, :haml_options => {:format => :html4 } # immár felülírva
  end
```

### Erb sablonok

  # Importáljuk be az erb-t az alkalmazásba

```ruby
  require 'erb'

  get '/' do
    erb :index
  end
```

Ez a `./views/index.erb` sablont fogja lerenderelni.

### Builder sablonok

Szükségünk lesz a builder gem-re vagy könyvtárra a builder sablonok
rendereléséhez:

  # Importáljuk be a builder-t az alkalmazásba

```ruby
  require 'builder'

  get '/' do
    builder :index
  end
```

Ez pedig a `./views/index.builder` állományt fogja renderelni.

### Sass sablonok

Sass sablonok használatához szükség lesz a haml gem-re vagy könyvtárra:

  # Be kell importálni a haml, vagy a sass könyvtárat

```ruby
  require 'sass'

  get '/stylesheet.css' do
    sass :stylesheet
  end
```

Így a `./views/stylesheet.sass` fájl máris renderelhető.

A [Sass kapcsolói](http://haml.hamptoncatlin.com/docs/rdoc/classes/Sass.html)
globálisan is beállíthatók a Sinatra konfigurációi között, lásd az
[Options and Configurations](http://www.sinatrarb.com/configuration.html) lapot.
A globális beállításokat lehetőségünk van felülírni metódus szinten is.

```ruby
  set :sass, {:style => :compact } # az alapértelmezett Sass stílus a :nested

  get '/stylesheet.css' do
    sass :stylesheet, :sass_options => {:style => :expanded } # felülírva
  end
```

### Beágyazott sablonok

```ruby
  get '/' do
    haml '%div.title Helló Világ'
  end
```

Lerendereli a beágyazott sablon karakerláncát.

### Változók elérése a sablonokban

A sablonok ugyanabban a kontextusban kerülnek kiértékelésre, mint az
útvonal metódusok (route handlers). Az útvonal metódusokban megadott
változók közvetlenül elérhetőek lesznek a sablonokban:

```ruby
  get '/:id' do
    @foo = Foo.find(params['id'])
    haml '%h1= @foo.name'
  end
```

De megadhatod egy lokális változókat tartalmazó explicit hash-ben is:

```ruby
  get '/:id' do
    foo = Foo.find(params['id'])
    haml '%h1= foo.name', :locals => { :foo => foo }
  end
```

Ezt leginkább akkor érdemes megtenni, ha partial-eket akarunk renderelni
valamely más sablonból.

### Fájlon belüli sablonok

Sablonokat úgy is megadhatunk, hogy egyszerűen az alkalmazás fájl
végére begépeljük őket:

```ruby
  require 'rubygems'
  require 'sinatra'

  get '/' do
    haml :index
  end

  __END__

  @@ layout
  %html
    = yield

  @@ index
  %div.title Helló Világ!!!!!
```

Megjegyzés: azok a fájlon belüli sablonok, amelyek az alkalmazás fájl végére
kerülnek és függnek a sinatra könyvtártól, automatikusan betöltődnek.
Ha ugyanezt más alkalmazásfájlban is szeretnéd megtenni, hívd meg
a <tt>use_in_file_templates!</tt> metódust az adott fájlban.

### Kulcsszavas sablonok

Sablonokat végül a felsőszintű <tt>template</tt> metódussal is
definiálhatunk:

```ruby
  template :layout do
    "%html\n  =yield\n"
  end

  template :index do
    '%div.title Helló Világ!'
  end

  get '/' do
    haml :index
  end
```

Ha létezik "layout" nevű sablon, akkor az minden esetben meghívódik, amikor
csak egy sablon renderelésre kerül. A layoutokat ki lehet kapcsolni a
`:layout => false` meghívásával.

```ruby
  get '/' do
    haml :index, :layout => !request.xhr?
  end
```

## Helperek

Használd a felső szintű <tt>helpers</tt> metódust azokhoz a helper
függvényekhez, amiket az útvonal metódusokban és a sablonokban akarsz
használni:

```ruby
  helpers do
    def bar(name)
      "#{name}bar"
    end
  end

  get '/:name' do
    bar(params['name'])
  end
```

## Szűrők (filters)

Az előszűrők (before filter) az adott hívás kontextusában minden egyes
kérés alkalmával kiértékelődnek, így módosíthatják a kérést és a
választ egyaránt. A szűrőkbe felvett példányváltozók elérhetőek lesznek
az útvonalakban és a sablonokban is:

```ruby
  before do
    @note = 'Csá!'
    request.path_info = '/foo/bar/baz'
  end

  get '/foo/*' do
    @note #=> 'Szeva!'
    params['splat'] #=> 'bar/baz'
  end
```

Az utószűrők az egyes kérések után, az adott kérés kontextusában kerülnek
kiértékelésre, így ezek is képesek módosítani a kérést és a választ egyaránt.
Az előszűrőkben és úvonalakban létrehozott példányváltozók elérhetőek lesznek
az utószűrők számára:

```ruby
  after do
    puts response.status
  end
```

## Megállítás

Egy kérés szűrőben vagy útvonalban történő azonnal blokkolásához
használd a következő parancsot:

  halt

A megállításkor egy blokktörzset is megadhatsz ...

  halt 'ez fog megjelenni a törzsben'

Vagy állítsd be a HTTP státuszt és a törzset is egyszerre ...

  halt 401, 'menj innen!'

## Passzolás

Az útvonalak továbbadhatják a végrehajtást egy másik útvonalnak
a `pass` függvényhívással:

```ruby
  get '/guess/:who' do
    pass unless params['who'] == 'Frici'
    "Elkaptál!"
  end

  get '/guess/*' do
    "Elhibáztál!"
  end
```

Az útvonal blokkja azonnal kilép és átadja a vezérlést a következő
illeszkedő útvonalnak. Ha nem talál megfelelő útvonalat, a Sinatra
egy 404-es hibával tér vissza.

## Beállítások

Csak indításkor, de minden környezetre érvényesen fusson le:

```ruby
  configure do
    ...
  end
```

Csak akkor fusson le, ha a környezet (a RACK_ENV környezeti változóban)
`:production`-ra van állítva:

```ruby
  configure :production do
    ...
  end
```

Csak akkor fusson le, ha a környezet <tt>:production</tt> vagy <tt>:test</tt>:

```ruby
  configure :production, :test do
    ...
  end
```

## Hibakezelés

A hibakezelők ugyanabban a kontextusban futnak le, mint az útvonalak és
előszűrők, ezért számukra is elérhetőek mindazok a könyvtárak, amelyek
az utóbbiak rendelkezésére is állnak; így például a `haml`,
az `erb`, a `halt` stb.

### Nem található

Amikor a `Sinatra::NotFound` kivétel fellép, vagy a válasz HTTP
státuszkódja 404-es, mindig a `not_found` metódus hívódik meg.

```ruby
  not_found do
    'Sehol sem találom, amit keresel'
  end
```

### Hiba

Az `error` metódus hívódik meg olyankor, amikor egy útvonal, blokk vagy
előszűrő kivételt vált ki. A kivétel objektum lehívható a
`sinatra.error` Rack változótól:

```ruby
  error do
    'Elnézést, de valami szörnyű hiba lépett fel - ' + env['sinatra.error'].message
  end
```

Egyéni hibakezelés:

```ruby
  error MyCustomError do
    'Szóval az van, hogy...' + env['sinatra.error'].message
  end
```

És amikor fellép:

```ruby
  get '/' do
    raise MyCustomError, 'valami nem stimmel!'
  end
```

Ez fog megjelenni:

  Szóval az van, hogy... valami nem stimmel!

A Sinatra speciális `not_found` és `error` hibakezelőket
használ, amikor a futtatási környezet fejlesztői módba van kapcsolva.

## Mime típusok

A `send_file` metódus használatakor, vagy statikus fájlok
kiszolgálásakor előfordulhat, hogy a Sinatra nem ismeri fel a fájlok
mime típusát. Ilyenkor használd a +mime_type+ kapcsolót a fájlkiterjesztés
bevezetéséhez:

```ruby
  mime_type :foo, 'text/foo'
```

## Rack Middleware

A Sinatra egy Ruby keretrendszerek számára kifejlesztett egyszerű és szabványos
interfészre, a [Rack](http://rack.github.io/) -re épül. A Rack fejlesztői
szempontból egyik legérdekesebb jellemzője, hogy támogatja az úgynevezett
"middleware" elnevezésű komponenseket, amelyek beékelődnek a szerver és az
alkalmazás közé, így képesek megfigyelni és/vagy módosítani a HTTP
kéréseket és válaszokat. Segítségükkel különféle, egységesen működő
funkciókat építhetünk be rendszerünkbe.

A Sinatra keretrendszerben gyerekjáték a Rack middleware-ek behúzása a
`use` metódus segítségével:

```ruby
  require 'sinatra'
  require 'my_custom_middleware'

  use Rack::Lint
  use MyCustomMiddleware

  get '/hello' do
    'Helló Világ'
  end
```

A `use` metódus szemantikája megegyezik a
[Rack::Builder](http://rubydoc.info/github/rack/rack/master/Rack/Builder) DSL-ben
használt +use+ metóduséval (az említett DSL-t leginkább rackup állományokban
használják). Hogy egy példát említsünk, a `use` metódus elfogad
változókat és blokkokat egyaránt, akár kombinálva is ezeket:

```ruby
  use Rack::Auth::Basic do |username, password|
    username == 'admin' && password == 'titkos'
  end
```

A Rack terjesztéssel egy csomó alap middleware komponens is érkezik,
amelyekkel a naplózás, URL útvonalak megadása, autentikáció és
munkamenet-kezelés könnyen megvalósítható. A Sinatra ezek közül elég
sokat automatikusan felhasznál a beállításoktól függően, így ezek
explicit betöltésével (+use+) nem kell bajlódnod.

## Tesztelés

Sinatra teszteket bármely Rack alapú tesztelő könyvtárral vagy
keretrendszerrel készíthetsz. Mi a [Rack::Test](http://gitrdoc.com/brynary/rack-test)
könyvtárat ajánljuk:

```ruby
  require 'my_sinatra_app'
  require 'rack/test'

  class MyAppTest < Minitest::Test
    include Rack::Test::Methods

    def app
      Sinatra::Application
    end

    def test_my_default
      get '/'
      assert_equal 'Helló Világ!', last_response.body
    end

    def test_with_params
      get '/meet', :name => 'Frici'
      assert_equal 'Helló Frici!', last_response.body
    end

    def test_with_rack_env
      get '/', {}, 'HTTP_USER_AGENT' => 'Songbird'
      assert_equal "Songbird-öt használsz!", last_response.body
    end
  end
```

Megjegyzés: A beépített Sinatra::Test és Sinatra::TestHarness osztályok
a 0.9.2-es kiadástól kezdve elavultnak számítanak.

## Sinatra::Base - Middleware-ek, könyvtárak és moduláris alkalmazások

Az alkalmazást felső szinten építeni megfelelhet mondjuk egy kisebb
app esetén, ám kifejezetten károsnak bizonyulhat olyan komolyabb,
újra felhasználható komponensek készítésekor, mint például egy Rack
middleware, Rails metal, egyszerűbb kiszolgáló komponenssel bíró
könyvtárak vagy éppen Sinatra kiterjesztések. A felső szintű DSL
bepiszkítja az Objektum névteret, ráadásul kisalkalmazásokra szabott
beállításokat feltételez (így például egyetlen alkalmazásfájl,
`./public`
és `./views` könyvtár meglétét, naplózást, kivételkezelő oldalt stb.).
Itt jön a képbe a Sinatra::Base osztály:

```ruby
  require 'sinatra/base'

  class MyApp < Sinatra::Base
    set :sessions, true
    set :foo, 'bar'

    get '/' do
      'Helló Világ!'
    end
  end
```

A MyApp osztály immár önálló Rack komponensként, mondjuk Rack middleware-ként
vagy alkalmazásként, esetleg Rails metal-ként is tud működni. Közvetlenül
használhatod (`use`) vagy futtathatod (`run`) az osztályodat egy rackup
konfigurációs állományban (`config.ru`), vagy egy szerverkomponenst
tartalmazó könyvtár vezérlésekor:

```ruby
   MyApp.run! :host => 'localhost', :port => 9090
```

A Sinatra::Base gyermekosztályaiban elérhető metódusok egyúttal a felső
szintű DSL-en keresztül is hozzáférhetők. A legtöbb felső szintű
alkalmazás átalakítható Sinatra::Base alapú komponensekké két lépésben:

* A fájlban nem a `sinatra`, hanem a `sinatra/base` osztályt kell
  beimportálni, mert egyébként az összes Sinatra DSL metódus a fő
  névtérbe kerül.
* Az alkalmazás útvonalait, hibakezelőit, szűrőit és beállításait
  a Sinatra::Base osztály gyermekosztályaiban kell megadni.

A `Sinatra::Base` osztály igazából egy üres lap: a legtöbb funkció
alapból ki van kapcsolva, beleértve a beépített szervert is. A
beállításokkal és az egyes kapcsolók hatásával az
[Options and Configuration](http://sinatra.github.com/configuration.html) lap
foglalkozik.

Széljegyzet: A Sinatra felső szintű DSL-je egy egyszerű delegációs
rendszerre épül. A Sinatra::Application osztály - a Sinatra::Base egy
speciális osztályaként - fogadja az összes :get, :put, :post,
:delete, :before, :error, :not_found, :configure és :set üzenetet,
ami csak a felső szintre beérkezik. Érdemes utánanézned a kódban,
miképp [kerül be](http://github.com/sinatra/sinatra/blob/master/lib/sinatra/main.rb#L25)
a [Sinatra::Delegator mixin](http://github.com/sinatra/sinatra/blob/master/lib/sinatra/base.rb#L1064)
a fő névtérbe.

## Parancssori lehetőségek

Sinatra alkalmazásokat közvetlenül futtathatunk:

```
  ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-s HANDLER]
```

Az alábbi kapcsolókat ismeri fel a rendszer:

  -h # segítség
  -p # a port beállítása (alapértelmezés szerint ez a 4567-es)
  -e # a környezet beállítása (alapértelmezés szerint ez a development)
  -s # a rack szerver/handler beállítása (alapértelmezetten ez a thin)
  -x # a mutex lock bekapcsolása (alapértelmezetten ki van kapcsolva)

## Fejlesztői változat

Ha a Sinatra legfrissebb, fejlesztői változatát szeretnéd használni,
készíts egy helyi másolatot és indítsd az alkalmazásodat úgy,
hogy a `sinatra/lib` könyvtár elérhető legyen a
`LOAD_PATH`-on:

```
  cd myapp
  git clone git://github.com/sinatra/sinatra.git
  ruby -Isinatra/lib myapp.rb
```

De hozzá is adhatod a <tt>sinatra/lib</tt> könyvtárat a <tt>LOAD_PATH</tt>-hoz
az alkalmazásodban:

```ruby
  $LOAD_PATH.unshift File.dirname(__FILE__) + '/sinatra/lib'
  require 'rubygems'
  require 'sinatra'

  get '/about' do
    "A következő változatot futtatom " + Sinatra::VERSION
  end
```

A Sinatra frissítését később így végezheted el:

```
  cd myproject/sinatra
  git pull
```

## További információk

* [A projekt weboldala](http://sinatra.github.com/) - Kiegészítő dokumentáció,
  hírek, hasznos linkek
* [Közreműködés](http://sinatra.github.com/contributing.html) - Hibát találtál?
  Segítségre van szükséged? Foltot küldenél be?
* [Lighthouse](http://sinatra.lighthouseapp.com) - Hibakövetés és kiadások
* [Twitter](http://twitter.com/sinatra)
* [Levelezőlista](http://groups.google.com/group/sinatrarb)
* [IRC: #sinatra](irc://chat.freenode.net/#sinatra) a http://freenode.net címen
# Sinatra

Sinatra is a [DSL](http://en.wikipedia.org/wiki/Domain-specific_language) for
quickly creating web applications in Ruby with minimal effort:

``` ruby
# myapp.rb
require 'sinatra'

get '/' do
  'Hello world!'
end
```

Install the gem:

``` shell
gem install sinatra
```

And run with:

``` shell
ruby myapp.rb
```

View at: http://localhost:4567

It is recommended to also run `gem install thin`, which Sinatra will
pick up if available.

## Table of Contents

* [Sinatra](#sinatra)
    * [Table of Contents](#table-of-contents)
    * [Routes](#routes)
    * [Conditions](#conditions)
    * [Return Values](#return-values)
    * [Custom Route Matchers](#custom-route-matchers)
    * [Static Files](#static-files)
    * [Views / Templates](#views--templates)
        * [Literal Templates](#literal-templates)
        * [Available Template Languages](#available-template-languages)
            * [Haml Templates](#haml-templates)
            * [Erb Templates](#erb-templates)
            * [Builder Templates](#builder-templates)
            * [Nokogiri Templates](#nokogiri-templates)
            * [Sass Templates](#sass-templates)
            * [SCSS Templates](#scss-templates)
            * [Less Templates](#less-templates)
            * [Liquid Templates](#liquid-templates)
            * [Markdown Templates](#markdown-templates)
            * [Textile Templates](#textile-templates)
            * [RDoc Templates](#rdoc-templates)
            * [AsciiDoc Templates](#asciidoc-templates)
            * [Radius Templates](#radius-templates)
            * [Markaby Templates](#markaby-templates)
            * [RABL Templates](#rabl-templates)
            * [Slim Templates](#slim-templates)
            * [Creole Templates](#creole-templates)
            * [MediaWiki Templates](#mediawiki-templates)
            * [CoffeeScript Templates](#coffeescript-templates)
            * [Stylus Templates](#stylus-templates)
            * [Yajl Templates](#yajl-templates)
            * [WLang Templates](#wlang-templates)
        * [Accessing Variables in Templates](#accessing-variables-in-templates)
        * [Templates with `yield` and nested layouts](#templates-with-yield-and-nested-layouts)
        * [Inline Templates](#inline-templates)
        * [Named Templates](#named-templates)
        * [Associating File Extensions](#associating-file-extensions)
        * [Adding Your Own Template Engine](#adding-your-own-template-engine)
        * [Using Custom Logic for Template Lookup](#using-custom-logic-for-template-lookup)
    * [Filters](#filters)
    * [Helpers](#helpers)
        * [Using Sessions](#using-sessions)
        * [Halting](#halting)
        * [Passing](#passing)
        * [Triggering Another Route](#triggering-another-route)
        * [Setting Body, Status Code and Headers](#setting-body-status-code-and-headers)
        * [Streaming Responses](#streaming-responses)
        * [Logging](#logging)
        * [Mime Types](#mime-types)
        * [Generating URLs](#generating-urls)
        * [Browser Redirect](#browser-redirect)
        * [Cache Control](#cache-control)
        * [Sending Files](#sending-files)
        * [Accessing the Request Object](#accessing-the-request-object)
        * [Attachments](#attachments)
        * [Dealing with Date and Time](#dealing-with-date-and-time)
        * [Looking Up Template Files](#looking-up-template-files)
    * [Configuration](#configuration)
        * [Configuring attack protection](#configuring-attack-protection)
        * [Available Settings](#available-settings)
    * [Environments](#environments)
    * [Error Handling](#error-handling)
        * [Not Found](#not-found)
        * [Error](#error)
    * [Rack Middleware](#rack-middleware)
    * [Testing](#testing)
    * [Sinatra::Base - Middleware, Libraries, and Modular Apps](#sinatrabase---middleware-libraries-and-modular-apps)
        * [Modular vs. Classic Style](#modular-vs-classic-style)
        * [Serving a Modular Application](#serving-a-modular-application)
        * [Using a Classic Style Application with a config.ru](#using-a-classic-style-application-with-a-configru)
        * [When to use a config.ru?](#when-to-use-a-configru)
        * [Using Sinatra as Middleware](#using-sinatra-as-middleware)
        * [Dynamic Application Creation](#dynamic-application-creation)
    * [Scopes and Binding](#scopes-and-binding)
        * [Application/Class Scope](#applicationclass-scope)
        * [Request/Instance Scope](#requestinstance-scope)
        * [Delegation Scope](#delegation-scope)
    * [Command Line](#command-line)
    * [Requirement](#requirement)
    * [The Bleeding Edge](#the-bleeding-edge)
        * [With Bundler](#with-bundler)
        * [Roll Your Own](#roll-your-own)
        * [Install Globally](#install-globally)
    * [Versioning](#versioning)
    * [Further Reading](#further-reading)

## Routes

In Sinatra, a route is an HTTP method paired with a URL-matching pattern.
Each route is associated with a block:

``` ruby
get '/' do
  .. show something ..
end

post '/' do
  .. create something ..
end

put '/' do
  .. replace something ..
end

patch '/' do
  .. modify something ..
end

delete '/' do
  .. annihilate something ..
end

options '/' do
  .. appease something ..
end

link '/' do
  .. affiliate something ..
end

unlink '/' do
  .. separate something ..
end
```

Routes are matched in the order they are defined. The first route that
matches the request is invoked.

Route patterns may include named parameters, accessible via the
`params` hash:

``` ruby
get '/hello/:name' do
  # matches "GET /hello/foo" and "GET /hello/bar"
  # params['name'] is 'foo' or 'bar'
  "Hello #{params['name']}!"
end
```

You can also access named parameters via block parameters:

``` ruby
get '/hello/:name' do |n|
  # matches "GET /hello/foo" and "GET /hello/bar"
  # params['name'] is 'foo' or 'bar'
  # n stores params['name']
  "Hello #{n}!"
end
```

Route patterns may also include splat (or wildcard) parameters, accessible
via the `params['splat']` array:

``` ruby
get '/say/*/to/*' do
  # matches /say/hello/to/world
  params['splat'] # => ["hello", "world"]
end

get '/download/*.*' do
  # matches /download/path/to/file.xml
  params['splat'] # => ["path/to/file", "xml"]
end
```

Or with block parameters:

``` ruby
get '/download/*.*' do |path, ext|
  [path, ext] # => ["path/to/file", "xml"]
end
```

Route matching with Regular Expressions:

``` ruby
get /\A\/hello\/([\w]+)\z/ do
  "Hello, #{params['captures'].first}!"
end
```

Or with a block parameter:

``` ruby
get %r{/hello/([\w]+)} do |c|
  # Matches "GET /meta/hello/world", "GET /hello/world/1234" etc.
  "Hello, #{c}!"
end
```

Route patterns may have optional parameters:

``` ruby
get '/posts.?:format?' do
  # matches "GET /posts" and any extension "GET /posts.json", "GET /posts.xml" etc.
end
```

Routes may also utilize query parameters:

``` ruby
get '/posts' do
  # matches "GET /posts?title=foo&author=bar"
  title = params['title']
  author = params['author']
  # uses title and author variables; query is optional to the /posts route
end
```

By the way, unless you disable the path traversal attack protection (see below),
the request path might be modified before matching against your routes.

## Conditions

Routes may include a variety of matching conditions, such as the user agent:

``` ruby
get '/foo', :agent => /Songbird (\d\.\d)[\d\/]*?/ do
  "You're using Songbird version #{params['agent'][0]}"
end

get '/foo' do
  # Matches non-songbird browsers
end
```

Other available conditions are `host_name` and `provides`:

``` ruby
get '/', :host_name => /^admin\./ do
  "Admin Area, Access denied!"
end

get '/', :provides => 'html' do
  haml :index
end

get '/', :provides => ['rss', 'atom', 'xml'] do
  builder :feed
end
```
`provides` searches the request's Accept header.

You can easily define your own conditions:

``` ruby
set(:probability) { |value| condition { rand <= value } }

get '/win_a_car', :probability => 0.1 do
  "You won!"
end

get '/win_a_car' do
  "Sorry, you lost."
end
```

For a condition that takes multiple values use a splat:

``` ruby
set(:auth) do |*roles|   # <- notice the splat here
  condition do
    unless logged_in? && roles.any? {|role| current_user.in_role? role }
      redirect "/login/", 303
    end
  end
end

get "/my/account/", :auth => [:user, :admin] do
  "Your Account Details"
end

get "/only/admin/", :auth => :admin do
  "Only admins are allowed here!"
end
```

## Return Values

The return value of a route block determines at least the response body passed
on to the HTTP client, or at least the next middleware in the Rack stack.
Most commonly, this is a string, as in the above examples. But other values are
also accepted.

You can return any object that would either be a valid Rack response, Rack
body object or HTTP status code:

* An Array with three elements: `[status (Fixnum), headers (Hash), response
  body (responds to #each)]`
* An Array with two elements: `[status (Fixnum), response body (responds to
  #each)]`
* An object that responds to `#each` and passes nothing but strings to
  the given block
* A Fixnum representing the status code

That way we can, for instance, easily implement a streaming example:

``` ruby
class Stream
  def each
    100.times { |i| yield "#{i}\n" }
  end
end

get('/') { Stream.new }
```

You can also use the `stream` helper method (described below) to reduce boiler
plate and embed the streaming logic in the route.

## Custom Route Matchers

As shown above, Sinatra ships with built-in support for using String patterns
and regular expressions as route matches. However, it does not stop there. You
can easily define your own matchers:

``` ruby
class AllButPattern
  Match = Struct.new(:captures)

  def initialize(except)
    @except   = except
    @captures = Match.new([])
  end

  def match(str)
    @captures unless @except === str
  end
end

def all_but(pattern)
  AllButPattern.new(pattern)
end

get all_but("/index") do
  # ...
end
```

Note that the above example might be over-engineered, as it can also be
expressed as:

``` ruby
get // do
  pass if request.path_info == "/index"
  # ...
end
```

Or, using negative look ahead:

``` ruby
get %r{^(?!/index$)} do
  # ...
end
```

## Static Files

Static files are served from the `./public` directory. You can specify
a different location by setting the `:public_folder` option:

``` ruby
set :public_folder, File.dirname(__FILE__) + '/static'
```

Note that the public directory name is not included in the URL. A file
`./public/css/style.css` is made available as
`http://example.com/css/style.css`.

Use the `:static_cache_control` setting (see below) to add
`Cache-Control` header info.

## Views / Templates

Each template language is exposed via its own rendering method. These
methods simply return a string:

``` ruby
get '/' do
  erb :index
end
```

This renders `views/index.erb`.

Instead of a template name, you can also just pass in the template content
directly:

``` ruby
get '/' do
  code = "<%= Time.now %>"
  erb code
end
```

Templates take a second argument, the options hash:

``` ruby
get '/' do
  erb :index, :layout => :post
end
```

This will render `views/index.erb` embedded in the
`views/post.erb` (default is `views/layout.erb`, if it exists).

Any options not understood by Sinatra will be passed on to the template
engine:

``` ruby
get '/' do
  haml :index, :format => :html5
end
```

You can also set options per template language in general:

``` ruby
set :haml, :format => :html5

get '/' do
  haml :index
end
```

Options passed to the render method override options set via `set`.

Available Options:

<dl>
  <dt>locals</dt>
  <dd>
    List of locals passed to the document. Handy with partials.
    Example: <tt>erb "<%= foo %>", :locals => {:foo => "bar"}</tt>
  </dd>

  <dt>default_encoding</dt>
  <dd>
    String encoding to use if uncertain. Defaults to
    <tt>settings.default_encoding</tt>.
  </dd>

  <dt>views</dt>
  <dd>
    Views folder to load templates from. Defaults to <tt>settings.views</tt>.
  </dd>

  <dt>layout</dt>
  <dd>
    Whether to use a layout (<tt>true</tt> or <tt>false</tt>). If it's a
    Symbol, specifies what template to use. Example:
    <tt>erb :index, :layout => !request.xhr?</tt>
  </dd>

  <dt>content_type</dt>
  <dd>
    Content-Type the template produces. Default depends on template language.
  </dd>

  <dt>scope</dt>
  <dd>
    Scope to render template under. Defaults to the application instance. If you
    change this, instance variables and helper methods will not be available.
  </dd>

  <dt>layout_engine</dt>
  <dd>
    Template engine to use for rendering the layout. Useful for languages that
    do not support layouts otherwise. Defaults to the engine used for the
    template. Example: <tt>set :rdoc, :layout_engine => :erb</tt>
  </dd>

  <dt>layout_options</dt>
  <dd>
    Special options only used for rendering the layout. Example:
    <tt>set :rdoc, :layout_options => { :views => 'views/layouts' }</tt>
  </dd>
</dl>

Templates are assumed to be located directly under the `./views` directory. To
use a different views directory:

``` ruby
set :views, settings.root + '/templates'
```


One important thing to remember is that you always have to reference templates
with symbols, even if they're in a subdirectory (in this case, use:
`:'subdir/template'` or `'subdir/template'.to_sym`). You must use a symbol
because otherwise rendering methods will render any strings passed to them
directly.

### Literal Templates

``` ruby
get '/' do
  haml '%div.title Hello World'
end
```

Renders the template string.

### Available Template Languages

Some languages have multiple implementations. To specify what implementation
to use (and to be thread-safe), you should simply require it first:

``` ruby
require 'rdiscount' # or require 'bluecloth'
get('/') { markdown :index }
```

#### Haml Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="http://haml.info/" title="haml">haml</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.haml</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>haml :index, :format => :html5</tt></td>
  </tr>
</table>

#### Erb Templates

<table>
  <tr>
    <td>Dependency</td>
    <td>
      <a href="http://www.kuwata-lab.com/erubis/" title="erubis">erubis</a>
      or erb (included in Ruby)
    </td>
  </tr>
  <tr>
    <td>File Extensions</td>
    <td><tt>.erb</tt>, <tt>.rhtml</tt> or <tt>.erubis</tt> (Erubis only)</td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>erb :index</tt></td>
  </tr>
</table>

#### Builder Templates

<table>
  <tr>
    <td>Dependency</td>
    <td>
      <a href="https://github.com/jimweirich/builder" title="builder">builder</a>
    </td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.builder</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>builder { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

It also takes a block for inline templates (see example).

#### Nokogiri Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="http://nokogiri.org/" title="nokogiri">nokogiri</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.nokogiri</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>nokogiri { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

It also takes a block for inline templates (see example).

#### Sass Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.sass</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>sass :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>

#### SCSS Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.scss</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>scss :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>

#### Less Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="http://www.lesscss.org/" title="less">less</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.less</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>less :stylesheet</tt></td>
  </tr>
</table>

#### Liquid Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="http://www.liquidmarkup.org/" title="liquid">liquid</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.liquid</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>liquid :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

Since you cannot call Ruby methods (except for `yield`) from a Liquid
template, you almost always want to pass locals to it.

#### Markdown Templates

<table>
  <tr>
    <td>Dependency</td>
    <td>
      Anyone of:
        <a href="https://github.com/rtomayko/rdiscount" title="RDiscount">RDiscount</a>,
        <a href="https://github.com/vmg/redcarpet" title="RedCarpet">RedCarpet</a>,
        <a href="http://deveiate.org/projects/BlueCloth" title="BlueCloth">BlueCloth</a>,
        <a href="http://kramdown.gettalong.org/" title="kramdown">kramdown</a>,
        <a href="https://github.com/bhollis/maruku" title="maruku">maruku</a>
    </td>
  </tr>
  <tr>
    <td>File Extensions</td>
    <td><tt>.markdown</tt>, <tt>.mkd</tt> and <tt>.md</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>markdown :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

It is not possible to call methods from markdown, nor to pass locals to it.
You therefore will usually use it in combination with another rendering
engine:

``` ruby
erb :overview, :locals => { :text => markdown(:introduction) }
```

Note that you may also call the `markdown` method from within other templates:

``` ruby
%h1 Hello From Haml!
%p= markdown(:greetings)
```

Since you cannot call Ruby from Markdown, you cannot use layouts written in
Markdown. However, it is possible to use another rendering engine for the
template than for the layout by passing the `:layout_engine` option.

#### Textile Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="http://redcloth.org/" title="RedCloth">RedCloth</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.textile</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>textile :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

It is not possible to call methods from textile, nor to pass locals to it. You
therefore will usually use it in combination with another rendering engine:

``` ruby
erb :overview, :locals => { :text => textile(:introduction) }
```

Note that you may also call the `textile` method from within other templates:

``` ruby
%h1 Hello From Haml!
%p= textile(:greetings)
```

Since you cannot call Ruby from Textile, you cannot use layouts written in
Textile. However, it is possible to use another rendering engine for the
template than for the layout by passing the `:layout_engine` option.

#### RDoc Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="http://rdoc.sourceforge.net/" title="RDoc">RDoc</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.rdoc</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>rdoc :README, :layout_engine => :erb</tt></td>
  </tr>
</table>

It is not possible to call methods from rdoc, nor to pass locals to it. You
therefore will usually use it in combination with another rendering engine:

``` ruby
erb :overview, :locals => { :text => rdoc(:introduction) }
```

Note that you may also call the `rdoc` method from within other templates:

``` ruby
%h1 Hello From Haml!
%p= rdoc(:greetings)
```

Since you cannot call Ruby from RDoc, you cannot use layouts written in
RDoc. However, it is possible to use another rendering engine for the
template than for the layout by passing the `:layout_engine` option.

#### AsciiDoc Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="http://asciidoctor.org/" title="Asciidoctor">Asciidoctor</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.asciidoc</tt>, <tt>.adoc</tt> and <tt>.ad</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>asciidoc :README, :layout_engine => :erb</tt></td>
  </tr>
</table>

Since you cannot call Ruby methods directly from an AsciiDoc template, you
almost always want to pass locals to it.

#### Radius Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="https://github.com/jlong/radius" title="Radius">Radius</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.radius</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>radius :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

Since you cannot call Ruby methods directly from a Radius template, you almost
always want to pass locals to it.

#### Markaby Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="http://markaby.github.com/" title="Markaby">Markaby</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.mab</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>markaby { h1 "Welcome!" }</tt></td>
  </tr>
</table>

It also takes a block for inline templates (see example).

#### RABL Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="https://github.com/nesquena/rabl" title="Rabl">Rabl</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.rabl</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>rabl :index</tt></td>
  </tr>
</table>

#### Slim Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="http://slim-lang.com/" title="Slim Lang">Slim Lang</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.slim</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>slim :index</tt></td>
  </tr>
</table>

#### Creole Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="https://github.com/minad/creole" title="Creole">Creole</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.creole</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>creole :wiki, :layout_engine => :erb</tt></td>
  </tr>
</table>

It is not possible to call methods from creole, nor to pass locals to it. You
therefore will usually use it in combination with another rendering engine:

``` ruby
erb :overview, :locals => { :text => creole(:introduction) }
```

Note that you may also call the `creole` method from within other templates:

``` ruby
%h1 Hello From Haml!
%p= creole(:greetings)
```

Since you cannot call Ruby from Creole, you cannot use layouts written in
Creole. However, it is possible to use another rendering engine for the
template than for the layout by passing the `:layout_engine` option.

#### MediaWiki Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="https://github.com/nricciar/wikicloth" title="WikiCloth">WikiCloth</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.mediawiki</tt> and <tt>.mw</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>mediawiki :wiki, :layout_engine => :erb</tt></td>
  </tr>
</table>

It is not possible to call methods from MediaWiki markup, nor to pass locals to
it. You therefore will usually use it in combination with another rendering
engine:

``` ruby
erb :overview, :locals => { :text => mediawiki(:introduction) }
```

Note that you may also call the `mediawiki` method from within other templates:

``` ruby
%h1 Hello From Haml!
%p= mediawiki(:greetings)
```

Since you cannot call Ruby from MediaWiki, you cannot use layouts written in
MediaWiki. However, it is possible to use another rendering engine for the
template than for the layout by passing the `:layout_engine` option.

#### CoffeeScript Templates

<table>
  <tr>
    <td>Dependency</td>
    <td>
      <a href="https://github.com/josh/ruby-coffee-script" title="Ruby CoffeeScript">
        CoffeeScript
      </a> and a
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        way to execute javascript
      </a>
    </td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.coffee</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>coffee :index</tt></td>
  </tr>
</table>

#### Stylus Templates

<table>
  <tr>
    <td>Dependency</td>
    <td>
      <a href="https://github.com/lucasmazza/ruby-stylus" title="Ruby Stylus">
        Stylus
      </a> and a
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        way to execute javascript
      </a>
    </td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.styl</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>stylus :index</tt></td>
  </tr>
</table>

Before being able to use Stylus templates, you need to load `stylus` and
`stylus/tilt` first:

``` ruby
require 'sinatra'
require 'stylus'
require 'stylus/tilt'

get '/' do
  stylus :example
end
```

#### Yajl Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="https://github.com/brianmario/yajl-ruby" title="yajl-ruby">yajl-ruby</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.yajl</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td>
      <tt>
        yajl :index,
             :locals => { :key => 'qux' },
             :callback => 'present',
             :variable => 'resource'
      </tt>
    </td>
  </tr>
</table>


The template source is evaluated as a Ruby string, and the
resulting json variable is converted using `#to_json`:

``` ruby
json = { :foo => 'bar' }
json[:baz] = key
```

The `:callback` and `:variable` options can be used to decorate the rendered
object:

``` javascript
var resource = {"foo":"bar","baz":"qux"};
present(resource);
```

#### WLang Templates

<table>
  <tr>
    <td>Dependency</td>
    <td><a href="https://github.com/blambeau/wlang/" title="WLang">WLang</a></td>
  </tr>
  <tr>
    <td>File Extension</td>
    <td><tt>.wlang</tt></td>
  </tr>
  <tr>
    <td>Example</td>
    <td><tt>wlang :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

Since calling ruby methods is not idiomatic in WLang, you almost always want to
pass locals to it. Layouts written in WLang and `yield` are supported, though.

### Accessing Variables in Templates

Templates are evaluated within the same context as route handlers. Instance
variables set in route handlers are directly accessible by templates:

``` ruby
get '/:id' do
  @foo = Foo.find(params['id'])
  haml '%h1= @foo.name'
end
```

Or, specify an explicit Hash of local variables:

``` ruby
get '/:id' do
  foo = Foo.find(params['id'])
  haml '%h1= bar.name', :locals => { :bar => foo }
end
```

This is typically used when rendering templates as partials from within
other templates.

### Templates with `yield` and nested layouts

A layout is usually just a template that calls `yield`.
Such a template can be used either through the `:template` option as
described above, or it can be rendered with a block as follows:

``` ruby
erb :post, :layout => false do
  erb :index
end
```

This code is mostly equivalent to `erb :index, :layout => :post`.

Passing blocks to rendering methods is most useful for creating nested layouts:

``` ruby
erb :main_layout, :layout => false do
  erb :admin_layout do
    erb :user
  end
end
```

This can also be done in fewer lines of code with:

``` ruby
erb :admin_layout, :layout => :main_layout do
  erb :user
end
```

Currently, the following rendering methods accept a block: `erb`, `haml`,
`liquid`, `slim `, `wlang`. Also the general `render` method accepts a block.

### Inline Templates

Templates may be defined at the end of the source file:

``` ruby
require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.title Hello world.
```

NOTE: Inline templates defined in the source file that requires sinatra are
automatically loaded. Call `enable :inline_templates` explicitly if you
have inline templates in other source files.

### Named Templates

Templates may also be defined using the top-level `template` method:

``` ruby
template :layout do
  "%html\n  =yield\n"
end

template :index do
  '%div.title Hello World!'
end

get '/' do
  haml :index
end
```

If a template named "layout" exists, it will be used each time a template
is rendered. You can individually disable layouts by passing
`:layout => false` or disable them by default via
`set :haml, :layout => false`:

``` ruby
get '/' do
  haml :index, :layout => !request.xhr?
end
```

### Associating File Extensions

To associate a file extension with a template engine, use
`Tilt.register`. For instance, if you like to use the file extension
`tt` for Textile templates, you can do the following:

``` ruby
Tilt.register :tt, Tilt[:textile]
```

### Adding Your Own Template Engine

First, register your engine with Tilt, then create a rendering method:

``` ruby
Tilt.register :myat, MyAwesomeTemplateEngine

helpers do
  def myat(*args) render(:myat, *args) end
end

get '/' do
  myat :index
end
```

Renders `./views/index.myat`. See https://github.com/rtomayko/tilt to
learn more about Tilt.

### Using Custom Logic for Template Lookup

To implement your own template lookup mechanism you can write your
own `#find_template` method:

``` ruby
configure do
  set :views [ './views/a', './views/b' ]
end

def find_template(views, name, engine, &block)
  Array(views).each do |v|
    super(v, name, engine, &block)
  end
end
```

## Filters

Before filters are evaluated before each request within the same
context as the routes will be and can modify the request and response. Instance
variables set in filters are accessible by routes and templates:

``` ruby
before do
  @note = 'Hi!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @note #=> 'Hi!'
  params['splat'] #=> 'bar/baz'
end
```

After filters are evaluated after each request within the same context as the
routes will be and can also modify the request and response. Instance variables
set in before filters and routes are accessible by after filters:

``` ruby
after do
  puts response.status
end
```

Note: Unless you use the `body` method rather than just returning a String from
the routes, the body will not yet be available in the after filter, since it is
generated later on.

Filters optionally take a pattern, causing them to be evaluated only if the
request path matches that pattern:

``` ruby
before '/protected/*' do
  authenticate!
end

after '/create/:slug' do |slug|
  session[:last_slug] = slug
end
```

Like routes, filters also take conditions:

``` ruby
before :agent => /Songbird/ do
  # ...
end

after '/blog/*', :host_name => 'example.com' do
  # ...
end
```

## Helpers

Use the top-level `helpers` method to define helper methods for use in
route handlers and templates:

``` ruby
helpers do
  def bar(name)
    "#{name}bar"
  end
end

get '/:name' do
  bar(params['name'])
end
```

Alternatively, helper methods can be separately defined in a module:

``` ruby
module FooUtils
  def foo(name) "#{name}foo" end
end

module BarUtils
  def bar(name) "#{name}bar" end
end

helpers FooUtils, BarUtils
```

The effect is the same as including the modules in the application class.

### Using Sessions

A session is used to keep state during requests. If activated, you have one
session hash per user session:

``` ruby
enable :sessions

get '/' do
  "value = " << session[:value].inspect
end

get '/:value' do
  session['value'] = params['value']
end
```

Note that `enable :sessions` actually stores all data in a cookie. This
might not always be what you want (storing lots of data will increase your
traffic, for instance). You can use any Rack session middleware: in order to
do so, do **not** call `enable :sessions`, but instead pull in your
middleware of choice as you would any other middleware:

``` ruby
use Rack::Session::Pool, :expire_after => 2592000

get '/' do
  "value = " << session[:value].inspect
end

get '/:value' do
  session['value'] = params['value']
end
```

To improve security, the session data in the cookie is signed with a session
secret. A random secret is generated for you by Sinatra. However, since this
secret will change with every start of your application, you might want to
set the secret yourself, so all your application instances share it:

``` ruby
set :session_secret, 'super secret'
```

If you want to configure it further, you may also store a hash with options in
the `sessions` setting:

``` ruby
set :sessions, :domain => 'foo.com'
```

To share your session across other apps on subdomains of foo.com, prefix the
domain with a *.* like this instead:

``` ruby
set :sessions, :domain => '.foo.com'
```

### Halting

To immediately stop a request within a filter or route use:

``` ruby
halt
```

You can also specify the status when halting:

``` ruby
halt 410
```

Or the body:

``` ruby
halt 'this will be the body'
```

Or both:

``` ruby
halt 401, 'go away!'
```

With headers:

``` ruby
halt 402, {'Content-Type' => 'text/plain'}, 'revenge'
```

It is of course possible to combine a template with `halt`:

``` ruby
halt erb(:error)
```

### Passing

A route can punt processing to the next matching route using `pass`:

``` ruby
get '/guess/:who' do
  pass unless params['who'] == 'Frank'
  'You got me!'
end

get '/guess/*' do
  'You missed!'
end
```

The route block is immediately exited and control continues with the next
matching route. If no matching route is found, a 404 is returned.

### Triggering Another Route

Sometimes `pass` is not what you want, instead you would like to get the result
of calling another route. Simply use `call` to achieve this:

``` ruby
get '/foo' do
  status, headers, body = call env.merge("PATH_INFO" => '/bar')
  [status, headers, body.map(&:upcase)]
end

get '/bar' do
  "bar"
end
```

Note that in the example above, you would ease testing and increase performance
by simply moving `"bar"` into a helper used by both `/foo` and `/bar`.

If you want the request to be sent to the same application instance rather than
a duplicate, use `call!` instead of `call`.

Check out the Rack specification if you want to learn more about `call`.

### Setting Body, Status Code and Headers

It is possible and recommended to set the status code and response body with the
return value of the route block. However, in some scenarios you might want to
set the body at an arbitrary point in the execution flow. You can do so with the
`body` helper method. If you do so, you can use that method from there on to
access the body:

``` ruby
get '/foo' do
  body "bar"
end

after do
  puts body
end
```

It is also possible to pass a block to `body`, which will be executed by the
Rack handler (this can be used to implement streaming, see "Return Values").

Similar to the body, you can also set the status code and headers:

``` ruby
get '/foo' do
  status 418
  headers \
    "Allow"   => "BREW, POST, GET, PROPFIND, WHEN",
    "Refresh" => "Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt"
  body "I'm a tea pot!"
end
```

Like `body`, `headers` and `status` with no arguments can be used to access
their current values.

### Streaming Responses

Sometimes you want to start sending out data while still generating parts of
the response body. In extreme examples, you want to keep sending data until
the client closes the connection. You can use the `stream` helper to avoid
creating your own wrapper:

``` ruby
get '/' do
  stream do |out|
    out << "It's gonna be legen -\n"
    sleep 0.5
    out << " (wait for it) \n"
    sleep 1
    out << "- dary!\n"
  end
end
```

This allows you to implement streaming APIs,
[Server Sent Events](http://dev.w3.org/html5/eventsource/), and can be used as
the basis for [WebSockets](http://en.wikipedia.org/wiki/WebSocket). It can also be
used to increase throughput if some but not all content depends on a slow
resource.

Note that the streaming behavior, especially the number of concurrent requests,
highly depends on the web server used to serve the application. Some servers,
like WEBRick, might not even support streaming at all. If the server does not
support streaming, the body will be sent all at once after the block passed to
`stream` finishes executing. Streaming does not work at all with Shotgun.

If the optional parameter is set to `keep_open`, it will not call `close` on
the stream object, allowing you to close it at any later point in the
execution flow. This only works on evented servers, like Thin and Rainbows.
Other servers will still close the stream:

``` ruby
# long polling

set :server, :thin
connections = []

get '/subscribe' do
  # register a client's interest in server events
  stream(:keep_open) do |out|
    connections << out
    # purge dead connections
    connections.reject!(&:closed?)
  end
end

post '/:message' do
  connections.each do |out|
    # notify client that a new message has arrived
    out << params['message'] << "\n"

    # indicate client to connect again
    out.close
  end

  # acknowledge
  "message received"
end
```

### Logging

In the request scope, the `logger` helper exposes a `Logger` instance:

``` ruby
get '/' do
  logger.info "loading data"
  # ...
end
```

This logger will automatically take your Rack handler's logging settings into
account. If logging is disabled, this method will return a dummy object, so
you do not have to worry about it in your routes and filters.

Note that logging is only enabled for `Sinatra::Application` by default, so if
you inherit from `Sinatra::Base`, you probably want to enable it yourself:

``` ruby
class MyApp < Sinatra::Base
  configure :production, :development do
    enable :logging
  end
end
```

To avoid any logging middleware to be set up, set the `logging` setting to
`nil`. However, keep in mind that `logger` will in that case return `nil`. A
common use case is when you want to set your own logger. Sinatra will use
whatever it will find in `env['rack.logger']`.

### Mime Types

When using `send_file` or static files you may have mime types Sinatra
doesn't understand. Use `mime_type` to register them by file extension:

``` ruby
configure do
  mime_type :foo, 'text/foo'
end
```

You can also use it with the `content_type` helper:

``` ruby
get '/' do
  content_type :foo
  "foo foo foo"
end
```

### Generating URLs

For generating URLs you should use the `url` helper method, for instance, in
Haml:

``` ruby
%a{:href => url('/foo')} foo
```

It takes reverse proxies and Rack routers into account, if present.

This method is also aliased to `to` (see below for an example).

### Browser Redirect

You can trigger a browser redirect with the `redirect` helper method:

``` ruby
get '/foo' do
  redirect to('/bar')
end
```

Any additional parameters are handled like arguments passed to `halt`:

``` ruby
redirect to('/bar'), 303
redirect 'http://google.com', 'wrong place, buddy'
```

You can also easily redirect back to the page the user came from with
`redirect back`:

``` ruby
get '/foo' do
  "<a href='/bar'>do something</a>"
end

get '/bar' do
  do_something
  redirect back
end
```

To pass arguments with a redirect, either add them to the query:

``` ruby
redirect to('/bar?sum=42')
```

Or use a session:

``` ruby
enable :sessions

get '/foo' do
  session[:secret] = 'foo'
  redirect to('/bar')
end

get '/bar' do
  session[:secret]
end
```

### Cache Control

Setting your headers correctly is the foundation for proper HTTP caching.

You can easily set the Cache-Control header like this:

``` ruby
get '/' do
  cache_control :public
  "cache it!"
end
```

Pro tip: Set up caching in a before filter:

``` ruby
before do
  cache_control :public, :must_revalidate, :max_age => 60
end
```

If you are using the `expires` helper to set the corresponding header,
`Cache-Control` will be set automatically for you:

``` ruby
before do
  expires 500, :public, :must_revalidate
end
```

To properly use caches, you should consider using `etag` or `last_modified`.
It is recommended to call those helpers *before* doing any heavy lifting, as
they will immediately flush a response if the client already has the current
version in its cache:

``` ruby
get "/article/:id" do
  @article = Article.find params['id']
  last_modified @article.updated_at
  etag @article.sha1
  erb :article
end
```

It is also possible to use a
[weak ETag](http://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation):

``` ruby
etag @article.sha1, :weak
```

These helpers will not do any caching for you, but rather feed the necessary
information to your cache. If you are looking for a quick reverse-proxy caching
solution, try [rack-cache](https://github.com/rtomayko/rack-cache):

``` ruby
require "rack/cache"
require "sinatra"

use Rack::Cache

get '/' do
  cache_control :public, :max_age => 36000
  sleep 5
  "hello"
end
```

Use the `:static_cache_control` setting (see below) to add
`Cache-Control` header info to static files.

According to RFC 2616, your application should behave differently if the If-Match
or If-None-Match header is set to `*`, depending on whether the resource
requested is already in existence. Sinatra assumes resources for safe (like get)
and idempotent (like put) requests are already in existence, whereas other
resources (for instance post requests) are treated as new resources. You
can change this behavior by passing in a `:new_resource` option:

``` ruby
get '/create' do
  etag '', :new_resource => true
  Article.create
  erb :new_article
end
```

If you still want to use a weak ETag, pass in a `:kind` option:

``` ruby
etag '', :new_resource => true, :kind => :weak
```

### Sending Files

To return the contents of a file as the response, you can use the `send_file`
helper method:

``` ruby
get '/' do
  send_file 'foo.png'
end
```

It also takes options:

``` ruby
send_file 'foo.png', :type => :jpg
```

The options are:

<dl>
  <dt>filename</dt>
    <dd>File name to be used in the response, defaults to the real file name.</dd>

  <dt>last_modified</dt>
    <dd>Value for Last-Modified header, defaults to the file's mtime.</dd>

  <dt>type</dt>
    <dd>Value for Content-Type header, guessed from the file extension if
    missing.</dd>

  <dt>disposition</dt>
    <dd>
      Value for Content-Disposition header, possible values: <tt>nil</tt>
      (default), <tt>:attachment</tt> and <tt>:inline</tt>
    </dd>

  <dt>length</dt>
    <dd>Value for Content-Length header, defaults to file size.</dd>

  <dt>status</dt>
    <dd>
      Status code to be sent. Useful when sending a static file as an error page.

      If supported by the Rack handler, other means than streaming from the Ruby
      process will be used. If you use this helper method, Sinatra will
      automatically handle range requests.
    </dd>
</dl>

### Accessing the Request Object

The incoming request object can be accessed from request level (filter, routes,
error handlers) through the `request` method:

``` ruby
# app running on http://example.com/example
get '/foo' do
  t = %w[text/css text/html application/javascript]
  request.accept              # ['text/html', '*/*']
  request.accept? 'text/xml'  # true
  request.preferred_type(t)   # 'text/html'
  request.body                # request body sent by the client (see below)
  request.scheme              # "http"
  request.script_name         # "/example"
  request.path_info           # "/foo"
  request.port                # 80
  request.request_method      # "GET"
  request.query_string        # ""
  request.content_length      # length of request.body
  request.media_type          # media type of request.body
  request.host                # "example.com"
  request.get?                # true (similar methods for other verbs)
  request.form_data?          # false
  request["some_param"]       # value of some_param parameter. [] is a shortcut to the params hash.
  request.referrer            # the referrer of the client or '/'
  request.user_agent          # user agent (used by :agent condition)
  request.cookies             # hash of browser cookies
  request.xhr?                # is this an ajax request?
  request.url                 # "http://example.com/example/foo"
  request.path                # "/example/foo"
  request.ip                  # client IP address
  request.secure?             # false (would be true over ssl)
  request.forwarded?          # true (if running behind a reverse proxy)
  request.env                 # raw env hash handed in by Rack
end
```

Some options, like `script_name` or `path_info`, can also be written:

``` ruby
before { request.path_info = "/" }

get "/" do
  "all requests end up here"
end
```

The `request.body` is an IO or StringIO object:

``` ruby
post "/api" do
  request.body.rewind  # in case someone already read it
  data = JSON.parse request.body.read
  "Hello #{data['name']}!"
end
```

### Attachments

You can use the `attachment` helper to tell the browser the response should be
stored on disk rather than displayed in the browser:

``` ruby
get '/' do
  attachment
  "store it!"
end
```

You can also pass it a file name:

``` ruby
get '/' do
  attachment "info.txt"
  "store it!"
end
```

### Dealing with Date and Time

Sinatra offers a `time_for` helper method that generates a Time object from the
given value. It is also able to convert `DateTime`, `Date` and similar classes:

``` ruby
get '/' do
  pass if Time.now > time_for('Dec 23, 2012')
  "still time"
end
```

This method is used internally by `expires`, `last_modified` and akin. You can
therefore easily extend the behavior of those methods by overriding `time_for`
in your application:

``` ruby
helpers do
  def time_for(value)
    case value
    when :yesterday then Time.now - 24*60*60
    when :tomorrow  then Time.now + 24*60*60
    else super
    end
  end
end

get '/' do
  last_modified :yesterday
  expires :tomorrow
  "hello"
end
```

### Looking Up Template Files

The `find_template` helper is used to find template files for rendering:

``` ruby
find_template settings.views, 'foo', Tilt[:haml] do |file|
  puts "could be #{file}"
end
```

This is not really useful. But it is useful that you can actually override this
method to hook in your own lookup mechanism. For instance, if you want to be
able to use more than one view directory:

``` ruby
set :views, ['views', 'templates']

helpers do
  def find_template(views, name, engine, &block)
    Array(views).each { |v| super(v, name, engine, &block) }
  end
end
```

Another example would be using different directories for different engines:

``` ruby
set :views, :sass => 'views/sass', :haml => 'templates', :default => 'views'

helpers do
  def find_template(views, name, engine, &block)
    _, folder = views.detect { |k,v| engine == Tilt[k] }
    folder ||= views[:default]
    super(folder, name, engine, &block)
  end
end
```

You can also easily wrap this up in an extension and share with others!

Note that `find_template` does not check if the file really exists but
rather calls the given block for all possible paths. This is not a performance
issue, since `render` will use `break` as soon as a file is found. Also,
template locations (and content) will be cached if you are not running in
development mode. You should keep that in mind if you write a really crazy
method.

## Configuration

Run once, at startup, in any environment:

``` ruby
configure do
  # setting one option
  set :option, 'value'

  # setting multiple options
  set :a => 1, :b => 2

  # same as `set :option, true`
  enable :option

  # same as `set :option, false`
  disable :option

  # you can also have dynamic settings with blocks
  set(:css_dir) { File.join(views, 'css') }
end
```

Run only when the environment (`RACK_ENV` environment variable) is set to
`:production`:

``` ruby
configure :production do
  ...
end
```

Run when the environment is set to either `:production` or `:test`:

```ruby
configure :production, :test do
  ...
end
```

You can access those options via `settings`:

``` ruby
configure do
  set :foo, 'bar'
end

get '/' do
  settings.foo? # => true
  settings.foo  # => 'bar'
  ...
end
```

### Configuring attack protection

Sinatra is using
[Rack::Protection](https://github.com/rkh/rack-protection#readme) to defend
your application against common, opportunistic attacks. You can easily disable
this behavior (which will open up your application to tons of common
vulnerabilities):

``` ruby
disable :protection
```

To skip a single defense layer, set `protection` to an options hash:

``` ruby
set :protection, :except => :path_traversal
```
You can also hand in an array in order to disable a list of protections:

``` ruby
set :protection, :except => [:path_traversal, :session_hijacking]
```

By default, Sinatra will only set up session based protection if `:sessions`
has been enabled. Sometimes you want to set up sessions on your own, though. In
that case you can get it to set up session based protections by passing the
`:session` option:

``` ruby
use Rack::Session::Pool
set :protection, :session => true
```

### Available Settings

<dl>
  <dt>absolute_redirects</dt>
  <dd>
    If disabled, Sinatra will allow relative redirects, however, Sinatra will no
    longer conform with RFC 2616 (HTTP 1.1), which only allows absolute redirects.
  </dd>
  <dd>
    Enable if your app is running behind a reverse proxy that has not been set up
    properly. Note that the <tt>url</tt> helper will still produce absolute URLs, unless you
    pass in <tt>false</tt> as the second parameter.
  </dd>
  <dd>Disabled by default.</dd>

  <dt>add_charset</dt>
  <dd>
    Mime types the <tt>content_type</tt> helper will automatically add the charset info to.
    You should add to it rather than overriding this option:
    <tt>settings.add_charset << "application/foobar"</tt>
  </dd>

  <dt>app_file</dt>
  <dd>
    Path to the main application file, used to detect project root, views and public
    folder and inline templates.
  </dd>

  <dt>bind</dt>
  <dd>IP address to bind to (default: <tt>0.0.0.0</tt> <em>or</em>
  <tt>localhost</tt> if your `environment` is set to development). Only used
  for built-in server.</dd>

  <dt>default_encoding</dt>
  <dd>Encoding to assume if unknown (defaults to <tt>"utf-8"</tt>).</dd>

  <dt>dump_errors</dt>
  <dd>Display errors in the log.</dd>

  <dt>environment</dt>
  <dd>
    Current environment. Defaults to <tt>ENV['RACK_ENV']</tt>, or
    <tt>"development"</tt> if not available.
  </dd>

  <dt>logging</dt>
  <dd>Use the logger.</dd>

  <dt>lock</dt>
  <dd>
    Places a lock around every request, only running processing on request
    per Ruby process concurrently.
  </dd>
  <dd>Enabled if your app is not thread-safe. Disabled per default.</dd>

  <dt>method_override</dt>
  <dd>
    Use <tt>_method</tt> magic to allow put/delete forms in browsers that
    don't support it.
  </dd>

  <dt>port</dt>
  <dd>Port to listen on. Only used for built-in server.</dd>

  <dt>prefixed_redirects</dt>
  <dd>
    Whether or not to insert <tt>request.script_name</tt> into redirects if no
    absolute path is given. That way <tt>redirect '/foo'</tt> would behave like
    <tt>redirect to('/foo')</tt>. Disabled per default.
  </dd>

  <dt>protection</dt>
  <dd>Whether or not to enable web attack protections. See protection section
  above.</dd>

  <dt>public_dir</dt>
  <dd>Alias for <tt>public_folder</tt>. See below.</dd>

  <dt>public_folder</dt>
  <dd>
    Path to the folder public files are served from. Only used if static
    file serving is enabled (see <tt>static</tt> setting below). Inferred from
    <tt>app_file</tt> setting if not set.
  </dd>

  <dt>reload_templates</dt>
  <dd>
    Whether or not to reload templates between requests. Enabled in development
    mode.
  </dd>

  <dt>root</dt>
  <dd>
    Path to project root folder. Inferred from <tt>app_file</tt> setting if not
    set.
  </dd>

  <dt>raise_errors</dt>
  <dd>
    Raise exceptions (will stop application). Enabled by default when
    <tt>environment</tt> is set to <tt>"test"</tt>, disabled otherwise.
  </dd>

  <dt>run</dt>
  <dd>
    If enabled, Sinatra will handle starting the web server. Do not
    enable if using rackup or other means.
  </dd>

  <dt>running</dt>
  <dd>Is the built-in server running now? Do not change this setting!</dd>

  <dt>server</dt>
  <dd>
    Server or list of servers to use for built-in server. Order indicates
    priority, default depends on Ruby implementation.
  </dd>

  <dt>sessions</dt>
  <dd>
    Enable cookie-based sessions support using <tt>Rack::Session::Cookie</tt>.
    See 'Using Sessions' section for more information.
  </dd>

  <dt>show_exceptions</dt>
  <dd>
    Show a stack trace in the browser when an exception happens. Enabled by
    default when <tt>environment</tt> is set to <tt>"development"</tt>,
    disabled otherwise.
  </dd>
  <dd>
    Can also be set to <tt>:after_handler</tt> to trigger app-specified error
    handling before showing a stack trace in the browser.
  </dd>

  <dt>static</dt>
  <dd>Whether Sinatra should handle serving static files.</dd>
  <dd>Disable when using a server able to do this on its own.</dd>
  <dd>Disabling will boost performance.</dd>
  <dd>
    Enabled per default in classic style, disabled for modular apps.
  </dd>

  <dt>static_cache_control</dt>
  <dd>
    When Sinatra is serving static files, set this to add <tt>Cache-Control</tt>
    headers to the responses. Uses the <tt>cache_control</tt> helper. Disabled
    by default.
  </dd>
  <dd>
    Use an explicit array when setting multiple values:
    <tt>set :static_cache_control, [:public, :max_age => 300]</tt>
  </dd>

  <dt>threaded</dt>
  <dd>
    If set to <tt>true</tt>, will tell Thin to use <tt>EventMachine.defer</tt>
    for processing the request.
  </dd>

  <dt>traps</dt>
  <dd>Whether Sinatra should handle system signals.</dd>

  <dt>views</dt>
  <dd>
    Path to the views folder. Inferred from <tt>app_file</tt> setting if
    not set.
  </dd>

  <dt>x_cascade</dt>
  <dd>
    Whether or not to set the X-Cascade header if no route matches.
    Defaults to <tt>true</tt>.
  </dd>
</dl>

## Environments

There are three predefined `environments`: `"development"`, `"production"` and
`"test"`. Environments can be set through the `RACK_ENV` environment variable.
The default value is `"development"`. In the `"development"` environment all
templates are reloaded between requests, and special `not_found` and `error`
handlers display stack traces in your browser. In the `"production"` and
`"test"` environments, templates are cached by default.

To run different environments, set the `RACK_ENV` environment variable:

``` shell
RACK_ENV=production ruby my_app.rb
```

You can use predefined methods: `development?`, `test?` and `production?` to
check the current environment setting:

``` ruby
get '/' do
  if settings.development?
    "development!"
  else
    "not development!"
  end
end
```

## Error Handling

Error handlers run within the same context as routes and before filters, which
means you get all the goodies it has to offer, like `haml`,
`erb`, `halt`, etc.

### Not Found

When a `Sinatra::NotFound` exception is raised, or the response's status
code is 404, the `not_found` handler is invoked:

``` ruby
not_found do
  'This is nowhere to be found.'
end
```

### Error

The `error` handler is invoked any time an exception is raised from a route
block or a filter. But note in development it will only run if you set the
show exceptions option to `:after_handler`:

```ruby
set :show_exceptions, :after_handler
```

The exception object can be obtained from the `sinatra.error` Rack variable:

``` ruby
error do
  'Sorry there was a nasty error - ' + env['sinatra.error'].message
end
```

Custom errors:

``` ruby
error MyCustomError do
  'So what happened was...' + env['sinatra.error'].message
end
```

Then, if this happens:

``` ruby
get '/' do
  raise MyCustomError, 'something bad'
end
```

You get this:

```
So what happened was... something bad
```

Alternatively, you can install an error handler for a status code:

``` ruby
error 403 do
  'Access forbidden'
end

get '/secret' do
  403
end
```

Or a range:

``` ruby
error 400..510 do
  'Boom'
end
```

Sinatra installs special `not_found` and `error` handlers when
running under the development environment to display nice stack traces
and additional debugging information in your browser.

## Rack Middleware

Sinatra rides on [Rack](http://rack.github.io/), a minimal standard
interface for Ruby web frameworks. One of Rack's most interesting capabilities
for application developers is support for "middleware" -- components that sit
between the server and your application monitoring and/or manipulating the
HTTP request/response to provide various types of common functionality.

Sinatra makes building Rack middleware pipelines a cinch via a top-level
`use` method:

``` ruby
require 'sinatra'
require 'my_custom_middleware'

use Rack::Lint
use MyCustomMiddleware

get '/hello' do
  'Hello World'
end
```

The semantics of `use` are identical to those defined for the
[Rack::Builder](http://rubydoc.info/github/rack/rack/master/Rack/Builder) DSL
(most frequently used from rackup files). For example, the `use` method
accepts multiple/variable args as well as blocks:

``` ruby
use Rack::Auth::Basic do |username, password|
  username == 'admin' && password == 'secret'
end
```

Rack is distributed with a variety of standard middleware for logging,
debugging, URL routing, authentication, and session handling. Sinatra uses
many of these components automatically based on configuration so you
typically don't have to `use` them explicitly.

You can find useful middleware in
[rack](https://github.com/rack/rack/tree/master/lib/rack),
[rack-contrib](https://github.com/rack/rack-contrib#readm),
or in the [Rack wiki](https://github.com/rack/rack/wiki/List-of-Middleware).

## Testing

Sinatra tests can be written using any Rack-based testing library or framework.
[Rack::Test](http://rdoc.info/github/brynary/rack-test/master/frames)
is recommended:

``` ruby
require 'my_sinatra_app'
require 'minitest/autorun'
require 'rack/test'

class MyAppTest < Minitest::Test
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_my_default
    get '/'
    assert_equal 'Hello World!', last_response.body
  end

  def test_with_params
    get '/meet', :name => 'Frank'
    assert_equal 'Hello Frank!', last_response.body
  end

  def test_with_rack_env
    get '/', {}, 'HTTP_USER_AGENT' => 'Songbird'
    assert_equal "You're using Songbird!", last_response.body
  end
end
```

Note: If you are using Sinatra in the modular style, replace
`Sinatra::Application` above with the class name of your app.

## Sinatra::Base - Middleware, Libraries, and Modular Apps

Defining your app at the top-level works well for micro-apps but has
considerable drawbacks when building reusable components such as Rack
middleware, Rails metal, simple libraries with a server component, or even
Sinatra extensions. The top-level assumes a micro-app style configuration
(e.g., a single application file, `./public` and `./views`
directories, logging, exception detail page, etc.). That's where
`Sinatra::Base` comes into play:

``` ruby
require 'sinatra/base'

class MyApp < Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Hello world!'
  end
end
```

The methods available to `Sinatra::Base` subclasses are exactly the same as
those available via the top-level DSL. Most top-level apps can be converted to
`Sinatra::Base` components with two modifications:

* Your file should require `sinatra/base` instead of `sinatra`;
  otherwise, all of Sinatra's DSL methods are imported into the main
  namespace.
* Put your app's routes, error handlers, filters, and options in a subclass
  of `Sinatra::Base`.

`Sinatra::Base` is a blank slate. Most options are disabled by default,
including the built-in server. See
[Configuring Settings](http://sinatra.github.com/configuration.html)
for details on available options and their behavior. If you want
behavior more similar to when you define your app at the top level (also
known as Classic style), you
can subclass `Sinatra::Application`.

``` ruby
require 'sinatra/base'

class MyApp < Sinatra::Application
  get '/' do
    'Hello world!'
  end
end
```

### Modular vs. Classic Style

Contrary to common belief, there is nothing wrong with the classic style. If it
suits your application, you do not have to switch to a modular application.

The main disadvantage of using the classic style rather than the modular style
is that you will only have one Sinatra application per Ruby process. If you
plan to use more than one, switch to the modular style. There is no reason you
cannot mix the modular and the classic styles.

If switching from one style to the other, you should be aware of slightly
different default settings:

<table>
  <tr>
    <th>Setting</th>
    <th>Classic</th>
    <th>Modular</th>
    <th>Modular</th>
  </tr>

  <tr>
    <td>app_file</td>
    <td>file loading sinatra</td>
    <td>file subclassing Sinatra::Base</td>
    <td>file subclassing Sinatra::Application</td>
  </tr>

  <tr>
    <td>run</td>
    <td>$0 == app_file</td>
    <td>false</td>
    <td>false</td>
  </tr>

  <tr>
    <td>logging</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>method_override</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>inline_templates</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>static</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>
</table>

### Serving a Modular Application

There are two common options for starting a modular app, actively starting with
`run!`:

``` ruby
# my_app.rb
require 'sinatra/base'

class MyApp < Sinatra::Base
  # ... app code here ...

  # start the server if ruby file executed directly
  run! if app_file == $0
end
```

Start with:

``` shell
ruby my_app.rb
```

Or with a `config.ru` file, which allows using any Rack handler:

``` ruby
# config.ru (run with rackup)
require './my_app'
run MyApp
```

Run:

``` shell
rackup -p 4567
```

### Using a Classic Style Application with a config.ru

Write your app file:

``` ruby
# app.rb
require 'sinatra'

get '/' do
  'Hello world!'
end
```

And a corresponding `config.ru`:

``` ruby
require './app'
run Sinatra::Application
```

### When to use a config.ru?

A `config.ru` file is recommended if:

* You want to deploy with a different Rack handler (Passenger, Unicorn,
  Heroku, ...).
* You want to use more than one subclass of `Sinatra::Base`.
* You want to use Sinatra only for middleware, and not as an endpoint.

**There is no need to switch to a `config.ru` simply because you switched to
the modular style, and you don't have to use the modular style for running with
a `config.ru`.**

### Using Sinatra as Middleware

Not only is Sinatra able to use other Rack middleware, any Sinatra application
can in turn be added in front of any Rack endpoint as middleware itself. This
endpoint could be another Sinatra application, or any other Rack-based
application (Rails/Ramaze/Camping/...):

``` ruby
require 'sinatra/base'

class LoginScreen < Sinatra::Base
  enable :sessions

  get('/login') { haml :login }

  post('/login') do
    if params['name'] == 'admin' && params['password'] == 'admin'
      session['user_name'] = params['name']
    else
      redirect '/login'
    end
  end
end

class MyApp < Sinatra::Base
  # middleware will run before filters
  use LoginScreen

  before do
    unless session['user_name']
      halt "Access denied, please <a href='/login'>login</a>."
    end
  end

  get('/') { "Hello #{session['user_name']}." }
end
```

### Dynamic Application Creation

Sometimes you want to create new applications at runtime without having to
assign them to a constant. You can do this with `Sinatra.new`:

``` ruby
require 'sinatra/base'
my_app = Sinatra.new { get('/') { "hi" } }
my_app.run!
```

It takes the application to inherit from as an optional argument:

```ruby
# config.ru (run with rackup)
require 'sinatra/base'

controller = Sinatra.new do
  enable :logging
  helpers MyHelpers
end

map('/a') do
  run Sinatra.new(controller) { get('/') { 'a' } }
end

map('/b') do
  run Sinatra.new(controller) { get('/') { 'b' } }
end
```

This is especially useful for testing Sinatra extensions or using Sinatra in
your own library.

This also makes using Sinatra as middleware extremely easy:

``` ruby
require 'sinatra/base'

use Sinatra do
  get('/') { ... }
end

run RailsProject::Application
```

## Scopes and Binding

The scope you are currently in determines what methods and variables are
available.

### Application/Class Scope

Every Sinatra application corresponds to a subclass of `Sinatra::Base`.
If you are using the top-level DSL (`require 'sinatra'`), then this
class is `Sinatra::Application`, otherwise it is the subclass you
created explicitly. At class level you have methods like `get` or `before`, but
you cannot access the `request` or `session` objects, as there is only a
single application class for all requests.

Options created via `set` are methods at class level:

``` ruby
class MyApp < Sinatra::Base
  # Hey, I'm in the application scope!
  set :foo, 42
  foo # => 42

  get '/foo' do
    # Hey, I'm no longer in the application scope!
  end
end
```

You have the application scope binding inside:

* Your application class body
* Methods defined by extensions
* The block passed to `helpers`
* Procs/blocks used as value for `set`
* The block passed to `Sinatra.new`

You can reach the scope object (the class) like this:

* Via the object passed to configure blocks (`configure { |c| ... }`)
* `settings` from within the request scope

### Request/Instance Scope

For every incoming request, a new instance of your application class is
created, and all handler blocks run in that scope. From within this scope you
can access the `request` and `session` objects or call rendering methods like
`erb` or `haml`. You can access the application scope from within the request
scope via the `settings` helper:

``` ruby
class MyApp < Sinatra::Base
  # Hey, I'm in the application scope!
  get '/define_route/:name' do
    # Request scope for '/define_route/:name'
    @value = 42

    settings.get("/#{params['name']}") do
      # Request scope for "/#{params['name']}"
      @value # => nil (not the same request)
    end

    "Route defined!"
  end
end
```

You have the request scope binding inside:

* get, head, post, put, delete, options, patch, link, and unlink blocks
* before and after filters
* helper methods
* templates/views

### Delegation Scope

The delegation scope just forwards methods to the class scope. However, it
does not behave exactly like the class scope, as you do not have the class
binding. Only methods explicitly marked for delegation are available, and you
do not share variables/state with the class scope (read: you have a different
`self`). You can explicitly add method delegations by calling
`Sinatra::Delegator.delegate :method_name`.

You have the delegate scope binding inside:

* The top level binding, if you did `require "sinatra"`
* An object extended with the `Sinatra::Delegator` mixin

Have a look at the code for yourself: here's the
[Sinatra::Delegator mixin](https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/base.rb#L1609-1633)
being [extending the main object](https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/main.rb#L28-30).

## Command Line

Sinatra applications can be run directly:

``` shell
ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-o HOST] [-s HANDLER]
```

Options are:

```
-h # help
-p # set the port (default is 4567)
-o # set the host (default is 0.0.0.0)
-e # set the environment (default is development)
-s # specify rack server/handler (default is thin)
-x # turn on the mutex lock (default is off)
```

## Requirement

The following Ruby versions are officially supported:
<dl>
  <dt>Ruby 1.8.7</dt>
  <dd>
    1.8.7 is fully supported, however, if nothing is keeping you from it, we
    recommend upgrading or switching to JRuby or Rubinius. Support for 1.8.7
    will not be dropped before Sinatra 2.0. Ruby 1.8.6 is no longer supported.
  </dd>

  <dt>Ruby 1.9.2</dt>
  <dd>
    1.9.2 is fully supported. Do not use 1.9.2p0, as it is known to cause
    segmentation faults when running Sinatra. Official support will continue
    at least until the release of Sinatra 1.5.
  </dd>

  <dt>Ruby 1.9.3</dt>
  <dd>
    1.9.3 is fully supported and recommended. Please note that switching to 1.9.3
    from an earlier version will invalidate all sessions. 1.9.3 will be supported
    until the release of Sinatra 2.0.
  </dd>

  <dt>Ruby 2.x</dt>
  <dd>
    2.x is fully supported and recommended. There are currently no plans to drop
    official support for it.
  </dd>

  <dt>Rubinius</dt>
  <dd>
    Rubinius is officially supported (Rubinius >= 2.x). It is recommended to
    <tt>gem install puma</tt>.
  </dd>

  <dt>JRuby</dt>
  <dd>
    The latest stable release of JRuby is officially supported. It is not
    recommended to use C extensions with JRuby. It is recommended to
    <tt>gem install trinidad</tt>.
  </dd>
</dl>

We also keep an eye on upcoming Ruby versions.

The following Ruby implementations are not officially supported but still are
known to run Sinatra:

* Older versions of JRuby and Rubinius
* Ruby Enterprise Edition
* MacRuby, Maglev, IronRuby
* Ruby 1.9.0 and 1.9.1 (but we do recommend against using those)

Not being officially supported means if things only break there and not on a
supported platform, we assume it's not our issue but theirs.

We also run our CI against ruby-head (future releases of MRI), but we can't
guarantee anything, since it is constantly moving. Expect upcoming 2.x releases
to be fully supported.

Sinatra should work on any operating system supported by the chosen Ruby
implementation.

If you run MacRuby, you should `gem install control_tower`.

Sinatra currently doesn't run on Cardinal, SmallRuby, BlueRuby or any
Ruby version prior to 1.8.7.

## The Bleeding Edge

If you would like to use Sinatra's latest bleeding-edge code, feel free to run your
application against the master branch, it should be rather stable.

We also push out prerelease gems from time to time, so you can do a

``` shell
gem install sinatra --pre
```

to get some of the latest features.

### With Bundler

If you want to run your application with the latest Sinatra, using
[Bundler](http://gembundler.com/) is the recommended way.

First, install bundler, if you haven't:

``` shell
gem install bundler
```

Then, in your project directory, create a `Gemfile`:

```ruby
source 'https://rubygems.org'
gem 'sinatra', :github => "sinatra/sinatra"

# other dependencies
gem 'haml'                    # for instance, if you use haml
gem 'activerecord', '~> 3.0'  # maybe you also need ActiveRecord 3.x
```

Note that you will have to list all your application's dependencies in the `Gemfile`.
Sinatra's direct dependencies (Rack and Tilt) will, however, be automatically
fetched and added by Bundler.

Now you can run your app like this:

``` shell
bundle exec ruby myapp.rb
```

### Roll Your Own

Create a local clone and run your app with the `sinatra/lib` directory
on the `$LOAD_PATH`:

``` shell
cd myapp
git clone git://github.com/sinatra/sinatra.git
ruby -I sinatra/lib myapp.rb
```

To update the Sinatra sources in the future:

``` shell
cd myapp/sinatra
git pull
```

### Install Globally

You can build the gem on your own:

``` shell
git clone git://github.com/sinatra/sinatra.git
cd sinatra
rake sinatra.gemspec
rake install
```

If you install gems as root, the last step should be:

``` shell
sudo rake install
```

## Versioning

Sinatra follows [Semantic Versioning](http://semver.org/), both SemVer and
SemVerTag.

## Further Reading

* [Project Website](http://www.sinatrarb.com/) - Additional documentation,
  news, and links to other resources.
* [Contributing](http://www.sinatrarb.com/contributing) - Find a bug? Need
  help? Have a patch?
* [Issue tracker](http://github.com/sinatra/sinatra/issues)
* [Twitter](http://twitter.com/sinatra)
* [Mailing List](http://groups.google.com/group/sinatrarb/topics)
* IRC: [#sinatra](irc://chat.freenode.net/#sinatra) on http://freenode.net
* [Sinatra Book](https://github.com/sinatra/sinatra-book/) Cookbook Tutorial
* [Sinatra Recipes](http://recipes.sinatrarb.com/) Community
  contributed recipes
* API documentation for the [latest release](http://rubydoc.info/gems/sinatra)
  or the [current HEAD](http://rubydoc.info/github/sinatra/sinatra) on
  http://rubydoc.info
* [CI server](http://travis-ci.org/sinatra/sinatra)
# Sinatra

*주의: 이 문서는 영문판의 번역본이며 최신판 문서와 다를 수 있습니다.*

Sinatra는 최소한의 노력으로 루비 기반 웹 애플리케이션을 신속하게 만들 수 있게
해 주는 [DSL](http://en.wikipedia.org/wiki/Domain-specific_language)입니다.

``` ruby
# myapp.rb
require 'sinatra'

get '/' do
  'Hello world!'
end
```

젬을 설치합니다.

``` shell
gem install sinatra
```

실행합니다.

``` shell
ruby myapp.rb
```

`http://localhost:4567`를 확인해 보세요.

`gem install thin`도 함께 실행하기를 권장합니다.
thin이 설치되어 있을 경우 Sinatra는 thin을 통해 실행합니다.

## 목차

* [Sinatra](#sinatra)
    * [목차](#목차)
    * [라우터(Routes)](#라우터routes)
        * [조건(Conditions)](#조건conditions)
        * [반환값(Return Values)](#반환값return-values)
        * [커스텀 라우터 매처(Custom Route Matchers)](#커스텀-라우터-매처custom-route-matchers)
    * [정적 파일(Static Files)](#정적-파일static-files)
    * [뷰 / 템플릿(Views / Templates)](#뷰--템플릿views--templates)
        * [리터럴 템플릿(Literal Templates)](#리터럴-템플릿literal-templates)
        * [가능한 템플릿 언어들(Available Template Languages)](#가능한-템플릿-언어들available-template-languages)
            * [Haml 템플릿](#haml-템플릿)
            * [Erb 템플릿](#erb-템플릿)
            * [Builder 템플릿](#builder-템플릿)
            * [Nokogiri 템플릿](#nokogiri-템플릿)
            * [Sass 템플릿](#sass-템플릿)
            * [SCSS 템플릿](#scss-템플릿)
            * [Less 템플릿](#less-템플릿)
            * [Liquid 템플릿](#liquid-템플릿)
            * [Markdown 템플릿](#markdown-템플릿)
            * [Textile 템플릿](#textile-템플릿)
            * [RDoc 템플릿](#rdoc-템플릿)
            * [AsciiDoc 템플릿](#asciidoc-템플릿)
            * [Radius 템플릿](#radius-템플릿)
            * [Markaby 템플릿](#markaby-템플릿)
            * [RABL 템플릿](#rabl-템플릿)
            * [Slim 템플릿](#slim-템플릿)
            * [Creole 템플릿](#creole-템플릿)
            * [MediaWiki 템플릿](#mediawiki-템플릿)
            * [CoffeeScript 템플릿](#coffeescript-템플릿)
            * [Stylus 템플릿](#stylus-템플릿)
            * [Yajl 템플릿](#yajl-템플릿)
            * [WLang 템플릿](#wlang-템플릿)
        * [템플릿에서 변수에 접근하기](#템플릿에서-변수에-접근하기)
        * [템플릿에서의 `yield` 와 중첩 레이아웃](#템플릿에서의-yield-와-중첩-레이아웃)
        * [인라인 템플릿](#인라인-템플릿)
        * [이름을 가지는 템플릿(Named Templates)](#이름을-가지는-템플릿named-templates)
        * [파일 확장자 연결하기](#파일-확장자-연결하기)
        * [나만의 고유한 템플릿 엔진 추가하기](#나만의-고유한-템플릿-엔진-추가하기)
        * [템플릿 검사를 위한 커스텀 로직 사용하기](#템플릿-검사를-위한-커스텀-로직-사용하기)
    * [필터(Filters)](#필터filters)
    * [헬퍼(Helpers)](#헬퍼helpers)
        * [세션(Sessions) 사용하기](#세션sessions-사용하기)
        * [중단하기(Halting)](#중단하기halting)
        * [넘기기(Passing)](#넘기기passing)
        * [다른 라우터 부르기(Triggering Another Route)](#다른-라우터-부르기triggering-another-route)
        * [본문, 상태 코드 및 헤더 설정하기](#본문-상태-코드-및-헤더-설정하기)
        * [응답 스트리밍(Streaming Responses)](#응답-스트리밍streaming-responses)
        * [로깅(Logging)](#로깅logging)
        * [마임 타입(Mime Types)](#마임-타입mime-types)
        * [URL 생성하기](#url-생성하기)
        * [브라우저 재지정(Browser Redirect)](#브라우저-재지정browser-redirect)
        * [캐시 컨트롤(Cache Control)](#캐시-컨트롤cache-control)
        * [파일 전송하기(Sending Files)](#파일-전송하기sending-files)
        * [요청 객체에 접근하기(Accessing the Request Object)](#요청-객체에-접근하기accessing-the-request-object)
        * [첨부(Attachments)](#첨부attachments)
        * [날짜와 시간 다루기](#날짜와-시간-다루기)
        * [템플릿 파일 참조하기](#템플릿-파일-참조하기)
    * [설정(Configuration)](#설정configuration)
        * [공격 방어 설정하기(Configuring attack protection)](#공격-방어-설정하기configuring-attack-protection)
        * [가능한 설정들(Available Settings)](#가능한-설정들available-settings)
    * [환경(Environments)](#환경environments)
    * [에러 처리(Error Handling)](#에러-처리error-handling)
        * [찾을 수 없음(Not Found)](#찾을-수-없음not-found)
        * [에러](#에러)
    * [Rack 미들웨어(Rack Middleware)](#rack-미들웨어rack-middleware)
    * [테스팅(Testing)](#테스팅testing)
    * [Sinatra::Base - 미들웨어(Middleware), 라이브러리(Libraries), 그리고 모듈 앱(Modular Apps)](#sinatrabase---미들웨어middleware-라이브러리libraries-그리고-모듈-앱modular-apps)
        * [모듈(Modular) vs. 전통적 방식(Classic Style)](#모듈modular-vs-전통적-방식classic-style)
        * [모듈 애플리케이션(Modular Application) 제공하기](#모듈-애플리케이션modular-application-제공하기)
        * [config.ru로 전통적 방식의 애플리케이션 사용하기](#configru로-전통적-방식의-애플리케이션-사용하기)
        * [언제 config.ru를 사용할까?](#언제-configru를-사용할까)
        * [Sinatra를 미들웨어로 사용하기](#sinatra를-미들웨어로-사용하기)
        * [동적인 애플리케이션 생성(Dynamic Application Creation)](#동적인-애플리케이션-생성dynamic-application-creation)
    * [범위(Scopes)와 바인딩(Binding)](#범위scopes와-바인딩binding)
        * [애플리케이션/클래스 범위](#애플리케이션클래스-범위)
        * [요청/인스턴스 범위](#요청인스턴스-범위)
        * [위임 범위(Delegation Scope)](#위임-범위delegation-scope)
    * [명령행(Command Line)](#명령행command-line)
    * [요구사항(Requirement)](#요구사항requirement)
    * [최신(The Bleeding Edge)](#최신the-bleeding-edge)
        * [Bundler를 사용하여](#bundler를-사용하여)
        * [직접 하기(Roll Your Own)](#직접-하기roll-your-own)
        * [전역으로 설치(Install Globally)](#전역으로-설치install-globally)
    * [버저닝(Versioning)](#버저닝versioning)
    * [더 읽을 거리(Further Reading)](#더-읽을-거리further-reading)

## 라우터(Routes)

Sinatra에서, 라우터(route)는 URL-매칭 패턴과 쌍을 이루는 HTTP 메서드입니다.
각각의 라우터는 블록과 연결됩니다.

``` ruby
get '/' do
  .. 무언가 보여주기(show) ..
end

post '/' do
  .. 무언가 만들기(create) ..
end

put '/' do
  .. 무언가 대체하기(replace) ..
end

patch '/' do
  .. 무언가 수정하기(modify) ..
end

delete '/' do
  .. 무언가 없애기(annihilate) ..
end

options '/' do
  .. 무언가 주기(appease) ..
end

link '/' do
  .. 무언가 관계맺기(affiliate) ..
end

unlink '/' do
  .. 무언가 격리하기(separate) ..
end
```

라우터는 정의된 순서에 따라 매치되고 요청에 대해 가장 먼저 매칭된 라우터가 호출됩니다.

라우터 패턴에는 이름을 가진 매개변수가 포함될 수 있으며, `params` 해시로 접근할 수 있습니다.

``` ruby
get '/hello/:name' do
  # "GET /hello/foo" 및 "GET /hello/bar"와 매치
  # params['name']은 'foo' 또는 'bar'
  "Hello #{params['name']}!"
end
```

또한 블록 매개변수를 통하여도 이름을 가진 매개변수에 접근할 수 있습니다.

``` ruby
get '/hello/:name' do |n|
  # "GET /hello/foo" 및 "GET /hello/bar"와 매치
  # params['name']은 'foo' 또는 'bar'
  # n 에는 params['name']가 저장
  "Hello #{n}!"
end
```

라우터 패턴에는 스플랫(splat, 또는 와일드카드)도 매개변수도 포함될 수 있으며, 이럴 경우 `params['splat']` 배열을 통해 접근할 수 있습니다.

``` ruby
get '/say/*/to/*' do
  # /say/hello/to/world와 매치
  params['splat'] # => ["hello", "world"]
end

get '/download/*.*' do
  # /download/path/to/file.xml과 매치
  params['splat'] # => ["path/to/file", "xml"]
end
```

블록 매개변수로도 접근할 수 있습니다.

``` ruby
get '/download/*.*' do |path, ext|
  [path, ext] # => ["path/to/file", "xml"]
end
```

라우터는 정규표현식으로 매치할 수 있습니다.

``` ruby
get /\A\/hello\/([\w]+)\z/ do
  "Hello, #{params['captures'].first}!"
end
```

블록 매개변수로도 사용가능합니다.

``` ruby
get %r{/hello/([\w]+)} do |c|
  # "GET /meta/hello/world", "GET /hello/world/1234" 등과 매치
  "Hello, #{c}!"
end
```

라우터 패턴에는 선택적인(optional) 매개변수도 올 수 있습니다.

``` ruby
get '/posts.?:format?' do
  # "GET /posts" 는 물론 "GET /posts.json", "GET /posts.xml" 와 같은 어떤 확장자와도 매칭
end
```

쿼리 파라메터로도 이용가능 합니다.

``` ruby
get '/posts' do
  # matches "GET /posts?title=foo&author=bar"
  title = params['title']
  author = params['author']
  # uses title and author variables; query is optional to the /posts route
end
```

한편, 경로 탐색 공격 방지(path traversal attack protection, 아래 참조)를 비활성화시키지 않았다면,
요청 경로는 라우터와 매칭되기 이전에 수정될 수 있습니다.

### 조건(Conditions)

라우터는 사용자 에이전트(user agent)같은 다양한 매칭 조건을 포함할 수 있습니다.

``` ruby
get '/foo', :agent => /Songbird (\d\.\d)[\d\/]*?/ do
  "Songbird 버전 #{params['agent'][0]}을 사용하는군요!"
end

get '/foo' do
  # songbird 브라우저가 아닌 경우 매치
end
```

다른 가능한 조건에는 `host_name`과 `provides`가 있습니다.

``` ruby
get '/', :host_name => /^admin\./ do
  "Admin Area, Access denied!"
end

get '/', :provides => 'html' do
  haml :index
end

get '/', :provides => ['rss', 'atom', 'xml'] do
  builder :feed
end
```
`provides`는 request의 허용된 해더를 검색합니다.

사용자 정의 조건도 쉽게 만들 수 있습니다.

``` ruby
set(:probability) { |value| condition { rand <= value } }

get '/win_a_car', :probability => 0.1 do
  "내가 졌소!"
end

get '/win_a_car' do
  "미안해서 어쩌나."
end
```

여러 값을 받는 조건에는 스플랫(splat)을 사용합니다.

``` ruby
set(:auth) do |*roles|   # <- 이게 스플랫
  condition do
    unless logged_in? && roles.any? {|role| current_user.in_role? role }
      redirect "/login/", 303
    end
  end
end

get "/my/account/", :auth => [:user, :admin] do
  "내 계정 정보"
end

get "/only/admin/", :auth => :admin do
  "관리자 외 접근불가!"
end
```

### 반환값(Return Values)

라우터 블록의 반환 값은 HTTP 클라이언트로 전달되는 응답 본문만을 결정하거나, 또는 Rack 스택에서 다음 번 미들웨어만를 결정합니다.
위의 예제에서 볼 수 있지만 대부분의 경우 이 반환값은 문자열입니다.하지만 다른 값도 허용됩니다.

유효한 Rack 응답, Rack 본문 객체 또는 HTTP 상태 코드가 되는 어떠한 객체라도 반환할 수 있습니다.

* 세 요소를 가진 배열: `[상태 (Fixnum), 헤더 (Hash), 응답 본문 (#each에 반응)]`
* 두 요소를 가진 배열: `[상태 (Fixnum), 응답 본문 (#each에 반응)]`
* `#each`에 반응하고 주어진 블록으로 문자열만을 전달하는 객체
* 상태 코드를 의미하는 Fixnum

이것을 이용한 예를 들자면, 스트리밍(streaming) 예제를 쉽게 구현할 수 있습니다.

``` ruby
class Stream
  def each
100.times { |i| yield "#{i}\n" }
  end
end

get('/') { Stream.new }
```

`stream` 헬퍼 메서드(아래 참조)를 사용하면 이런 번거로움을 줄이고 스트리밍 로직을 라우터 속에 포함 시킬 수도 있습니다.

### 커스텀 라우터 매처(Custom Route Matchers)

위에서 보듯, Sinatra에는 문자열 패턴 및 정규표현식을 이용한 라우터 매칭 지원이 내장되어 있습니다.
하지만, 그게 끝은 아닙니다. 여러분 만의 매처(matcher)도 쉽게 정의할 수 있습니다.

``` ruby
class AllButPattern
  Match = Struct.new(:captures)

  def initialize(except)
    @except   = except
    @captures = Match.new([])
  end

  def match(str)
    @captures unless @except === str
  end
end

def all_but(pattern)
  AllButPattern.new(pattern)
end

get all_but("/index") do
  # ...
end
```

사실 위의 예제는 조금 과하게 작성된 면이 있습니다. 간단하게 표현할 수도 있어요.

``` ruby
get // do
  pass if request.path_info == "/index"
  # ...
end
```

또는 거꾸로 탐색(negative look ahead)할 수도 있습니다.

``` ruby
get %r{^(?!/index$)} do
  # ...
end
```

## 정적 파일(Static Files)

정적 파일들은 `./public` 디렉터리에서 제공됩니다. 위치를 다른 곳으로
변경하려면 `:public_folder` 옵션을 지정하면 됩니다.

``` ruby
set :public_folder, File.dirname(__FILE__) + '/static'
```

public 디렉터리명은 URL에 포함되지 않는다는 점에 주의하세요.
`./public/css/style.css` 파일은 아마 `http://example.com/css/style.css` 로 접근할 수 있을 것 입니다.

`Cache-Control` 헤더 정보를 추가하려면 `:static_cache_control` 설정(아래 참조)을 사용하면 됩니다.

## 뷰 / 템플릿(Views / Templates)

템플릿 언어들은 각각의 렌더링 메서드를 통해 표출됩니다.
이들 메서드는 문자열을 반환할 뿐입니다.

``` ruby
get '/' do
  erb :index
end
```

이 구문은 `views/index.erb`를 렌더합니다.

템플릿 이름 대신 템플릿의 내용을 직접 넘길 수도 있습니다.

``` ruby
get '/' do
  code = "<%= Time.now %>"
  erb code
end
```

템플릿은 두 번째 인자로 옵션값의 해시를 받습니다.

``` ruby
get '/' do
  erb :index, :layout => :post
end
```

이 구문은 `views/post.erb` 속에 내장된 `views/index.erb`를 렌더합니다.
(`views/layout.erb`파일이 존재할 경우 기본값은 `views/layout.erb`입니다.)

Sinatra가 이해하지 못하는 모든 옵션값들은 템플릿 엔진으로 전달됩니다.

``` ruby
get '/' do
  haml :index, :format => :html5
end
```

옵션값은 템플릿 언어별로 전역적으로 설정할 수도 있습니다.

``` ruby
set :haml, :format => :html5

get '/' do
  haml :index
end
```

render 메서드에서 전달된 옵션값들은 `set`을 통해 설정한 옵션값보다 우선합니다.

가능한 옵션값들은 다음과 같습니다.

<dl>
  <dt>locals</dt>
  <dd>
    문서로 전달되는 local 목록. 파셜과 함께 사용하기 좋음.
    예제: <tt>erb "<%= foo %>", :locals => {:foo => "bar"}</tt>
  </dd>

  <dt>default_encoding</dt>
  <dd>
    불확실한 경우에 사용할 문자열 인코딩.
    기본값은 <tt>settings.default_encoding</tt>.
  </dd>

  <dt>views</dt>
  <dd>
    템플릿을 로드할 뷰 폴더.
    기본값은 <tt>settings.views</tt>.
  </dd>

  <dt>layout</dt>
  <dd>
    레이아웃을 사용할지 여부 (<tt>true</tt> 또는 <tt>false</tt>), 만약
    이 값이 심볼일 경우, 사용할 템플릿을 지정. 예제:
    <tt>erb :index, :layout => !request.xhr?</tt>
  </dd>

  <dt>content_type</dt>
  <dd>
    템플릿이 생성하는 Content-Type, 기본값은 템플릿 언어에 의존.
  </dd>

  <dt>scope</dt>
  <dd>
    템플릿을 렌더링하는 범위. 기본값은 어플리케이션 인스턴스.
    만약 이 값을 변경하면, 인스턴스 변수와 헬퍼 메서드들을 사용할 수 없게 됨.
  </dd>

  <dt>layout_engine</dt>
  <dd>
    레이아웃 렌더링에 사용할 템플릿 엔진. 레이아웃을 지원하지 않는 언어인 경우에 유용.
    기본값은 템플릿에서 사용하는 엔진. 예제: <tt>set :rdoc, :layout_engine => :erb</tt>
  </dd>
</dl>


템플릿은 `./views` 디렉터리에 있는 것으로 가정됩니다. 뷰 디렉터리를
다른 곳으로 하고 싶으시면 이렇게 하세요.

``` ruby
set :views, settings.root + '/templates'
```

템플릿은 언제나 심볼로 참조되어야 한다는 것에 주의하세요.
템플릿이 하위 디렉터리에 위치한 경우(그럴 경우에는 `:'subdir/template'`을
사용)에도 예외는 없습니다. 반드시 심볼이어야 하는 이유는, 문자열을 넘기면
렌더링 메서드가 전달된 문자열을 직접 렌더하기 때문입니다.

### 리터럴 템플릿(Literal Templates)

``` ruby
get '/' do
  haml '%div.title Hello World'
end
```

템플릿 문자열을 렌더합니다.

### 가능한 템플릿 언어들(Available Template Languages)

일부 언어는 여러 개의 구현이 있습니다. (스레드에 안전하게 thread-safe) 어느 구현을
사용할지 저정하려면, 먼저 require 하기만 하면 됩니다.

``` ruby
require 'rdiscount' # or require 'bluecloth'
get('/') { markdown :index }
```

#### Haml 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="http://haml.info/">haml</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.haml</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>haml :index, :format => :html5</tt></td>
  </tr>
</table>

#### Erb 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="http://www.kuwata-lab.com/erubis/">erubis</a> 또는 erb (루비 속에 포함)</td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.erb</tt>, <tt>.rhtml</tt>, <tt>.erubis</tt> (Erubis만 해당)</td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>erb :index</tt></td>
  </tr>
</table>

#### Builder 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="https://github.com/jimweirich/builder">builder</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.builder</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>builder { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

인라인 템플릿으로 블록을 받을 수도 있습니다(예제 참조).

#### Nokogiri 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="http://nokogiri.org/">nokogiri</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.nokogiri</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>nokogiri { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

인라인 템플릿으로 블록을 받을 수도 있습니다(예제 참조).

#### Sass 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="http://sass-lang.com/">sass</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.sass</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>sass :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>

#### SCSS 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="http://sass-lang.com/">sass</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.scss</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>scss :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>

#### Less 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="http://www.lesscss.org/">less</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.less</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>less :stylesheet</tt></td>
  </tr>
</table>

#### Liquid 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="http://www.liquidmarkup.org/">liquid</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.liquid</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>liquid :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

Liquid 템플릿에서는 루비 메서드(`yield` 제외)를 호출할 수 없기
때문에, 거의 대부분의 경우 locals를 전달해야 합니다.

#### Markdown 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td>
      <a href="https://github.com/rtomayko/rdiscount" title="RDiscount">RDiscount</a>,
      <a href="https://github.com/vmg/redcarpet" title="RedCarpet">RedCarpet</a>,
      <a href="http://deveiate.org/projects/BlueCloth" title="BlueCloth">BlueCloth</a>,
      <a href="http://kramdown.gettalong.org/" title="kramdown">kramdown</a>,
      <a href="https://github.com/bhollis/maruku" title="maruku">maruku</a>
      중 아무거나
    </td>
  </tr>
  <tr>
    <td>파일 확장</td>
    <td><tt>.markdown</tt>, <tt>.mkd</tt>,  <tt>.md</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>markdown :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

Markdown에서는 메서드 호출 뿐 아니라 locals 전달도 안됩니다.
따라서 일반적으로는 다른 렌더링 엔진과 함께 사용하게 됩니다.

``` ruby
erb :overview, :locals => { :text => markdown(:introduction) }
```

다른 템플릿 속에서 `markdown` 메서드를 호출할 수도 있습니다.

``` ruby
%h1 안녕 Haml!
%p= markdown(:greetings)
```

Markdown에서 루비를 호출할 수 없기 때문에, Markdown으로 작성된 레이아웃은
사용할 수 없습니다. 하지만, `:layout_engine` 옵션으로 레이아웃의 템플릿을
다른 렌더링 엔진으로 렌더링 할 수는 있습니다.

#### Textile 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="http://redcloth.org/">RedCloth</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.textile</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>textile :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

Textile에서는 메서드 호출 뿐 아니라 locals 전달도 안됩니다.
따라서 일반적으로는 다른 렌더링 엔진과 함께 사용하게 됩니다.

``` ruby
erb :overview, :locals => { :text => textile(:introduction) }
```

다른 템플릿 속에서 `textile` 메서드를 호출할 수도 있습니다.

``` ruby
%h1 안녕 Haml!
%p= textile(:greetings)
```

Textile에서 루비를 호출할 수 없기 때문에, Textile으로 작성된 레이아웃은
사용할 수 없습니다. 하지만, `:layout_engine` 옵션으로 레이아웃의 템플릿을
다른 렌더링 엔진으로 렌더링 할 수는 있습니다.

#### RDoc 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="http://rdoc.sourceforge.net/" title="RDoc">rdoc</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.rdoc</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>rdoc :README, :layout_engine => :erb</tt></td>
  </tr>
</table>

RDoc에서는 메서드 호출 뿐 아니라 locals 전달도 안됩니다.
따라서 일반적으로는 다른 렌더링 엔진과 함께 사용하게 됩니다.

``` ruby
erb :overview, :locals => { :text => rdoc(:introduction) }
```

다른 템플릿 속에서 `rdoc` 메서드를 호출할 수도 있습니다.

``` ruby
%h1 Hello From Haml!
%p= rdoc(:greetings)
```

RDoc에서 루비를 호출할 수 없기 때문에, RDoc으로 작성된 레이아웃은
사용할 수 없습니다. 하지만, `:layout_engine` 옵션으로 레이아웃의 템플릿을
다른 렌더링 엔진으로 렌더링 할 수는 있습니다.

#### AsciiDoc 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="http://asciidoctor.org/" title="Asciidoctor">Asciidoctor</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.asciidoc</tt>, <tt>.adoc</tt> and <tt>.ad</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>asciidoc :README, :layout_engine => :erb</tt></td>
  </tr>
</table>

AsciiDoc 템플릿에서는 루비 메서드를 호출할 수 없기
때문에, 거의 대부분의 경우 locals를 전달해야 합니다.

#### Radius 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="https://github.com/jlong/radius" title="Radius">radius</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.radius</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>radius :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

Radius 템플릿에서는 루비 메서드를 호출할 수 없기
때문에, 거의 대부분의 경우 locals를 전달해야 합니다.

#### Markaby 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="http://markaby.github.com/">markaby</a></td>
  </tr>
  <tr>
    <td>파일확장</td>
    <td><tt>.mab</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>markaby { h1 "Welcome!" }</tt></td>
  </tr>
</table>

인라인 템플릿으로 블록을 받을 수도 있습니다(예제 참조).

#### RABL 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="https://github.com/nesquena/rabl">rabl</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.rabl</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>rabl :index</tt></td>
  </tr>
</table>

#### Slim 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="http://slim-lang.com/">slim</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.slim</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>slim :index</tt></td>
  </tr>
</table>

#### Creole 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="https://github.com/minad/creole">creole</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.creole</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>creole :wiki, :layout_engine => :erb</tt></td>
  </tr>
</table>

Creole에서는 메서드 호출 뿐 아니라 locals 전달도 안됩니다.
따라서 일반적으로는 다른 렌더링 엔진과 함께 사용하게 됩니다.

``` ruby
erb :overview, :locals => { :text => creole(:introduction) }
```

다른 템플릿 속에서 `creole` 메서드를 호출할 수도 있습니다.

``` ruby
%h1 Hello From Haml!
%p= creole(:greetings)
```

Creole에서 루비를 호출할 수 없기 때문에, Creole으로 작성된 레이아웃은
사용할 수 없습니다. 하지만, `:layout_engine` 옵션으로 레이아웃의 템플릿을
다른 렌더링 엔진으로 렌더링 할 수는 있습니다.

#### MediaWiki 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="https://github.com/nricciar/wikicloth" title="WikiCloth">WikiCloth</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.mediawiki</tt> and <tt>.mw</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>mediawiki :wiki, :layout_engine => :erb</tt></td>
  </tr>
</table>

MediaWiki 마크업에서는 메서드 호출 뿐 아니라 locals 전달도 불가능합니다.
따라서 일반적으로는 다른 렌더링 엔진과 함께 사용하게 됩니다.

``` ruby
erb :overview, :locals => { :text => mediawiki(:introduction) }
```

다른 템플릿 속에서 `mediawiki` 메서드를 호출할 수도 있습니다.

``` ruby
%h1 Hello From Haml!
%p= mediawiki(:greetings)
```

MediaWiki에서 루비를 호출할 수 없기 때문에, MediaWiki으로 작성된 레이아웃은
사용할 수 없습니다. 하지만, `:layout_engine` 옵션으로 레이아웃의 템플릿을
다른 렌더링 엔진으로 렌더링 할 수는 있습니다.

#### CoffeeScript 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td>
      <a href="https://github.com/josh/ruby-coffee-script" title="Ruby CoffeeScript">
        CoffeeScript
      </a> 와
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        자바스크립트 실행법
      </a>
    </td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.coffee</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>coffee :index</tt></td>
  </tr>
</table>

#### Stylus 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td>
      <a href="https://github.com/lucasmazza/ruby-stylus" title="Ruby Stylus">
        Stylus
      </a> 와
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        자바스크립트 실행법
      </a>
    </td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.styl</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>stylus :index</tt></td>
  </tr>
</table>

Stylus 템플릿을 사용가능하게 하려면, 먼저 `stylus`와 `stylus/tilt`를 로드
해야합니다.

``` ruby
require 'sinatra'
require 'stylus'
require 'stylus/tilt'

get '/' do
  stylus :example
end
```

#### Yajl 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="https://github.com/brianmario/yajl-ruby">yajl-ruby</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.yajl</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td>
      <tt>
        yajl :index,
             :locals => { :key => 'qux' },
             :callback => 'present',
             :variable => 'resource'
      </tt>
    </td>
  </tr>
</table>

템플릿 소스는 루비 문자열로 평가(evaluate)되고, 결과인 json 변수는 `#to_json`으로 변환됩니다.

``` ruby
json = { :foo => 'bar' }
json[:baz] = key
```

`:callback`과 `:variable` 옵션은 렌더된 객체를 꾸미는데(decorate) 사용할 수 있습니다.

```javascript
var resource = {"foo":"bar","baz":"qux"};
present(resource);
```

#### WLang 템플릿

<table>
  <tr>
    <td>의존성</td>
    <td><a href="https://github.com/blambeau/wlang/" title="WLang">WLang</a></td>
  </tr>
  <tr>
    <td>파일 확장자</td>
    <td><tt>.wlang</tt></td>
  </tr>
  <tr>
    <td>예제</td>
    <td><tt>wlang :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

WLang 템플릿에서는 루비 메서드를 사용하는게 일반적이지 않기
때문에, 거의 대부분의 경우 locals를 전달합니다. 그래도
WLang으로 쓰여진 레이아웃과 `yield`는 지원합니다.

### 템플릿에서 변수에 접근하기

템플릿은 라우터 핸들러와 같은 맥락(context)에서 평가됩니다. 라우터
핸들러에서 설정한 인스턴스 변수들은 템플릿에서 직접 접근 가능합니다.

``` ruby
get '/:id' do
  @foo = Foo.find(params['id'])
  haml '%h1= @foo.name'
end
```

명시적으로 로컬 변수의 해시를 지정할 수도 있습니다.

``` ruby
get '/:id' do
  foo = Foo.find(params['id'])
  haml '%h1= bar.name', :locals => { :bar => foo }
end
```

이 방법은 주로 템플릿을 다른 템플릿 속에서 파셜(partial)로 렌더링할
때 사용됩니다.

### 템플릿에서의 `yield` 와 중첩 레이아웃

레이아웃은 보통 `yield`만 호출하는 템플릿입니다.
위에 설명된 `:template` 옵션을 통해 템플릿을 사용하거나,
다음 예제처럼 블록으로 렌더링 할 수 있습니다.

``` ruby
erb :post, :layout => false do
  erb :index
end
```

위 코드는 `erb :index, :layout => :post`와 대부분 동일합니다.

렌더링 메서드에 블록 넘기기는 중첩 레이아웃을 만들때 유용합니다.

``` ruby
erb :main_layout, :layout => false do
  erb :admin_layout do
    erb :user
  end
end
```

위의 코드도 줄일 수 있습니다.

``` ruby
erb :admin_layout, :layout => :main_layout do
  erb :user
end
```

현재, `erb`, `haml`, `liquid`, `slim `, `wlang`는 블럭을 지원합니다.
일반적인 `render` 메소드도 블럭을 지원합니다.

### 인라인 템플릿

템플릿은 소스 파일의 마지막에서 정의할 수도 있습니다.

``` ruby
require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
= yield

@@ index
%div.title Hello world.
```

참고: sinatra를 require한 소스 파일에 정의된 인라인 템플릿은 자동으로
로드됩니다. 다른 소스 파일에서 인라인 템플릿을 사용하려면 명시적으로
`enable :inline_templates`을 호출하면 됩니다.

### 이름을 가지는 템플릿(Named Templates)

템플릿은 톱 레벨(top-level)에서 `template`메서드로도 정의할 수 있습니다.

``` ruby
template :layout do
  "%html\n  =yield\n"
end

template :index do
  '%div.title Hello World!'
end

get '/' do
  haml :index
end
```

"layout"이라는 이름의 템플릿이 존재하면, 템플릿이 렌더될 때마다 사용됩니다.
레이아웃을 비활성화할 때는 `:layout => false`를 전달하여 개별적으로
비활성시키거나 `set :haml, :layout => false`으로 기본값을 비활성으로 둘 수
있습니다.

``` ruby
get '/' do
  haml :index, :layout => !request.xhr?
end
```

### 파일 확장자 연결하기

어떤 파일 확장자를 특정 템플릿 엔진과 연결하려면, `Tilt.register`를 사용하면
됩니다. 예를 들어, `tt`라는 파일 확장자를 Textile 템플릿과 연결하고 싶다면,
다음과 같이 하면 됩니다.

``` ruby
Tilt.register :tt, Tilt[:textile]
```

### 나만의 고유한 템플릿 엔진 추가하기

우선, Tilt로 여러분 엔진을 등록하고, 렌더링 메서드를 생성합니다.

``` ruby
Tilt.register :myat, MyAwesomeTemplateEngine

helpers do
  def myat(*args) render(:myat, *args) end
end

get '/' do
  myat :index
end
```

위 코드는 `./views/index.myat` 를 렌더합니다.
Tilt에 대한 더 자세한 내용은 https://github.com/rtomayko/tilt 참조하세요.

### 템플릿 검사를 위한 커스텀 로직 사용하기

고유한 템플릿 룩업을 구현하기 위해서는 `#find_template` 메서드를 만드셔야 합니다.

``` ruby
configure do
  set :views [ './views/a', './views/b' ]
end

def find_template(views, name, engine, &block)
  Array(views).each do |v|
    super(v, name, engine, &block)
  end
end
```

## 필터(Filters)

사전 필터(before filter)는 라우터와 동일한 맥락에서 매 요청 전에 평가되며
요청과 응답을 변형할 수 있습니다. 필터에서 설정된 인스턴스 변수들은 라우터와
템플릿에서 접근 가능합니다.

``` ruby
before do
  @note = 'Hi!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @note #=> 'Hi!'
  params['splat'] #=> 'bar/baz'
end
```

사후 필터(after filter)는 라우터와 동일한 맥락에서 매 요청 이후에 평가되며
마찬가지로 요청과 응답을 변형할 수 있습니다. 사전 필터와 라우터에서 설정된
인스턴스 변수들은 사후 필터에서 접근 가능합니다.

``` ruby
after do
  puts response.status
end
```

참고: 만약 라우터에서 `body` 메서드를 사용하지 않고 그냥 문자열만 반환한
경우라면, body는 나중에 생성되는 탓에, 아직 사후 필터에서 사용할 수 없을
것입니다.

필터는 패턴을 취할 수도 있으며, 이 경우 요청 경로가 그 패턴과 매치할
경우에만 필터가 평가될 것입니다.

``` ruby
before '/protected/*' do
  authenticate!
end

after '/create/:slug' do |slug|
  session['last_slug'] = slug
end
```

라우터와 마찬가지로, 필터 역시 조건을 취할 수 있습니다.

``` ruby
before :agent => /Songbird/ do
  # ...
end

after '/blog/*', :host_name => 'example.com' do
  # ...
end
```

## 헬퍼(Helpers)

톱-레벨의 `helpers` 메서드를 사용하여 라우터 핸들러와 템플릿에서 사용할 헬퍼
메서드들을 정의할 수 있습니다.

``` ruby
helpers do
  def bar(name)
    "#{name}bar"
  end
end

get '/:name' do
  bar(params['name'])
end
```

또는, 헬퍼 메서드는 별도의 모듈 속에 정의할 수도 있습니다.

``` ruby
module FooUtils
  def foo(name) "#{name}foo" end
end

module BarUtils
  def bar(name) "#{name}bar" end
end

helpers FooUtils, BarUtils
```

이 것은 모듈을 애플리케이션 클래스에 포함(include)시킨 것과 같습니다.

### 세션(Sessions) 사용하기

세션은 요청 동안에 상태를 유지하기 위해 사용합니다.
세션이 활성화되면, 사용자 세션 당 세션 해시 하나씩을 갖게 됩니다.

``` ruby
enable :sessions

get '/' do
  "value = " << session['value'].inspect
end

get '/:value' do
  session['value'] = params['value']
end
```

`enable :sessions`은 실은 모든 데이터를 쿠키 속에 저장하는 것에 주의하세요.
이 방식이 바람직하지 않을 수도 있습니다. (예를 들어, 많은 양의 데이터를
저장하게 되면 트래픽이 늘어납니다).
이런 경우에는 랙 세션 미들웨어(Rack session middleware)를 사용할 수 있습니다.
`enable :sessions`을 호출하지 **않는** 대신에, 선택한 미들웨어를 다른
미들웨어들처럼 포함시키면 됩니다.

``` ruby
use Rack::Session::Pool, :expire_after => 2592000

get '/' do
  "value = " << session['value'].inspect
end

get '/:value' do
  session['value'] = params['value']
end
```

보안 강화을 위해서, 쿠키 속의 세션 데이터는 세션 시크릿(secret)으로
사인(sign)됩니다. Sinatra는 무작위 시크릿을 생성합니다. 하지만, 이
시크릿은 애플리케이션 시작 시마다 변경되기 때문에, 애플리케이션의
모든 인스턴스들이 공유할 시크릿을 직접 만들 수도 있습니다.

``` ruby
set :session_secret, 'super secret'
```

조금 더 세부적인 설정이 필요하다면, `sessions` 설정에서 옵션이 있는
해시를 저장할 수도 있습니다.

``` ruby
set :sessions, :domain => 'foo.com'
```

세션을 다른 foo.com의 서브도메인 들과 공유하기 원한다면, 다음에 나오는
것 처럼 도메인 앞에 *.*을 붙이셔야 합니다.

``` ruby
set :sessions, :domain => '.foo.com'
```

### 중단하기(Halting)

필터나 라우터에서 요청을 즉각 중단하고 싶을 때 사용하합니다.

``` ruby
halt
```

중단할 때 상태를 지정할 수도 있습니다.

``` ruby
halt 410
```

본문을 넣을 수도 있습니다.

``` ruby
halt 'this will be the body'
```

둘 다 할 수도 있습니다.

``` ruby
halt 401, 'go away!'
```

헤더를 추가할 경우에는 다음과 같이 하면 됩니다.

``` ruby
halt 402, {'Content-Type' => 'text/plain'}, 'revenge'
```

당연히 `halt`와 템플릿은 같이 사용할 수 있습니다.

``` ruby
halt erb(:error)
```

### 넘기기(Passing)

라우터는 `pass`를 사용하여 다음 번 매칭되는 라우터로 처리를 넘길 수 있습니다.

``` ruby
get '/guess/:who' do
  pass unless params['who'] == 'Frank'
  'You got me!'
end

get '/guess/*' do
  'You missed!'
end
```

이 때 라우터 블록에서 즉각 빠져나오게 되고 제어는 다음 번 매칭되는 라우터로
넘어갑니다. 만약 매칭되는 라우터를 찾지 못하면, 404가 반환됩니다.

### 다른 라우터 부르기(Triggering Another Route)

때로는 `pass`가 아니라, 다른 라우터를 호출한 결과를 얻고 싶을 때도
있습니다. 이럴때는 간단하게 `call`을 사용하면 됩니다.

``` ruby
get '/foo' do
  status, headers, body = call env.merge("PATH_INFO" => '/bar')
  [status, headers, body.map(&:upcase)]
end

get '/bar' do
"bar"
end
```

위 예제의 경우, `"bar"`를 헬퍼로 옮겨 `/foo`와 `/bar` 모두에서 사용하도록
하면 테스팅을 쉽게 하고 성능을 높일 수 있습니다.

요청의 사본이 아닌 바로 그 인스턴스로 보내지도록 하고 싶다면,
`call` 대신 `call!`을 사용하면 됩니다.

`call`에 대한 더 자세한 내용은 Rack 명세를 참고하세요.

### 본문, 상태 코드 및 헤더 설정하기

라우터 블록의 반환값과 함께 상태 코드(status code)와 응답 본문(response body)을
설정할수 있고 권장됩니다. 하지만, 경우에 따라서는 본문을 실행 흐름 중의 임의
지점에서 설정해야 할때도 있습니다. 이런 경우 `body` 헬퍼 메서드를 사용하면
됩니다. 이렇게 하면, 그 순간부터 본문에 접근할 때 그 메서드를 사용할 수가 있습니다.

``` ruby
get '/foo' do
  body "bar"
end

after do
  puts body
end
```

`body`로 블록을 전달하는 것도 가능하며, 이 블록은 랙(Rack) 핸들러에 의해
실행됩니다. (이 방법은 스트리밍을 구현할 때 사용할 수 있습니다. "값
반환하기"를 참고하세요).

본문와 마찬가지로, 상태코드와 헤더도 설정할 수 있습니다.

``` ruby
get '/foo' do
  status 418
  headers \
"Allow"   => "BREW, POST, GET, PROPFIND, WHEN",
"Refresh" => "Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt"
  body "I'm a tea pot!"
end
```

`body`처럼, `header`와 `status`도 매개변수 없이 사용하여 현재 값을
액세스할 수 있습니다.

### 응답 스트리밍(Streaming Responses)

응답 본문의 일정 부분을 계속 생성하는 가운데 데이터를 내보내기 시작하고
싶을 경우가 있습니다. 극단적인 예제로, 클라이언트가 접속을 끊기 전까지
계속 데이터를 내보내고 싶을 경우도 있죠. 여러분만의 래퍼(wrapper)를
만들지 않으려면 `stream` 헬퍼를 사용하면 됩니다.

``` ruby
get '/' do
  stream do |out|
    out << "It's gonna be legen -\n"
    sleep 0.5
    out << " (wait for it) \n"
    sleep 1
    out << "- dary!\n"
  end
end
```

이렇게 스트리밍 API나 [서버 발송 이벤트Server Sent
Events](http://dev.w3.org/html5/eventsource/)를 구현할 수 있고, 이 방법은
[WebSockets](http://en.wikipedia.org/wiki/WebSocket)을 위한 기반으로 사용됩니다.
이 방법은 일부 콘텐츠가 느린 자원에 의존하는 경우에 스로풋(throughtput)을
높이기 위해 사용되기도 합니다.

스트리밍 동작, 특히 동시 요청의 수는 애플리케이션을 서빙하는 웹서버에 크게
의존합니다. WEBRick서버 같은 일부의 경우 아예 스트리밍을 지원하지 조차 않습니다.
만약 서버가 스트리밍을 지원하지 않는다면, 본문은 `stream` 으로 전달된 블록이
수행을 마친 후에 한꺼번에 반환됩니다. 이런 한번에 쏘는 샷건같은 방식으로는
스트리밍은 움직이지 않습니다.

선택적 매개변수 `keep_open`이 설정되어 있다면, 스트림 객체에서 `close`를
호출하지 않을 것이고, 나중에 실행 흐름 상의 어느 시점에서 스트림을 닫을 수
있습니다. 이 옵션은 Thin과 Rainbow 같은 이벤트 기반 서버에서만 작동하고
다른 서버들은 여전히 스트림을 닫습니다.

``` ruby
# long polling

set :server, :thin
connections = []

get '/subscribe' do
  # register a client's interest in server events
  stream(:keep_open) do |out|
    connections << out
    # purge dead connections
    connections.reject!(&:closed?)
  end
end

post '/:message' do
  connections.each do |out|
    # notify client that a new message has arrived
    out << params['message'] << "\n"

    # indicate client to connect again
    out.close
  end

  # acknowledge
  "message received"
end
```

### 로깅(Logging)

요청 스코프(request scope) 내에서, `Logger`의 인스턴스인 `logger`
헬퍼를 사용할 수 있습니다.

``` ruby
get '/' do
  logger.info "loading data"
  # ...
end
```

이 로거는 자동으로 Rack 핸들러에서 설정한 로그설정을  참고합니다.
만약 로깅이 비활성상태라면, 이 메서드는 더미(dummy) 객체를 반환하기 때문에,
라우터나 필터에서 이 부분에 대해 걱정할 필요는 없습니다.

로깅은 `Sinatra::Application`에서만 기본으로 활성화되어 있음에 유의합시다.
만약 `Sinatra::Base`로부터 상속받은 경우라면 직접 활성화시켜 줘야 합니다.

``` ruby
class MyApp < Sinatra::Base
  configure :production, :development do
    enable :logging
  end
end
```

로깅 미들웨어를 사용하지 않으려면, `logging` 설정을 `nil`로 두면 됩니다.
하지만, 이 경우 주의할 것은 `logger`는 `nil`을 반환하는 것입니다.
통상적인 유스케이스는 여러분만의 로거를 사용하고자 할 경우일 것입니다.
Sinatra는 `env['rack.logger']`에서 찾은 로거를 사용할 것입니다.

### 마임 타입(Mime Types)

`send_file`이나 정적인 파일을 사용할 때에 Sinatra가 인식하지 못하는
마임 타입이 있을 수 있습니다. 이 경우 `mime_type`을 사용하여 파일
확장자를 등록합니다.

``` ruby
configure do
  mime_type :foo, 'text/foo'
end
```

`content_type` 헬퍼로 쓸 수도 있습니다.

``` ruby
get '/' do
  content_type :foo
  "foo foo foo"
end
```

### URL 생성하기

URL을 생성할때 `url` 헬퍼 메서드를 사용합니다. 예를 들어 Haml에서는 이렇게
합니다.

``` ruby
%a{:href => url('/foo')} foo
```

이것은 리버스 프록시(reverse proxies)와 Rack 라우터가 있다면 참고합니다.

이 메서드는 `to`라는 별칭으로도 사용할 수 있습니다. (아래 예제 참조)

### 브라우저 재지정(Browser Redirect)

`redirect` 헬퍼 메서드를 사용하여 브라우저를 리다이렉트 시킬 수 있습니다.

``` ruby
get '/foo' do
  redirect to('/bar')
end
```

다른 부가적인 매개변수들은 `halt`에 전달하는 인자들과 비슷합니다.

``` ruby
redirect to('/bar'), 303
redirect 'http://google.com', 'wrong place, buddy'
```

`redirect back`을 사용하면 쉽게 사용자가 왔던 페이지로 다시 돌아가게
할 수 있습니다.

``` ruby
get '/foo' do
  "<a href='/bar'>do something</a>"
end

get '/bar' do
  do_something
  redirect back
end
```

리다이렉트와 함께 인자를 전달하려면, 쿼리로 붙이거나,

``` ruby
redirect to('/bar?sum=42')
```

세션을 사용하면 됩니다.

``` ruby
enable :sessions

get '/foo' do
  session['secret'] = 'foo'
  redirect to('/bar')
end

get '/bar' do
  session['secret']
end
```

### 캐시 컨트롤(Cache Control)

헤더를 정확하게 설정하는 것은 적절한 HTTP 캐싱의 기본입니다.

Cache-Control 헤더를 다음과 같이 간단하게 설정할 수 있습니다.

``` ruby
get '/' do
  cache_control :public
  "cache it!"
end
```

프로 팁: 캐싱은 사전 필터에서 설정하세요.

``` ruby
before do
  cache_control :public, :must_revalidate, :max_age => 60
end
```

`expires` 헬퍼를 사용하여 그에 상응하는 헤더를 설정한다면,
`Cache-Control`이 자동으로 설정됩니다.

``` ruby
before do
  expires 500, :public, :must_revalidate
end
```

캐시를 잘 사용하려면, `etag` 또는 `last_modified`을 사용해 보세요.
무거운 작업을 하기 *전*에 이들 헬퍼를 호출하길 권장합니다. 이렇게 하면,
클라이언트 캐시에 현재 버전이 이미 들어 있을 경우엔 즉각 응답을
뿌릴(flush) 것입니다.

``` ruby
get "/article/:id" do
  @article = Article.find params['id']
  last_modified @article.updated_at
  etag @article.sha1
  erb :article
end
```

[약한 ETag](http://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation)를
사용할 수 도 있습니다.

``` ruby
etag @article.sha1, :weak
```

이들 헬퍼는 어떠한 캐싱도 하지 않으며, 대신 캐시에 필요한 정보를 제공합니다.
손쉬운 리버스 프록시(reverse-proxy) 캐싱 솔루션을 찾고 있다면,
[rack-cache](https://github.com/rtomayko/rack-cache)를 써보세요.

``` ruby
require "rack/cache"
require "sinatra"

use Rack::Cache

get '/' do
  cache_control :public, :max_age => 36000
  sleep 5
  "hello"
end
```

정적 파일에 `Cache-Control` 헤더 정보를 추가하려면 `:static_cache_control`
설정(아래 참조)을 쓰세요.

RFC 2616에 따르면 If-Match 또는 If-None-Match 헤더가 `*`로 설정된 경우 요청한
리소스(resource)가 이미 존재하느냐 여부에 따라 다르게 취급해야 한다고 되어
있습니다. Sinatra는 (get 처럼) 안전하거나 (put 처럼) 멱등인 요청에 대한 리소스는
이미 존재한다고 가정하지만, 다른 리소스(예를 들면 post 요청 같은)의 경우는
새 리소스로 취급합니다. 이 행동은 `:new_resource` 옵션을 전달하여 변경할 수 있습니다.

``` ruby
get '/create' do
  etag '', :new_resource => true
  Article.create
  erb :new_article
end
```

약한 ETag를 사용하고자 한다면, `:kind`으로 전달합시다.

``` ruby
etag '', :new_resource => true, :kind => :weak
```

### 파일 전송하기(Sending Files)

응답(response)으로 파일의 컨탠츠를 리턴하려면, `send_file` 헬퍼 메서드를 사용하면 됩니다.

``` ruby
get '/' do
  send_file 'foo.png'
end
```

이 메서드는 몇 가지 옵션을 받습니다.

``` ruby
send_file 'foo.png', :type => :jpg
```

옵션들:

<dl>
  <dt>filename</dt>
    <dd>응답에서 사용되는 파일명. 기본값은 실제 파일명.</dd>

  <dt>last_modified</dt>
    <dd>Last-Modified 헤더값. 기본값은 파일의 mtime.</dd>

  <dt>type</dt>
    <dd>Content-Type 헤더값. 없으면 파일 확장자로부터 유추.</dd>

  <dt>disposition</dt>
    <dd>
      Content-Disposition 헤더값. 가능한 값들: <tt>nil</tt> (기본값),
      <tt>:attachment</tt> 및 <tt>:inline</tt>
    </dd>

  <dt>length</dt>
    <dd>Content-Length 헤더값, 기본값은 파일 크기.</dd>

  <dt>status</dt>
    <dd>
      전송할 상태 코드. 오류 페이지로 정적 파일을 전송할 경우에 유용.

      Rack 핸들러가 지원할 경우, Ruby 프로세스로부터의 스트리밍이 아닌
      다른 수단이 사용가능함. 이 헬퍼 메서드를 사용하게 되면, Sinatra는
      자동으로 범위 요청(range request)을 처리함.
    </dd>
</dl>


### 요청 객체에 접근하기(Accessing the Request Object)

들어오는 요청 객에는 요청 레벨(필터, 라우터, 오류 핸들러)에서 `request`
메서드를 통해 접근 가능합니다.

``` ruby
# http://example.com/example 상에서 실행 중인 앱
get '/foo' do
  t = %w[text/css text/html application/javascript]
  request.accept              # ['text/html', '*/*']
  request.accept? 'text/xml'  # true
  request.preferred_type(t)   # 'text/html'
  request.body                # 클라이언트로부터 전송된 요청 본문 (아래 참조)
  request.scheme              # "http"
  request.script_name         # "/example"
  request.path_info           # "/foo"
  request.port                # 80
  request.request_method      # "GET"
  request.query_string        # ""
  request.content_length      # request.body의 길이
  request.media_type          # request.body의 미디어 유형
  request.host                # "example.com"
  request.get?                # true (다른 동사에 대해 유사한 메서드 있음)
  request.form_data?          # false
  request["SOME_HEADER"]      # SOME_HEADER 헤더의 값
  request.referrer            # 클라이언트의 리퍼러 또는 '/'
  request.user_agent          # 사용자 에이전트 (:agent 조건에서 사용됨)
  request.cookies             # 브라우저 쿠키의 해시
  request.xhr?                # 이게 ajax 요청인가요?
  request.url                 # "http://example.com/example/foo"
  request.path                # "/example/foo"
  request.ip                  # 클라이언트 IP 주소
  request.secure?             # false (ssl 접속인 경우 true)
  request.forwarded?          # true (리버스 프록시 하에서 작동 중이라면)
  request.env                 # Rack에 의해 처리되는 로우(raw) env 해시
end
```

`script_name`, `path_info`같은 일부 옵션들은 이렇게 쓸 수도 있습니다.

``` ruby
before { request.path_info = "/" }

get "/" do
  "all requests end up here"
end
```

`request.body`는 IO 객체이거나 StringIO 객체입니다.

``` ruby
post "/api" do
  request.body.rewind  # 누군가 이미 읽은 경우
  data = JSON.parse request.body.read
  "Hello #{data['name']}!"
end
```

### 첨부(Attachments)

`attachment` 헬퍼를 사용하여 응답이 브라우저에 표시하는 대신
디스크에 저장되어야 함을 블라우저에게 알릴 수 있습니다.

``` ruby
get '/' do
  attachment
  "store it!"
end
```

파일명을 전달할 수도 있습니다.

``` ruby
get '/' do
  attachment "info.txt"
  "store it!"
end
```

### 날짜와 시간 다루기

Sinatra는 `time_for_` 헬퍼 메서드를 제공합니다. 이 메서드는
주어진 값으로부터 Time 객체를 생성한다. `DateTime`, `Date` 같은
비슷한 클래스들도 변환됩니다.

``` ruby
get '/' do
  pass if Time.now > time_for('Dec 23, 2012')
  "still time"
end
```

이 메서드는 내부적으로 `expires` 나 `last_modified` 같은 곳에서 사용됩니다.
따라서 여러분은 애플리케이션에서 `time_for`를 오버라이딩하여 이들 메서드의
동작을 쉽게 확장할 수 있습니다.

``` ruby
helpers do
  def time_for(value)
    case value
    when :yesterday then Time.now - 24*60*60
    when :tomorrow  then Time.now + 24*60*60
    else super
    end
  end
end

get '/' do
  last_modified :yesterday
  expires :tomorrow
  "hello"
end
```

### 템플릿 파일 참조하기

`find_template`는 렌더링할 템플릿 파일을 찾는데 사용됩니다.

``` ruby
find_template settings.views, 'foo', Tilt[:haml] do |file|
  puts "could be #{file}"
end
```

이것만으로는 그렇게 유용하지는 않습니다만, 이 메서드를 오버라이드하여 여러분만의
참조 메커니즘에서 가로채게 하면 유용해집니다. 예를 들어, 하나 이상의 뷰 디렉터리를
사용하고자 한다면 이렇게 하세요.

``` ruby
set :views, ['views', 'templates']

helpers do
  def find_template(views, name, engine, &block)
    Array(views).each { |v| super(v, name, engine, &block) }
  end
end
```

다른 예제는 각 엔진마다 다른 디렉터리를 사용할 경우입니다.

``` ruby
set :views, :sass => 'views/sass', :haml => 'templates', :default => 'views'

helpers do
  def find_template(views, name, engine, &block)
    _, folder = views.detect { |k,v| engine == Tilt[k] }
    folder ||= views[:default]
    super(folder, name, engine, &block)
  end
end
```

여러분은 이것을 간단하게 확장(extension)으로 만들어 다른 사람들과 공유할 수 있다!

`find_template`은 그 파일이 실제 존재하는지 검사하지 않음에 유의합니다.
모든 가능한 경로에 대해 주어진 블록을 호출할 뿐입니다. 이것은 성능 문제는
되지 않습니다. 왜냐하면 `render`는 파일이 발견되는 즉시 `break`하기 때문입니다.
또한, 템플릿 위치(그리고 콘텐츠)는 개발 모드에서 실행 중이 아니라면 캐시될 것입니다.
정말로 멋진 메세드를 작성하고 싶다면 이 점을 명심하세요.

## 설정(Configuration)

모든 환경에서, 시작될 때, 한번만 실행되게 하려면 이렇게 하면 됩니다.

``` ruby
configure do
  # 옵션 하나 설정
  set :option, 'value'

  # 여러 옵션 설정
  set :a => 1, :b => 2

  # `set :option, true`와 동일
  enable :option

  # `set :option, false`와 동일
  disable :option

  # 블록으로 동적인 설정을 할 수도 있음
  set(:css_dir) { File.join(views, 'css') }
end
```

환경(RACK_ENV 환경 변수)이 `:production`일 때만 실행되게 하려면 이렇게 하면 됩니다.

``` ruby
configure :production do
  ...
end
```

환경이 `:production` 또는 `:test`일 때 실행되게 하려면 이렇게 하면 됩니다.

``` ruby
configure :production, :test do
  ...
end
```

이 옵션들은 `settings`를 통해 접근 가능합니다.

``` ruby
configure do
  set :foo, 'bar'
end

get '/' do
  settings.foo? # => true
  settings.foo  # => 'bar'
  ...
end
```

### 공격 방어 설정하기(Configuring attack protection)

Sinatra는 [Rack::Protection](https://github.com/rkh/rack-protection#readme)을 사용하여
일반적이고 일어날 수 있는 공격에 대비합니다. 이 모듈은 간단하게 비활성시킬 수 있습니다.
(하지만 애플리케이션에 엄청나게 많은 취약성을 야기합니다.)

``` ruby
disable :protection
```

하나의 방어층만 스킵하려면, 옵션 해시에 `protection`을 설정하면 됩니다.

``` ruby
set :protection, :except => :path_traversal
```

배열로 넘김으로써 방어층 여러 개를 비활성화할 수 있습니다.

``` ruby
set :protection, :except => [:path_traversal, :session_hijacking]
```

기본적으로 `:sessions`가 활성 중일 때만 Sinatra는 방어층을 설정합니다.
때로는 자신만의 세션을 설정할 때도 있습니다. 이런 경우 `:session` 옵션을
넘겨줌으로써 세션을 기반으로한 방어층을 설정 할 수 있습니다.

``` ruby
use Rack::Session::Pool
set :protection, :session => true
```

### 가능한 설정들(Available Settings)

<dl>
  <dt>absolute_redirects</dt>
  <dd>
    만약 비활성이면, Sinatra는 상대경로 리다이렉트를 허용할 것이지만,
    이렇게 되면 Sinatra는 더 이상 오직 절대경로 리다이렉트만 허용하고 있는
    RFC 2616(HTTP 1.1)에 위배됨.
  </dd>
  <dd>
    적정하게 설정되지 않은 리버스 프록시 하에서 앱을 실행 중이라면 활성화시킬 것.
    <tt>rul</tt> 헬퍼는, 만약 두 번째 매개변수로 <tt>false</tt>를 전달하지만 않는다면,
    여전히 절대경로 URL을 생성할 것임에 유의.
  </dd>
  <dd>기본값은 비활성.</dd>

  <dt>add_charset</dt>
  <dd>
    <tt>content_type</tt>가 문자셋 정보에 자동으로 추가하게 될 마임(mime) 타입.
     이 옵션은 오버라이딩하지 말고 추가해야 함.
    <tt>settings.add_charset << "application/foobar"</tt>
  </dd>

  <dt>app_file</dt>
  <dd>
    메인 애플리케이션 파일의 경로. 프로젝트 루트, 뷰, public 폴더,
    인라인 템플릿을 파악할 때 사용됨.
  </dd>

  <dt>bind</dt>
  <dd>바인드할 IP 주소(기본값: <tt>0.0.0.0</tt> <em>이나</em>
  `environment`가 개발로 설정 되어있으면 <tt>localhost</tt>). 오직
  빌트인(built-in) 서버에서만 사용됨.</dd>

  <dt>default_encoding</dt>
  <dd>인코딩을 알 수 없을 때 인코딩(기본값은 <tt>"utf-8"</tt>).</dd>

  <dt>dump_errors</dt>
  <dd>로그안의 에러 출력.</dd>

  <dt>environment</dt>
  <dd>
    현재 환경, 기본값은 <tt>ENV['RACK_ENV']</tt> ENV에 없을 경우엔 "development".
  </dd>

  <dt>logging</dt>
  <dd>로거(logger) 사용.</dd>

  <dt>lock</dt>
  <dd>
    Ruby 프로세스 당 요청을 동시에 할 경우에만 매 요청에 걸쳐 잠금(lock)을 설정.
  </dd>
  <dd>앱이 스레드에 안전(thread-safe)하지 않으면 활성화시킬 것. 기본값은 비활성.</dd>

  <dt>method_override</dt>
  <dd>
    put/delete를 지원하지 않는 브라우저에서 put/delete 폼을 허용하는
    <tt>_method</tt> 꼼수 사용.
  </dd>

  <dt>port</dt>
  <dd>접속 포트. 빌트인 서버에서만 사용됨.</dd>

  <dt>prefixed_redirects</dt>
  <dd>
    절대경로가 주어지지 않은 리다이렉트에 <tt>request.script_name</tt>를
    삽입할지 여부를 결정. 활성화 하면 <tt>redirect '/foo'</tt>는
    <tt>redirect to('/foo')</tt>처럼 동작. 기본값은 비활성.
  </dd>

  <dt>protection</dt>
  <dd>웹 공격 방어를 활성화시킬 건지 여부. 위의 보안 섹션 참조.</dd>

  <dt>public_dir</dt>
  <dd><tt>public_folder</tt>의 별칭. 밑을 참조.</dd>

  <dt>public_folder</dt>
  <dd>
    public 파일이 제공될 폴더의 경로.
    static 파일 제공이 활성화된 경우만 사용됨(아래 <tt>static</tt>참조).
    만약 설정이 없으면 <tt>app_file</tt>로부터 유추됨.
  </dd>

  <dt>reload_templates</dt>
  <dd>
    요청 간에 템플릿을 리로드(reload)할 건지 여부. 개발 모드에서는 활성됨.
  </dd>

  <dt>root</dt>
  <dd>
    프로젝트 루트 디렉터리 경로. 설정이 없으면 <tt>app_file</tt> 설정으로부터 유추됨.
  </dd>

  <dt>raise_errors</dt>
  <dd>
    예외 발생(애플리케이션은 중단됨).
    기본값은 <tt>environment</tt>가 <tt>"test"</tt>인 경우는 활성, 그렇지 않으면 비활성.
  </dd>

  <dt>run</dt>
  <dd>
    활성화되면, Sinatra가 웹서버의 시작을 핸들링.
    rackup 또는 다른 도구를 사용하는 경우라면 활성화시키지 말 것.
  </dd>

  <dt>running</dt>
  <dd>빌트인 서버가 실행 중인가? 이 설정은 변경하지 말 것!</dd>

  <dt>server</dt>
  <dd>
    빌트인 서버로 사용할 서버 또는 서버 목록.
    기본값은 루비구현에 따라 다르며 순서는 우선순위를 의미.
  </dd>

  <dt>sessions</dt>
  <dd>
    <tt>Rack::Session::Cookie</tt>를 사용한 쿠키 기반 세션 활성화.
    보다 자세한 정보는 '세션 사용하기' 참조.
  </dd>

  <dt>show_exceptions</dt>
  <dd>
    예외 발생 시에 브라우저에 스택 추적을 보임.
    기본값은 <tt>environment</tt>가 <tt>"development"</tt>인
    경우는 활성, 나머지는 비활성.
  </dd>
  <dd>
    <tt>:after_handler</tt>를 설정함으로써 브라우저에서
    스택 트레이스를 보여주기 전에 앱에 특화된 에러 핸들링을
    할 수도 있음.
  </dd>

  <dt>static</dt>
  <dd>Sinatra가 정적(static) 파일을 핸들링할 지 여부를 설정.</dd>
  <dd>이 기능이 가능한 서버를 사용하는 경우라면 비활성시킬 것.</dd>
  <dd>비활성시키면 성능이 올라감.</dd>
  <dd>
    기본값은 전통적 방식에서는 활성, 모듈 앱에서는 비활성.
  </dd>

  <dt>static_cache_control</dt>
  <dd>
    Sinatra가 정적 파일을 제공하는 경우, 응답에 <tt>Cache-Control</tt> 헤더를
    추가할 때 설정. <tt>cache_control</tt> 헬퍼를 사용.
    기본값은 비활성.
  </dd>
  <dd>
    여러 값을 설정할 경우는 명시적으로 배열을 사용할 것:
    <tt>set :static_cache_control, [:public, :max_age => 300]</tt>
  </dd>

  <dt>threaded</dt>
  <dd>
    <tt>true</tt>로 설정하면, Thin이 요청을 처리하는데 있어
    <tt>EventMachine.defer</tt>를 사용하도록 함.
  </dd>

  <dt>views</dt>
  <dd>
    뷰 폴더 경로. 설정하지 않은 경우 <tt>app_file</tt>로부터 유추됨.
  </dd>

  <dt>x_cascade</dt>
  <dd>
    라우트를 찾지못했을 때의 X-Cascade 해더를 설정여부.
    기본값은 <tt>true</tt>
  </dd>
</dl>


## 환경(Environments)

3가지의 미리 정의된 `environments` `"development"`, `"production"`, `"test"`
가 있습니다. 환경은 `RACK_ENV` 환경 변수를 통해서도 설정됩니다. 기본값은
`"development"`입니다. `"development"` 모드에서는 모든 템플릿들은 요청 간에
리로드됩니다. 또, `"development"` 모드에서는 특별한 `not_found` 와 `error`
핸들러가 브라우저에서 스택 트레이스를 볼 수 있게합니다.
`"production"`과 `"test"`에서는 기본적으로 템플릿은 캐시됩니다.

다른 환경으로 실행시키려면 `RACK_ENV` 환경 변수를 사용하세요.

``` shell
RACK_ENV=production ruby my_app.rb
```

현재 설정된 환경이 무엇인지 검사하기 위해서는 준비된 `development?`, `test?`,
`production?` 메서드를 사용할 수 있습니다.

``` ruby
get '/' do
  if settings.development?
    "development!"
  else
    "not development!"
  end
end
```

## 에러 처리(Error Handling)

예외 핸들러는 라우터 및 사전 필터와 동일한 맥락에서 실행됩니다.
이 말인즉, `haml`, `erb`, `halt`같은 이들이 제공하는 모든  것들을 사용할 수
있다는 뜻입니다.

### 찾을 수 없음(Not Found)

`Sinatra::NotFound` 예외가 발생하거나 또는 응답의 상태 코드가 404라면,
`not_found` 핸들러가 호출됩니다.

``` ruby
not_found do
  '아무 곳에도 찾을 수 없습니다.'
end
```

### 에러

`error` 핸들러는 라우터 또는 필터에서 뭐든 오류가 발생할 경우에 호출됩니다.
하지만 개발 환경에서는 예외 확인 옵션을 `:after_handler`로 설정되어 있을 경우에만
실행됨을 주의하세요.

``` ruby
set :show_exceptions, :after_handler
```

예외 객체는 Rack 변수 `sinatra.error`로부터 얻을 수 있습니다.

``` ruby
error do
  '고약한 오류가 발생했군요 - ' + env['sinatra.error'].message
end
```

사용자 정의 오류는 이렇게 정의합니다.

``` ruby
error MyCustomError do
  '무슨 일이 생겼나면요...' + env['sinatra.error'].message
end
```

그런 다음, 이 오류가 발생하면 이렇게 처리합니다.

``` ruby
get '/' do
  raise MyCustomError, '안좋은 일'
end
```

결과는 이렇습니다.

```
무슨 일이 생겼냐면요... 안좋은 일
```

상태 코드에 대해 오류 핸들러를 설치할 수도 있습니다.

``` ruby
error 403 do
  '액세스가 금지됨'
end

get '/secret' do
  403
end
```

범위로 지정할 수도 있습니다.

``` ruby
error 400..510 do
  '어이쿠'
end
```

Sinatra는 개발 환경에서 동작할 때 브라우저에 괜찮은 스택 트레이스와 추가적인
디버그 정보를 보여주기 위해 특별한 `not_found` 와 `error` 핸들러를 설치합니다.

## Rack 미들웨어(Middleware)

Sinatra는 [Rack](http://rack.github.io/) 위에서 동작하며, Rack은 루비 웹
프레임워크를 위한 최소한의 표준 인터페이스입니다. Rack이 애플리케이션 개발자들에게
제공하는 가장 흥미로운 기능은 "미들웨어(middleware)"에 대한 지원입니다.
여기서 미들웨어란 서버와 여러분의 애플리케이션 사이에 위치하면서 HTTP 요청/응답을
모니터링하거나/조작함으로써 다양한 유형의 공통 기능을 제공하는 컴포넌트입니다.

Sinatra는 톱레벨의 `use` 메서드를 사용하여 Rack 미들웨어의 파이프라인을 만드는 일을
식은 죽 먹기로 만듭니다.

``` ruby
require 'sinatra'
require 'my_custom_middleware'

use Rack::Lint
use MyCustomMiddleware

get '/hello' do
  'Hello World'
end
```

`use`문법은 [Rack::Builder](http://rubydoc.info/github/rack/rack/master/Rack/Builder) DSL
(rackup 파일에서 가장 많이 사용)에서 정의한 것과 동일합니다. 예를 들어, `use` 메서드는
블록이나 여러 개의/가변적인 인자도 받을 수 있습니다.

``` ruby
use Rack::Auth::Basic do |username, password|
  username == 'admin' && password == 'secret'
end
```

Rack은 로깅, 디버깅, URL 라우팅, 인증, 그리고 세센 핸들링을 위한 다양한 표준
미들웨어로 분산되어 있습니다. Sinatra는 설정에 기반하여 이들 컴포넌트들 중
많은 것들을 자동으로 사용하며, 따라서 여러분은 일반적으로는 `use`를 명시적으로
사용할 필요가 없을 것입니다.

[rack](https://github.com/rack/rack/tree/master/lib/rack),
[rack-contrib](https://github.com/rack/rack-contrib#readme),
[Rack wiki](https://github.com/rack/rack/wiki/List-of-Middleware)
에서 유용한 미들웨어들을 찾을 수 있습니다.

## 테스팅(Testing)

Sinatra 테스트는 많은 Rack 기반 테스팅 라이브러리, 프레임워크를 사용하여 작성가능합니다.
그 중 [Rack::Test](http://rdoc.info/github/brynary/rack-test/master/frames)를 권장합니다.

``` ruby
require 'my_sinatra_app'
require 'minitest/autorun'
require 'rack/test'

class MyAppTest < Minitest::Test
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_my_default
    get '/'
    assert_equal 'Hello World!', last_response.body
  end

  def test_with_params
    get '/meet', :name => 'Frank'
    assert_equal 'Hello Frank!', last_response.body
  end

  def test_with_rack_env
    get '/', {}, 'HTTP_USER_AGENT' => 'Songbird'
    assert_equal "You're using Songbird!", last_response.body
  end
end
```

주의: Sinatra를 모듈러 방식으로 사용한다면, `Sinatra::Application`
를 앱에서 사용하는 클래스 이름으로 바꾸세요.

## Sinatra::Base - 미들웨어(Middleware), 라이브러리(Libraries), 그리고 모듈 앱(Modular Apps)

톱레벨에서 앱을 정의하는 것은 마이크로 앱(micro-app) 수준에서는 잘 동작하지만,
Rack 미들웨어나, Rails 메탈(metal) 또는 서버 컴포넌트를 갖는 간단한 라이브러리,
또는 더 나아가 Sinatra 익스텐션(extension) 같은 재사용 가능한 컴포넌트들을 구축할
경우에는 심각한 약점이 있습니다. 톱레벨은 마이크로 앱 스타일의 설정을 가정하는 것
입니다. (즉, 하나의 단일 애플리케이션 파일과 `./public` 및 `./views` 디렉터리,
로깅, 예외 상세 페이지 등등). 이 곳에서 `Sinatra::Base`가 필요합니다.

``` ruby
require 'sinatra/base'

class MyApp < Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Hello world!'
  end
end
```

`Sinatra::Base` 서브클래스에서 사용가능한 메서드들은 톱레벨 DSL로 접근 가능한 것들과
동일합니다. 대부분의 톱레벨 앱들은 다음 두 가지만 수정하면 `Sinatra::Base` 컴포넌트로
변환 가능합니다.

* 파일은 `sinatra`가 아닌 `sinatra/base`를 require해야 합니다.
  그렇지 않으면 모든 Sinatra의 DSL 메서드들이 메인 네임스페이스에 불러지게
  됩니다.
* 앱의 라우터, 예외 핸들러, 필터, 옵션은 `Sinatra::Base`의 서브클래스에 두어야
  합니다.

`Sinatra::Base`는 백지상태(blank slate)입니다. 빌트인 서버를 비롯한 대부분의 옵션들이
기본값으로 꺼져 있습니다. 가능한 옵션들과 그 작동에 대한 상세는 [옵션과
설정](http://sinatra.github.com/configuration.html)을 참조하세요.

### 모듈(Modular) vs. 전통적 방식(Classic Style)

일반적인 믿음과는 반대로, 전통적 방식에 잘못된 부분은 없습니다. 여러분 애플리케이션에
맞다면, 모듈 애플리케이션으로 전환할 필요는 없습니다.

모듈 방식이 아닌 전통적 방식을 사용할 경우 생기는 주된 단점은 루비 프로세스 당
하나의 Sinatra 애플리케이션만 사용할 수 있다는 점입니다. 만약 하나 이상을 사용할
계획이라면 모듈 방식으로 전환하세요. 모듈 방식과 전통적 방식을 섞어쓰지 못할
이유는 없습니다.

방식을 전환할 경우에는, 기본값 설정의 미묘한 차이에 유의해야 합니다.

<table>
  <tr>
    <th>설정</th>
    <th>전통적 방식</th>
    <th>모듈</th>
  </tr>
  <tr>
    <td>app_file</td>
    <td>sinatra를 로딩하는 파일</td>
    <td>Sinatra::Base를 서브클래싱한 파일</td>
  </tr>
  <tr>
    <td>run</td>
    <td>$0 == app_file</td>
    <td>false</td>
  </tr>
  <tr>
    <td>logging</td>
    <td> true</td>
    <td>false</td>
  </tr>
  <tr>
    <td>method_override</td>
    <td>true</td>
    <td>false</td>
  </tr>
  <tr>
    <td>inline_templates</td>
    <td>true</td>
    <td>false</td>
  </tr>
  <tr>
    <td>static</td>
    <td>true</td>
    <td>false</td>
  </tr>
</table>

### 모듈 애플리케이션(Modular Application) 제공하기

모듈 앱을 시작하는 두 가지 일반적인 옵션이 있습니다.
`run!`으로 능동적으로 시작하는 방법은 이렇습니다.

``` ruby
# my_app.rb
require 'sinatra/base'

class MyApp < Sinatra::Base
  # ... 여기에 앱 코드가 온다 ...

  # 루비 파일이 직접 실행될 경우에 서버를 시작
  run! if app_file == $0
end
```

이렇게 시작할 수도 있습니다.

``` shell
ruby my_app.rb
```

`config.ru`와 함께 사용할수도 있습니다. 이 경우는 어떠한 Rack 핸들러도 사용할 수 있도록
허용 합다.

``` ruby
# config.ru
require './my_app'
run MyApp
```

실행은 이렇게 합니다.

``` shell
rackup -p 4567
```

### config.ru로 전통적 방식의 애플리케이션 사용하기

앱 파일을 다음과 같이 작성합니다.

``` ruby
# app.rb
require 'sinatra'

get '/' do
  'Hello world!'
end
```

대응하는 `config.ru`는 다음과 같이 작성합니다.

``` ruby
require './app'
run Sinatra::Application
```

### 언제 config.ru를 사용할까?

`config.ru`는 다음 경우에 권장 됩니다.

* 다른 Rack 핸들러(Passenger, Unicorn, Heroku, ...)로 배포하고자 할 때.
* 하나 이상의 `Sinatra::Base` 서브클래스를 사용하고자 할 때.
* Sinatra를 최종점(endpoint)이 아니라, 오로지 미들웨어로만 사용하고자 할 때.

**모듈 방식으로 전환했다는 이유만으로 `config.ru`로 전환할 필요는 없으며,
또한 `config.ru`를 사용한다고 해서 모듈 방식을 사용해야 하는 것도 아닙니다.**

### Sinatra를 미들웨어로 사용하기

Sinatra에서 다른 Rack 미들웨어를 사용할 수 있을 뿐 아니라,
어떤 Sinatra 애플리케이션에서도 순차로 어떠한 Rack 종착점 앞에 미들웨어로
추가될 수 있습니다. 이 종착점은 다른 Sinatra 애플리케이션이 될 수도 있고,
또는 Rack 기반의 어떠한 애플리케이션(Rails/Ramaze/Camping/...)이 될 수도
있습니다.

``` ruby
require 'sinatra/base'

class LoginScreen < Sinatra::Base
  enable :sessions

  get('/login') { haml :login }

  post('/login') do
    if params['name'] == 'admin' && params['password'] == 'admin'
      session['user_name'] = params['name']
    else
      redirect '/login'
    end
  end
end

class MyApp < Sinatra::Base
  # 미들웨어는 사전 필터보다 앞서 실행됨
  use LoginScreen

  before do
unless session['user_name']
  halt "접근 거부됨, <a href='/login'>로그인</a> 하세요."
end
  end

  get('/') { "Hello #{session['user_name']}." }
end
```

### 동적인 애플리케이션 생성(Dynamic Application Creation)

어떤 상수에 할당하지 않고 런타임에서 새 애플리케이션들을 생성하려면,
`Sinatra.new`를 쓰면 됩니다.

``` ruby
require 'sinatra/base'
my_app = Sinatra.new { get('/') { "hi" } }
my_app.run!
```

선택적 인자로 상속할 애플리케이션을 받을 수 있습니다.

``` ruby
# config.ru
require 'sinatra/base'

controller = Sinatra.new do
  enable :logging
  helpers MyHelpers
end

map('/a') do
  run Sinatra.new(controller) { get('/') { 'a' } }
end

map('/b') do
  run Sinatra.new(controller) { get('/') { 'b' } }
end
```

이 방법은 Sintra 익스텐션을 테스팅하거나 또는 여러분의 라이브러리에서 Sinatra를
사용할 경우에 특히 유용합니다.

이 방법은 Sinatra를 미들웨어로 사용하는 것을 아주 쉽게 만들어 주기도 합니다.

``` ruby
require 'sinatra/base'

use Sinatra do
  get('/') { ... }
end

run RailsProject::Application
```

## 범위(Scopes)와 바인딩(Binding)

현재 어느 범위에 있느냐가 어떤 메서드와 변수를 사용할 수 있는지를 결정합니다.

### 애플리케이션/클래스 범위

모든 Sinatra 애플리케이션은 `Sinatra::Base`의 서브클래스에 대응됩니다.
만약 톱레벨 DSL (`require 'sinatra'`)을 사용한다면, 이 클래스는
`Sinatra::Application`이며, 그렇지 않을 경우라면 여러분이 명시적으로 생성한
그 서브클래스가 됩니다. 클래스 레벨에서는 `get` 이나 `before` 같은 메서드들을
가지나, `request` 객체나 `session` 에는 접근할 수 없습니다. 왜냐면 모든 요청에
대해 애플리케이션 클래스는 오직 하나이기 때문입니다.

`set`으로 생성한 옵션들은 클래스 레벨의 메서드들입니다.

``` ruby
class MyApp < Sinatra::Base
  # 저기요, 저는 애플리케이션 범위에 있다구요!
  set :foo, 42
  foo # => 42

  get '/foo' do
    # 저기요, 전 이제 더 이상 애플리케이션 범위 속에 있지 않아요!
  end
end
```

애플리케이션 범위에는 이런 것들이 있습니다.

* 애플리케이션 클래스 본문
* 확장으로 정의된 메서드
* `helpers`로 전달된 블록
* `set`의 값으로 사용된 Procs/blocks
* `Sinatra.new`로 전달된 블록

범위 객체 (클래스)는 다음과 같이 접근할 수 있습니다.

* configure 블록으로 전달된 객체를 통해(`configure { |c| ... }`)
* 요청 범위 내에서 `settings`

### 요청/인스턴스 범위

매 요청마다, 애플리케이션 클래스의 새 인스턴스가 생성되고 모든 핸들러 블록은
그 범위 내에서 실행됩니다. 범위 내에서 여러분은 `request` 와 `session` 객체에
접근하거나 `erb` 나 `haml` 같은 렌더링 메서드를 호출할 수 있습니다. 요청 범위
내에서 `settings` 헬퍼를 통해 애플리케이션 범위에 접근 가능합니다.

``` ruby
class MyApp < Sinatra::Base
  # 이봐요, 전 애플리케이션 범위에 있다구요!
  get '/define_route/:name' do
    # '/define_route/:name'의 요청 범위
    @value = 42

    settings.get("/#{params['name']}") do
      # "/#{params['name']}"의 요청 범위
      @value # => nil (동일한 요청이 아님)
    end

    "라우터가 정의됨!"
  end
end
```

요청 범위에는 이런 것들이 있습니다.

* get/head/post/put/delete/options 블록
* before/after 필터
* 헬퍼(helper) 메서드
* 템플릿/뷰

### 위임 범위(Delegation Scope)

위임 범위(delegation scope)는 메서드를 단순히 클래스 범위로 보냅니다(forward).
하지만 클래스 바인딩을 갖지 않기에 완전히 클래스 범위처럼 동작하지는 않습니다.
오직 명시적으로 위임(delegation) 표시된 메서드들만 사용 가능하고,
또한 클래스 범위와 변수/상태를 공유하지 않습니다 (유의: `self`가 다름).
`Sinatra::Delegator.delegate :method_name`을 호출하여 메서드 위임을 명시적으로
추가할 수 있습니다.

위임 범위에는 이런 것들이 있습니다.

* 톱레벨 바인딩, `require "sinatra"`를 한 경우
* `Sinatra::Delegator` 믹스인으로 확장된 객체

직접 코드를 살펴보길 바랍니다.
[Sinatra::Delegator 믹스인](https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/base.rb#L1609-1633)
은 [메인 객체를 확장한 것](https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/main.rb#L28-30) 입니다.

## 명령행(Command Line)

Sinatra 애플리케이션은 직접 실행할 수 있습니다.

``` shell
ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-o HOST] [-s HANDLER]
```

옵션들은 다음과 같습니다.

```
-h # 도움말
-p # 포트 설정 (기본값은 4567)
-o # 호스트 설정 (기본값은 0.0.0.0)
-e # 환경 설정 (기본값은 development)
-s # rack 서버/핸들러 지정 (기본값은 thin)
-x # mutex 잠금 켜기 (기본값은 off)
```

## 요구사항(Requirement)

다음의 루비 버전은 공식적으로 지원됩니다.
<dl>
  <dt> Ruby 1.8.7 </dt>
  <dd>
    1.8.7은 완전하게 지원되지만, 꼭 그래야할 특별한 이유가 없다면,
    1.9.2로 업그레이드하거나 또는 JRuby나 Rubinius로 전환할 것을 권장합니다.
    1.8.7에 대한 지원은 Sinatra 2.0 이전에는 중단되지 않을 것입니다.
    Ruby 1.8.6은 더이상 지원하지 않습니다.
  </dd>

  <dt> Ruby 1.9.2 </dt>
  <dd>
    1.9.2는 완전하게 지원됩니다. 1.9.2p0은, Sinatra를 실행했을 때 세그먼트 오류가
    발생할수 있으므로 쓰지 마세요. 공식 지원은 Sinatra 1.5 이전에는 중단되지 않을
    것입니다.
  </dd>

  <dt> Ruby 1.9.3 </dt>
  <dd>
    1.9.3은 완전하게 지원되고 권장합니다. 이전 버전에서 1.9.3으로 전환할 경우 모든
    세션이 무효화되므로 주의하세요. 1.9.3에 대한 지원은 Sinatra 2.0 이전에는
    중단되지 않을 것입니다.
  </dd>

  <dt>Ruby 2.x</dt>
  <dd>
    2.x은 완전하게 지원되고 권장합니다. 현재 공식 지원 중지 계획은 없습니다.
  </dd>

  <dt>Rubinius</dt>
  <dd>
    Rubinius는 공식적으로 지원됩니다. (Rubinius >= 2.x)
    <tt>gem install puma</tt>를 권장합니다.
  </dd>

  <dt>JRuby</dt>
  <dd>
    JRuby의 마지막 안정판은 공식적으로 지원됩니다. C 확장을 JRuby와 사용하는
    것은 권장되지 않습니다.
    <tt>gem install trinidad</tt>를 권장합니다.
</dd>
</dl>

새로 나오는 루비 버전도 주시하고 있습니다.

다음 루비 구현체들은 공식적으로 지원하지 않지만
여전히 Sinatra를 실행할 수 있는 것으로 알려져 있습니다.

* JRuby와 Rubinius 예전 버전
* Ruby Enterprise Edition
* MacRuby, Maglev, IronRuby
* Ruby 1.9.0 및 1.9.1 (이 버전들은 사용하지 말 것을 권합니다)

공식적으로 지원하지 않는다는 것의 의미는 무언가가 그 플랫폼에서만 잘못되고
지원되는 플랫폼에서는 그러지 않을 경우, 우리의 문제가 아니라 그 플랫폼의 문제로
간주한다는 뜻입니다.

또한 우리는 CI를 ruby-head (MRI의 이후 릴리즈) 브랜치에 맞춰 실행하지만,
계속해서 변하고 있기 때문에 아무 것도 보장할 수는 없습니다.
앞으로 나올 2.x가 완전히 지원되길 기대합시다.

Sinatra는 선택한 루비 구현체가 지원하는 어떠한 운영체제에서도 작동해야
합니다.

현재 Cardinal, SmallRuby, BlueRuby 또는 1.8.7 이전의 루비 버전에서는
Sinatra를 실행할 수 없을 것입니다.

## 최신(The Bleeding Edge)

Sinatra의 가장 최근 코드를 사용하고자 한다면, 애플리케이션을 마스터 브랜치에 맞춰
실행하면 되므로 부담가지지 마세요. 하지만 덜 안정적일 것 입니다.

주기적으로 사전배포(prerelease) 젬을 푸시하기 때문에, 최신 기능들을 얻기 위해
다음과 같이 할 수도 있습니다.

``` shell
gem install sinatra --pre
```

### Bundler를 사용하여

여러분 애플리케이션을 최신 Sinatra로 실행하고자 한다면,
[Bundler](http://gembundler.com/)를 사용할 것을 권장합니다.

우선, 아직 설치하지 않았다면 bundler를 설치합니다.

``` shell
gem install bundler
```

그런 다음, 프로젝트 디렉터리에서, `Gemfile`을 만듭니다.

``` ruby
source 'https://rubygems.org'
gem 'sinatra', :github => "sinatra/sinatra"

# 다른 의존관계들
gem 'haml'                    # 예를 들어, haml을 사용한다면
gem 'activerecord', '~> 3.0'  # 아마도 ActiveRecord 3.x도 필요할 것
```

`Gemfile`안에 애플리케이션의 모든 의존성을 적어야 합니다.
하지만, Sinatra가 직접적인 의존관계에 있는 것들(Rack과 Tilt)은
Bundler가 자동으로 찾아서 추가할 것입니다.

이제 앱을 실행할 수 있습니다.

``` shell
bundle exec ruby myapp.rb
```

### 직접 하기(Roll Your Own)

로컬 클론(clone)을 생성한 다음 `$LOAD_PATH`에 `sinatra/lib` 디렉터리를 주고
여러분 앱을 실행합니다.

``` shell
cd myapp
git clone git://github.com/sinatra/sinatra.git
ruby -I sinatra/lib myapp.rb
```

이후에 Sinatra 소스를 업데이트하려면 이렇게 하세요.

``` shell
cd myapp/sinatra
git pull
```

### 전역으로 설치(Install Globally)

젬을 직접 빌드할 수 있습니다.

``` shell
git clone git://github.com/sinatra/sinatra.git
cd sinatra
rake sinatra.gemspec
rake install
```

만약 젬을 루트로 설치한다면, 마지막 단계는 다음과 같이 해야 합니다.

``` shell
sudo rake install
```

## 버저닝(Versioning)

Sinatra는 [시맨틱 버저닝Semantic Versioning](http://semver.org/)
[(번역)](http://surpreem.com/archives/380)의 SemVer,
SemVerTag를 준수합니다.

## 더 읽을 거리(Further Reading)

* [프로젝트 웹사이트](http://www.sinatrarb.com/) - 추가 문서들, 뉴스,
  그리고 다른 리소스들에 대한 링크.
* [기여하기](http://www.sinatrarb.com/contributing) - 버그를 찾았나요?
  도움이 필요한가요? 패치를 하셨나요?
* [이슈 트래커](http://github.com/sinatra/sinatra/issues)
* [트위터](http://twitter.com/sinatra)
* [메일링 리스트](http://groups.google.com/group/sinatrarb/topics)
* IRC: [#sinatra](irc://chat.freenode.net/#sinatra) http://freenode.net
* [Sinatra Book](https://github.com/sinatra/sinatra-book/) Cookbook 튜토리얼
* [Sinatra Recipes](http://recipes.sinatrarb.com/) 커뮤니티가 만드는 레시피
* http://rubydoc.info에 있는 [최종 릴리스](http://rubydoc.info/gems/sinatra)
  또는 [current HEAD](http://rubydoc.info/github/sinatra/sinatra)에 대한 API 문서
* [CI server](http://travis-ci.org/sinatra/sinatra)
# Sinatra

*Внимание: Этот документ является переводом английской версии и может быть
устаревшим*

Sinatra — это предметно-ориентированный каркас
([DSL](http://ru.wikipedia.org/wiki/Предметно-ориентированный_язык_программирования))
для быстрого создания функциональных веб-приложений на Ruby с минимумом усилий:

```ruby
# myapp.rb
require 'sinatra'

get '/' do
  'Hello world!'
end
```

Установите gem:

``` shell
gem install sinatra
```

и запустите приложение с помощью:

``` shell
ruby myapp.rb
```

Оцените результат: http://localhost:4567

Рекомендуется также установить Thin, сделать это можно командой: `gem install
thin`. Thin — это более производительный и функциональный сервер для
разработки приложений на Sinatra.

## Маршруты

В Sinatra маршрут — это пара: &lt;HTTP метод&gt; и &lt;шаблон URL&gt;. Каждый маршрут
связан с блоком кода:

```ruby
get '/' do
  # .. что-то показать ..
end

post '/' do
  # .. что-то создать ..
end

put '/' do
  # .. что-то заменить ..
end

patch '/' do
  # .. что-то изменить ..
end

delete '/' do
  # .. что-то удалить ..
end

options '/' do
  # .. что-то ответить ..
end

link '/' do
  .. что-то подключить ..
end

unlink '/' do
  .. что-то отключить ..
end
```

Маршруты сверяются с запросом в порядке очередности их записи в файле
приложения. Первый же совпавший с запросом маршрут и будет вызван.

Шаблоны маршрутов могут включать в себя именованные параметры, доступные в xэше
`params`:

```ruby
get '/hello/:name' do
  # соответствует "GET /hello/foo" и "GET /hello/bar",
  # где params['name'] 'foo' или 'bar'
  "Hello #{params['name']}!"
end
```

Также можно использовать именованные параметры в качестве переменных блока:

```ruby
get '/hello/:name' do |n|
  "Hello #{n}!"
end
```

Шаблоны маршрутов также могут включать в себя splat (или '*' маску,
обозначающую любой символ) параметры, доступные в массиве `params['splat']`:

```ruby
get '/say/*/to/*' do
  # соответствует /say/hello/to/world
  params['splat'] # => ["hello", "world"]
end

get '/download/*.*' do
  # соответствует /download/path/to/file.xml
  params['splat'] # => ["path/to/file", "xml"]
end
```

Или с параметрами блока:

```ruby
get '/download/*.*' do |path, ext|
  [path, ext] # => ["path/to/file", "xml"]
end
```

Регулярные выражения в качестве шаблонов маршрутов:

```ruby
get /\A\/hello\/([\w]+)\z/ do
  "Hello, #{params['captures'].first}!"
end
```

Или с параметром блока:

```ruby
# Находит "GET /meta/hello/world", "GET /hello/world/1234" и так далее
get %r{/hello/([\w]+)} do |c|
  "Hello, #{c}!"
end
```

Шаблоны маршрутов могут иметь необязательные параметры:

```ruby
get '/posts.?:format?' do
  # соответствует "GET /posts", "GET /posts.json", "GET /posts.xml" и т.д.
end
```

Кстати, если вы не отключите защиту от обратного пути в директориях (path
traversal, см. ниже), путь запроса может быть изменен до начала поиска
подходящего маршрута.

### Условия

Маршруты могут включать различные условия совпадений, например, клиентское
приложение (user agent):

```ruby
get '/foo', :agent => /Songbird (\d\.\d)[\d\/]*?/ do
  "You're using Songbird version #{params['agent'][0]}"
end

get '/foo' do
  # соответствует не-songbird браузерам
end
```

Другими доступными условиями являются `host_name` и `provides`:

```ruby
get '/', :host_name => /^admin\./ do
  "Admin Area, Access denied!"
end

get '/', :provides => 'html' do
  haml :index
end

get '/', :provides => ['rss', 'atom', 'xml'] do
  builder :feed
end
```

Вы можете задать собственные условия:

```ruby
set(:probability) { |value| condition { rand <= value } }

get '/win_a_car', :probability => 0.1 do
  "You won!"
end

get '/win_a_car' do
  "Sorry, you lost."
end
```

Для условия, которое принимает несколько параметров, используйте звездочку:

```ruby
set(:auth) do |*roles|   # <- обратите внимание на звездочку
  condition do
    unless logged_in? && roles.any? {|role| current_user.in_role? role }
      redirect "/login/", 303
    end
  end
end

get "/my/account/", :auth => [:user, :admin] do
  "Your Account Details"
end

get "/only/admin/", :auth => :admin do
  "Only admins are allowed here!"
end
```

### Возвращаемые значения

Возвращаемое значение блока маршрута ограничивается телом ответа, которое
будет передано HTTP клиенту, или следующей "прослойкой" (middleware) в Rack
стеке. Чаще всего это строка, как в примерах выше. Но также приемлемы и
другие значения.

Вы можете вернуть любой объект, который будет либо корректным Rack ответом,
объектом Rack body, либо кодом состояния HTTP:

* массив с тремя переменными: `[код (Fixnum), заголовки (Hash), тело ответа
  (должно отвечать на #each)]`;
* массив с двумя переменными: `[код (Fixnum), тело ответа (должно отвечать
  на #each)]`;
* объект, отвечающий на `#each`, который передает только строковые типы
  данных в этот блок;
* Fixnum, представляющий код состояния HTTP.


Таким образом, легко можно реализовать, например, поточный пример:

```ruby
class Stream
  def each
    100.times { |i| yield "#{i}\n" }
  end
end

get('/') { Stream.new }
```

Вы также можете использовать метод `stream` (описываемый ниже), чтобы
уменьшить количество дублируемого кода и держать логику стриминга прямо в
маршруте.

### Собственные детекторы совпадений для маршрутов

Как показано выше, Sinatra поставляется со встроенной поддержкой строк и
регулярных выражений в качестве шаблонов URL. Но и это еще не все. Вы можете
легко определить свои собственные детекторы совпадений (matchers) для
маршрутов:

```ruby
class AllButPattern
  Match = Struct.new(:captures)

  def initialize(except)
    @except   = except
    @captures = Match.new([])
  end

  def match(str)
    @captures unless @except === str
  end
end

def all_but(pattern)
  AllButPattern.new(pattern)
end

get all_but("/index") do
  # ...
end
```

Заметьте, что предыдущий пример, возможно, чересчур усложнен, потому что он
может быть реализован так:

```ruby
get // do
  pass if request.path_info == "/index"
  # ...
end
```

Или с использованием негативного просмотра вперед:

```ruby
get %r{^(?!/index$)} do
  # ...
end
```

## Статические файлы

Статические файлы отдаются из `./public` директории. Вы можете указать другое
место, используя опцию `:public_folder`:

```ruby
set :public_folder, File.dirname(__FILE__) + '/static'
```

Учтите, что имя директории со статическими файлами не включено в URL.
Например, файл `./public/css/style.css` будет доступен как
`http://example.com/css/style.css`.

Используйте опцию `:static_cache_control` (см. ниже), чтобы добавить заголовок
`Cache-Control`.

## Представления / Шаблоны

Каждый шаблонизатор представлен своим собственным методом. Эти методы попросту
возвращают строку:

```ruby
get '/' do
  erb :index
end
```

Отобразит `views/index.erb`.

Вместо имени шаблона вы так же можете передавать непосредственно само
содержимое шаблона:

```ruby
get '/' do
  code = "<%= Time.now %>"
  erb code
end
```

Эти методы принимают второй аргумент, хеш с опциями:

```ruby
get '/' do
  erb :index, :layout => :post
end
```

Отобразит `views/index.erb`, вложенным в `views/post.erb` (по умолчанию:
`views/layout.erb`, если существует).

Любые опции, не понимаемые Sinatra, будут переданы в шаблонизатор:

```ruby
get '/' do
  haml :index, :format => :html5
end
```

Вы также можете задавать опции для шаблонизаторов в общем:

```ruby
set :haml, :format => :html5

get '/' do
  haml :index
end
```

Опции, переданные в метод, переопределяют опции, заданные с помощью `set`.

Доступные опции:

<dl>
  <dt>locals</dt>
  <dd>
    Список локальных переменных, передаваемых в документ.
    Например: <tt>erb "<%= foo %>", :locals => {:foo => "bar"}</tt>
  </dd>

  <dt>default_encoding</dt>
  <dd>
    Кодировка, которую следует использовать, если не удалось определить
    оригинальную. По умолчанию: <tt>settings.default_encoding</tt>.
  </dd>

  <dt>views</dt>
  <dd>
    Директория с шаблонами. По умолчанию: <tt>settings.views</tt>.
  </dd>

  <dt>layout</dt>
  <dd>
    Использовать или нет лэйаут (<tt>true</tt> или <tt>false</tt>). Если же значение Symbol,
    то указывает, какой шаблон использовать в качестве лэйаута. Например:
    <tt>erb :index, :layout => !request.xhr?</tt>
  </dd>

  <dt>content_type</dt>
  <dd>
    Content-Type отображенного шаблона. По умолчанию: задается шаблонизатором.
  </dd>

  <dt>scope</dt>
  <dd>
    Область видимости, в которой рендерятся шаблоны. По умолчанию: экземпляр
    приложения. Если вы измените эту опцию, то переменные экземпляра и
    методы-помощники станут недоступными в ваших шаблонах.
  </dd>

  <dt>layout_engine</dt>
  <dd>
    Шаблонизатор, который следует использовать для отображения лэйаута.
    Полезная опция для шаблонизаторов, в которых нет никакой поддержки
    лэйаутов. По умолчанию: тот же шаблонизатор, что используется и для самого
    шаблона. Пример: <tt>set :rdoc, :layout_engine => :erb</tt>
  </dd>
</dl>

По умолчанию считается, что шаблоны находятся в директории `./views`. Чтобы
использовать другую директорию с шаблонами:

```ruby
set :views, settings.root + '/templates'
```

Важное замечание: вы всегда должны ссылаться на шаблоны с помощью символов
(Symbol), даже когда они в поддиректории (в этом случае используйте
`:'subdir/template'`). Вы должны использовать символы, потому что иначе
шаблонизаторы попросту отображают любые строки, переданные им.

### Буквальные шаблоны

```ruby
get '/' do
  haml '%div.title Hello World'
end
```

Отобразит шаблон, переданный строкой.

### Доступные шаблонизаторы

Некоторые языки шаблонов имеют несколько реализаций. Чтобы указать, какую
реализацию использовать, вам следует просто подключить нужную библиотеку:

```ruby
require 'rdiscount' # или require 'bluecloth'
get('/') { markdown :index }
```

#### Haml шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://haml.info/" title="haml">haml</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.haml</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>haml :index, :format => :html5</tt></td>
  </tr>
</table>

#### Erb шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td>
      <a href="http://www.kuwata-lab.com/erubis/" title="erubis">erubis</a>
      или erb (включен в Ruby)
    </td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.erb</tt>, <tt>.rhtml</tt> or <tt>.erubis</tt> (только Erubis)</td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>erb :index</tt></td>
  </tr>
</table>

#### Builder шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td>
      <a href="https://github.com/jimweirich/builder" title="builder">builder</a>
    </td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.builder</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>builder { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

Блок также используется и для встроенных шаблонов (см. пример).

#### Nokogiri шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://nokogiri.org/" title="nokogiri">nokogiri</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.nokogiri</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>nokogiri { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

Блок также используется и для встроенных шаблонов (см. пример).

#### Sass шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.sass</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>sass :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>

#### SCSS шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.scss</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>scss :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>

#### Less шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://www.lesscss.org/" title="less">less</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.less</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>less :stylesheet</tt></td>
  </tr>
</table>

#### Liquid шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://www.liquidmarkup.org/" title="liquid">liquid</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.liquid</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>liquid :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

Так как в Liquid шаблонах невозможно вызывать методы из Ruby (кроме `yield`), то
вы почти всегда будете передавать в шаблон локальные переменные.

#### Markdown шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td>
      Любая из библиотек:
        <a href="https://github.com/rtomayko/rdiscount" title="RDiscount">RDiscount</a>,
        <a href="https://github.com/vmg/redcarpet" title="RedCarpet">RedCarpet</a>,
        <a href="http://deveiate.org/projects/BlueCloth" title="BlueCloth">BlueCloth</a>,
        <a href="http://kramdown.gettalong.org/" title="kramdown">kramdown</a>,
        <a href="https://github.com/bhollis/maruku" title="maruku">maruku</a>
    </td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.markdown</tt>, <tt>.mkd</tt> and <tt>.md</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>markdown :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

В Markdown невозможно вызывать методы или передавать локальные переменные.
Следовательно, вам, скорее всего, придется использовать этот шаблон совместно
с другим шаблонизатором:

```ruby
erb :overview, :locals => { :text => markdown(:introduction) }
```

Заметьте, что вы можете вызывать метод `markdown` из других шаблонов:

```ruby
%h1 Hello From Haml!
%p= markdown(:greetings)
```

Вы не можете вызывать Ruby из Markdown, соответственно, вы не можете
использовать лэйауты на Markdown. Тем не менее, есть возможность использовать
один шаблонизатор для отображения шаблона, а другой для лэйаута с помощью
опции `:layout_engine`.

#### Textile шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://redcloth.org/" title="RedCloth">RedCloth</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.textile</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>textile :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

В Textile невозможно вызывать методы или передавать локальные переменные.
Следовательно, вам, скорее всего, придется использовать этот шаблон совместно
с другим шаблонизатором:

```ruby
erb :overview, :locals => { :text => textile(:introduction) }
```

Заметьте, что вы можете вызывать метод `textile` из других шаблонов:

```ruby
%h1 Hello From Haml!
%p= textile(:greetings)
```

Вы не можете вызывать Ruby из Textile, соответственно, вы не можете
использовать лэйауты на Textile. Тем не менее, есть возможность использовать
один шаблонизатор для отображения шаблона, а другой для лэйаута с помощью
опции `:layout_engine`.

#### RDoc шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://rdoc.sourceforge.net/" title="RDoc">RDoc</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.rdoc</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>rdoc :README, :layout_engine => :erb</tt></td>
  </tr>
</table>

В RDoc невозможно вызывать методы или передавать локальные переменные.
Следовательно, вам, скорее всего, придется использовать этот шаблон совместно
с другим шаблонизатором:

```ruby
erb :overview, :locals => { :text => rdoc(:introduction) }
```

Заметьте, что вы можете вызывать метод `rdoc` из других шаблонов:

```ruby
%h1 Hello From Haml!
%p= rdoc(:greetings)
```

Вы не можете вызывать Ruby из RDoc, соответственно, вы не можете использовать
лэйауты на RDoc. Тем не менее, есть возможность использовать один шаблонизатор
для отображения шаблона, а другой для лэйаута с помощью опции
`:layout_engine`.

#### AsciiDoc шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://asciidoctor.org/" title="Asciidoctor">Asciidoctor</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.asciidoc</tt>, <tt>.adoc</tt> и <tt>.ad</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>asciidoc :README, :layout_engine => :erb</tt></td>
  </tr>
</table>

Так как в AsciiDoc шаблонах невозможно вызывать методы из Ruby напрямую, то вы
почти всегда будете передавать в шаблон локальные переменные.

#### Radius шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://github.com/jlong/radius" title="Radius">Radius</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.radius</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>radius :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

Так как в Radius шаблонах невозможно вызывать методы из Ruby напрямую, то вы
почти всегда будете передавать в шаблон локальные переменные.

#### Markaby шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://markaby.github.com/" title="Markaby">Markaby</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.mab</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>markaby { h1 "Welcome!" }</tt></td>
  </tr>
</table>

Блок также используется и для встроенных шаблонов (см. пример).

#### RABL шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://github.com/nesquena/rabl" title="Rabl">Rabl</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.rabl</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>rabl :index</tt></td>
  </tr>
</table>

#### Slim шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://slim-lang.com/" title="Slim Lang">Slim Lang</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.slim</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>slim :index</tt></td>
  </tr>
</table>

#### Creole шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://github.com/minad/creole" title="Creole">Creole</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.creole</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>creole :wiki, :layout_engine => :erb</tt></td>
  </tr>
</table>

В Creole невозможно вызывать методы или передавать локальные переменные.
Следовательно, вам, скорее всего, придется использовать этот шаблон совместно
с другим шаблонизатором:

```ruby
erb :overview, :locals => { :text => creole(:introduction) }
```

Заметьте, что вы можете вызывать метод `creole` из других шаблонов:

```ruby
%h1 Hello From Haml!
%p= creole(:greetings)
```

Вы не можете вызывать Ruby из Creole, соответственно, вы не можете
использовать лэйауты на Creole. Тем не менее, есть возможность использовать
один шаблонизатор для отображения шаблона, а другой для лэйаута с помощью
опции `:layout_engine`.

#### MediaWiki шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://github.com/nricciar/wikicloth" title="WikiCloth">WikiCloth</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.mediawiki</tt> и <tt>.mw</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>mediawiki :wiki, :layout_engine => :erb</tt></td>
  </tr>
</table>

В разметке MediaWiki невозможно вызывать методы или передавать локальные переменные.
Следовательно, вам, скорее всего, придется использовать этот шаблон совместно
с другим шаблонизатором:

```ruby
erb :overview, :locals => { :text => mediawiki(:introduction) }
```

Заметьте, что вы можете вызывать метод `mediawiki` из других шаблонов:

```ruby
%h1 Hello From Haml!
%p= mediawiki(:greetings)
```

Вы не можете вызывать Ruby из MediaWiki, соответственно, вы не можете
использовать лэйауты на MediaWiki. Тем не менее, есть возможность использовать
один шаблонизатор для отображения шаблона, а другой для лэйаута с помощью
опции `:layout_engine`.

#### CoffeeScript шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td>
      <a href="https://github.com/josh/ruby-coffee-script" title="Ruby CoffeeScript">
        CoffeeScript
      </a> и
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        способ запускать JavaScript
      </a>
    </td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.coffee</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>coffee :index</tt></td>
  </tr>
</table>

#### Stylus шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td>
      <a href="https://github.com/lucasmazza/ruby-stylus" title="Ruby Stylus">
        Stylus
      </a> и
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        способ запускать JavaScript
      </a>
    </td>
  </tr>
  <tr>
    <td>Расширение файла</td>
    <td><tt>.styl</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>stylus :index</tt></td>
  </tr>
</table>

Перед тем, как использовать шаблоны стилус, загрузите `stylus` и
`stylus/tilt`:

``` ruby
require 'sinatra'
require 'stylus'
require 'stylus/tilt'

get '/' do
  stylus :example
end
```

#### Yajl шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://github.com/brianmario/yajl-ruby" title="yajl-ruby">yajl-ruby</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.yajl</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td>
      <tt>
        yajl :index,
             :locals => { :key => 'qux' },
             :callback => 'present',
             :variable => 'resource'
      </tt>
    </td>
  </tr>
</table>

Содержимое шаблона интерпретируется как код на Ruby, а результирующая
переменная json затем конвертируется с помощью `#to_json`.

```ruby
json = { :foo => 'bar' }
json[:baz] = key
```

Опции `:callback` и `:variable` используются для "декорирования" итогового
объекта.

```ruby
var resource = {"foo":"bar","baz":"qux"}; present(resource);
```

#### WLang шаблоны

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://github.com/blambeau/wlang/" title="wlang">wlang</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.wlang</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>wlang :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

Так как в WLang шаблонах невозможно вызывать методы из Ruby напрямую (за
исключением `yield`), то вы почти всегда будете передавать в шаблон локальные
переменные.

### Доступ к переменным в шаблонах

Шаблоны интерпретируются в том же контексте, что и обработчики маршрутов.
Переменные экземпляра, установленные в процессе обработки маршрутов, будут
доступны напрямую в шаблонах:

```ruby
get '/:id' do
  @foo = Foo.find(params['id'])
  haml '%h1= @foo.name'
end
```

Либо установите их через хеш локальных переменных:

```ruby
get '/:id' do
  foo = Foo.find(params['id'])
  haml '%h1= bar.name', :locals => { :bar => foo }
end
```

Это обычный подход, когда шаблоны рендерятся как части других шаблонов.

### Шаблоны с `yield` и вложенные раскладки (layout)

Раскладка (layout) обычно представляет собой шаблон, который исполняет
`yield`.
Такой шаблон может быть либо использован с помощью опции `:template`,
как описано выше, либо он может быть дополнен блоком:

```ruby
    erb :post, :layout => false do
      erb :index
    end
```

Эти инструкции в основном эквивалентны `erb :index, :layout => :post`.

Передача блоков интерпретирующим шаблоны методам наиболее полезна для
создания вложенных раскладок:

```ruby
    erb :main_layout, :layout => false do
      erb :admin_layout do
        erb :user
      end
    end
```

Это же самое может быть сделано короче:

```ruby
    erb :admin_layout, :layout => :main_layout do
      erb :user
    end
```

В настоящее время, следующие интерпретирующие шаблоны методы
принимают блок:
`erb`, `haml`, `liquid`, `slim `, `wlang`.
Общий метод заполнения шаблонов `render` также принимает блок.

### Включённые шаблоны

Шаблоны также могут быть определены в конце исходного файла:

```ruby
require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.title Hello world.
```

Заметьте: включённые шаблоны, определенные в исходном файле, который подключил
Sinatra, будут загружены автоматически. Вызовите `enable :inline_templates`
напрямую, если используете включённые шаблоны в других файлах.

### Именованные шаблоны

Шаблоны также могут быть определены при помощи `template` метода:

```ruby
template :layout do
  "%html\n  =yield\n"
end

template :index do
  '%div.title Hello World!'
end

get '/' do
  haml :index
end
```

Если шаблон с именем "layout" существует, то он будет использоваться каждый
раз при рендеринге. Вы можете отключать лэйаут в каждом конкретном случае с
помощью `:layout => false` или отключить его для всего приложения: `set :haml,
:layout => false`:

```ruby
get '/' do
  haml :index, :layout => !request.xhr?
end
```

### Привязка файловых расширений

Чтобы связать расширение файла с движком рендеринга, используйте
`Tilt.register`. Например, если вы хотите использовать расширение `tt` для
шаблонов Textile:

```ruby
Tilt.register :tt, Tilt[:textile]
```

### Добавление собственного движка рендеринга

Сначала зарегистрируйте свой движок в Tilt, а затем создайте метод, отвечающий
за рендеринг:

```ruby
Tilt.register :myat, MyAwesomeTemplateEngine

helpers do
  def myat(*args) render(:myat, *args) end
end

get '/' do
  myat :index
end
```

Отобразит `./views/index.myat`. Чтобы узнать больше о Tilt, смотрите
https://github.com/rtomayko/tilt

## Фильтры

`before`-фильтры выполняются перед каждым запросом в том же контексте, что и
маршруты, и могут изменять как запрос, так и ответ на него. Переменные
экземпляра, установленные в фильтрах, доступны в маршрутах и шаблонах:

```ruby
before do
  @note = 'Hi!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @note #=> 'Hi!'
  params['splat'] #=> 'bar/baz'
end
```

`after`-фильтры выполняются после каждого запроса в том же контексте
и могут изменять как запрос, так и ответ на него. Переменные
экземпляра, установленные в `before`-фильтрах и маршрутах, будут доступны в
`after`-фильтрах:

```ruby
after do
  puts response.status
end
```

Заметьте: если вы используете метод `body`, а не просто возвращаете строку из
маршрута, то тело ответа не будет доступно в `after`-фильтрах, так как оно
будет сгенерировано позднее.

Фильтры могут использовать шаблоны URL и будут интерпретированы, только если
путь запроса совпадет с этим шаблоном:

```ruby
before '/protected/*' do
  authenticate!
end

after '/create/:slug' do |slug|
  session['last_slug'] = slug
end
```

Как и маршруты, фильтры могут использовать условия:

```ruby
before :agent => /Songbird/ do
  # ...
end

after '/blog/*', :host_name => 'example.com' do
  # ...
end
```

## Методы-помощники

Используйте метод `helpers`, чтобы определить методы-помощники, которые в
дальнейшем можно будет использовать в обработчиках маршрутов и шаблонах:

```ruby
helpers do
  def bar(name)
    "#{name}bar"
  end
end

get '/:name' do
  bar(params['name'])
end
```

Также методы-помощники могут быть заданы в отдельных модулях:

```ruby
module FooUtils
  def foo(name) "#{name}foo" end
end

module BarUtils
  def bar(name) "#{name}bar" end
end

helpers FooUtils, BarUtils
```

Эффект равносилен включению модулей в класс приложения.

### Использование сессий

Сессия используется, чтобы сохранять состояние между запросами. Если эта опция
включена, то у вас будет один хеш сессии на одну пользовательскую сессию:

```ruby
enable :sessions

get '/' do
  "value = " << session['value'].inspect
end

get '/:value' do
  session['value'] = params['value']
end
```

Заметьте, что при использовании `enable :sessions` все данные сохраняются в
куках (cookies). Это может быть не совсем то, что вы хотите (например,
сохранение больших объемов данных увеличит ваш трафик). В таком случае вы
можете использовать альтернативную Rack "прослойку" (middleware), реализующую
механизм сессий. Для этого *не надо* вызывать `enable :sessions`, вместо этого
следует подключить ее так же, как и любую другую "прослойку":

```ruby
use Rack::Session::Pool, :expire_after => 2592000

get '/' do
  "value = " << session['value'].inspect
end

get '/:value' do
  session['value'] = params['value']
end
```

Для повышения безопасности данные сессии в куках подписываются секретным
ключом. Секретный ключ генерируется Sinatra. Тем не менее, так как этот ключ
будет меняться с каждым запуском приложения, вы, возможно, захотите установить
ключ вручную, чтобы у всех экземпляров вашего приложения был один и тот же
ключ:

```ruby
set :session_secret, 'super secret'
```

Если вы хотите больше настроек для сессий, вы можете задать их, передав хеш
опций в параметр `sessions`:

```ruby
set :sessions, :domain => 'foo.com'
```

Чтобы сделать сессию доступной другим приложениям, размещенным на поддоменах
foo.com, добавьте *.* перед доменом:

``` ruby
set :sessions, :domain => '.foo.com'
```

### Прерывание

Чтобы незамедлительно прервать обработку запроса внутри фильтра или маршрута,
используйте:

```ruby
halt
```

Можно также указать статус при прерывании:

```ruby
halt 410
```

Тело:

```ruby
halt 'this will be the body'
```

И то, и другое:

```ruby
halt 401, 'go away!'
```

Можно указать заголовки:

```ruby
halt 402, {'Content-Type' => 'text/plain'}, 'revenge'
```

И, конечно, можно использовать шаблоны с `halt`:

```ruby
halt erb(:error)
```

### Передача

Маршрут может передать обработку запроса следующему совпадающему маршруту,
используя `pass`:

```ruby
get '/guess/:who' do
  pass unless params['who'] == 'Frank'
  'You got me!'
end

get '/guess/*' do
  'You missed!'
end
```

Блок маршрута сразу же прерывается, и контроль переходит к следующему
совпадающему маршруту. Если соответствующий маршрут не найден, то ответом на
запрос будет 404.

### Вызов другого маршрута

Иногда `pass` не подходит, например, если вы хотите получить результат вызова
другого обработчика маршрута. В таком случае просто используйте `call`:

```ruby
get '/foo' do
  status, headers, body = call env.merge("PATH_INFO" => '/bar')
  [status, headers, body.map(&:upcase)]
end

get '/bar' do
  "bar"
end
```

Заметьте, что в предыдущем примере можно облегчить тестирование и повысить
производительность, перенеся `"bar"` в метод-помощник, используемый и в
`/foo`, и в `/bar`.

Если вы хотите, чтобы запрос был отправлен в тот же экземпляр приложения, а не
в его копию, используйте `call!` вместо `call`.

Если хотите узнать больше о `call`, смотрите спецификацию Rack.

### Задание тела, кода и заголовков ответа

Хорошим тоном является установка кода состояния HTTP и тела ответа в
возвращаемом значении обработчика маршрута. Тем не менее, в некоторых
ситуациях вам, возможно, понадобится задать тело ответа в произвольной точке
потока исполнения. Вы можете сделать это с помощью метода-помощника `body`.
Если вы задействуете метод `body`, то вы можете использовать его и в
дальнейшем, чтобы получить доступ к телу ответа.

```ruby
get '/foo' do
  body "bar"
end

after do
  puts body
end
```

Также можно передать блок в метод `body`, который затем будет вызван
обработчиком Rack (такой подход может быть использован для реализации
поточного ответа, см. "Возвращаемые значения").

Аналогично вы можете установить код ответа и его заголовки:

```ruby
get '/foo' do
  status 418
  headers \
    "Allow"   => "BREW, POST, GET, PROPFIND, WHEN",
    "Refresh" => "Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt"
  body "I'm a tea pot!"
end
```

Как и `body`, методы `headers` и `status`, вызванные без аргументов,
возвращают свои текущие значения.

### Стриминг ответов

Иногда требуется начать отправлять данные клиенту прямо в процессе
генерирования частей этих данных. В особых случаях требуется постоянно
отправлять данные до тех пор, пока клиент не закроет соединение. Вы можете
использовать метод `stream` вместо написания собственных "оберток".

```ruby
get '/' do
  stream do |out|
    out << "It's gonna be legen -\n"
    sleep 0.5
    out << " (wait for it) \n"
    sleep 1
    out << "- dary!\n"
  end
end
```

Что позволяет вам реализовать стриминговые API,
[Server Sent Events](http://dev.w3.org/html5/eventsource/),
и может служить основой для [WebSockets](http://en.wikipedia.org/wiki/WebSocket).
Также такой подход можно использовать для увеличения производительности в случае,
когда какая-то часть контента зависит от медленного ресурса.

Заметьте, что возможности стриминга, особенно количество одновременно
обслуживаемых запросов, очень сильно зависят от используемого веб-сервера.
Некоторые серверы, например, WEBRick, могут и вовсе не поддерживать стриминг.
Если сервер не поддерживает стриминг, то все данные будут отправлены за один
раз сразу после того, как блок, переданный в `stream`, завершится. Стриминг
вообще не работает при использовании Shotgun.

Если метод используется с параметром `keep_open`, то он не будет вызывать
`close` у объекта потока, что позволит вам закрыть его позже в любом другом
месте. Это работает только с событийными серверами, например, с Thin и
Rainbows. Другие же серверы все равно будут закрывать поток:

```ruby
# long polling

set :server, :thin
connections = []

get '/subscribe' do
  # регистрация клиента
  stream(:keep_open) do |out|
    connections << out }
    # удаление "мертвых клиентов"
    connections.reject!(&:closed?)
  end
end

post '/message' do
  connections.each do |out|
    # уведомить клиента о новом сообщении
    out << params['message'] << "\n"

    # указать клиенту на необходимость снова соединиться
    out.close
  end

  # допуск
  "message received"
end
```

### Логирование

В области видимости запроса метод `logger` предоставляет доступ к экземпляру
`Logger`:

```ruby
get '/' do
  logger.info "loading data"
  # ...
end
```

Этот логер автоматически учитывает ваши настройки логирования в Rack. Если
логирование выключено, то этот метод вернет пустой (dummy) объект, поэтому вы
можете смело использовать его в маршрутах и фильтрах.

Заметьте, что логирование включено по умолчанию только для
`Sinatra::Application`, а если ваше приложение — подкласс `Sinatra::Base`, то
вы, наверное, захотите включить его вручную:

```ruby
class MyApp < Sinatra::Base
  configure :production, :development do
    enable :logging
  end
end
```

Чтобы избежать использования любой логирующей "прослойки", задайте опции
`logging` значение `nil`. Тем не менее, не забывайте, что в такой ситуации
`logger` вернет `nil`. Чаще всего так делают, когда задают свой собственный
логер. Sinatra будет использовать то, что находится в `env['rack.logger']`.

### Mime-типы

Когда вы используете `send_file` или статические файлы, у вас могут быть
mime-типы, которые Sinatra не понимает по умолчанию. Используйте `mime_type`
для их регистрации по расширению файла:

```ruby
configure do
  mime_type :foo, 'text/foo'
end
```

Вы также можете использовать это в `content_type` методе-помощнике:

```ruby
get '/' do
  content_type :foo
  "foo foo foo"
end
```

### Генерирование URL

Чтобы сформировать URL, вам следует использовать метод `url`, например, в Haml:

```ruby
%a{:href => url('/foo')} foo
```

Этот метод учитывает обратные прокси и маршрутизаторы Rack, если они
присутствуют.

Наряду с `url` вы можете использовать `to` (смотрите пример ниже).

### Перенаправление (редирект)

Вы можете перенаправить браузер пользователя с помощью метода `redirect`:

```ruby
get '/foo' do
  redirect to('/bar')
end
```

Любые дополнительные параметры используются по аналогии с аргументами метода
`halt`:

```ruby
redirect to('/bar'), 303
redirect 'http://google.com', 'wrong place, buddy'
```

Вы также можете перенаправить пользователя обратно, на страницу, с которой он
пришел, с помощью `redirect back`:

```ruby
get '/foo' do
  "<a href='/bar'>do something</a>"
end

get '/bar' do
  do_something
  redirect back
end
```

Чтобы передать какие-либо параметры вместе с перенаправлением, либо добавьте
их в строку запроса:

```ruby
redirect to('/bar?sum=42')
```

либо используйте сессию:

```ruby
enable :sessions

get '/foo' do
  session['secret'] = 'foo'
  redirect to('/bar')
end

get '/bar' do
  session['secret']
end
```

### Управление кэшированием

Установка корректных заголовков — основа правильного HTTP кэширования.

Вы можете легко выставить заголовок Cache-Control таким образом:

```ruby
get '/' do
  cache_control :public
  "cache it!"
end
```

Совет: задавайте кэширование в `before`-фильтре:

```ruby
before do
  cache_control :public, :must_revalidate, :max_age => 60
end
```

Если вы используете метод `expires` для задания соответствующего заголовка, то
`Cache-Control` будет выставлен автоматически:

```ruby
before do
  expires 500, :public, :must_revalidate
end
```

Чтобы как следует использовать кэширование, вам следует подумать об
использовании `etag` или `last_modified`. Рекомендуется использовать эти
методы-помощники *до* выполнения ресурсоемких вычислений, так как они
немедленно отправят ответ клиенту, если текущая версия уже есть в их кэше:

```ruby
get '/article/:id' do
  @article = Article.find params['id']
  last_modified @article.updated_at
  etag @article.sha1
  erb :article
end
```

Также вы можете использовать
[weak ETag](http://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation):

```ruby
etag @article.sha1, :weak
```

Эти методы-помощники не станут ничего кэшировать для вас, но они дадут
необходимую информацию для вашего кэша. Если вы ищете легкое решение для
кэширования, попробуйте [rack-cache](https://github.com/rtomayko/rack-cache):

```ruby
require 'rack/cache'
require 'sinatra'

use Rack::Cache

get '/' do
  cache_control :public, :max_age => 36000
  sleep 5
  "hello"
end
```

Используйте опцию `:static_cache_control` (см. ниже), чтобы добавить заголовок
`Cache-Control` к статическим файлам.

В соответствии с RFC 2616 ваше приложение должно вести себя по-разному, когда
заголовки If-Match или If-None-Match имеют значение `*`, в зависимости от
того, существует или нет запрашиваемый ресурс. Sinatra предполагает, что
ресурсы, к которым обращаются с помощью безопасных (GET) и идемпотентных (PUT)
методов, уже существуют, а остальные ресурсы (к которым обращаются, например,
с помощью POST) считает новыми. Вы можете изменить данное поведение с помощью
опции `:new_resource`:

```ruby
get '/create' do
  etag '', :new_resource => true
  Article.create
  erb :new_article
end
```

Если вы хотите использовать weak ETag, задайте опцию `:kind`:

```ruby
etag '', :new_resource => true, :kind => :weak
```

### Отправка файлов

Для отправки файлов пользователю вы можете использовать метод `send_file`:

```ruby
get '/' do
  send_file 'foo.png'
end
```

Этот метод имеет несколько опций:

```ruby
send_file 'foo.png', :type => :jpg
```

Возможные опции:

<dl>
  <dt>filename</dt>
  <dd>имя файла, по умолчанию: реальное имя файла.</dd>

  <dt>last_modified</dt>
  <dd>значение для заголовка Last-Modified, по умолчанию: mtime (время
      изменения) файла.</dd>

  <dt>type</dt>
  <dd>тип файла, по умолчанию: определяется по расширению файла.</dd>

  <dt>disposition</dt>
  <dd>используется для заголовка Content-Disposition, возможные значения: <tt>nil</tt>
      (по умолчанию), <tt>:attachment</tt> и <tt>:inline</tt>.</dd>

  <dt>length</dt>
  <dd>значения для заголовка Content-Length, по умолчанию: размер файла.</dd>

  <dt>status</dt>
  <dd>Код ответа. Полезно, когда отдается статический файл в качестве страницы с
      сообщением об ошибке.</dd>
</dl>

Этот метод будет использовать возможности Rack сервера для отправки файлов,
если они доступны, в противном случае будет напрямую отдавать файл из Ruby
процесса. Метод `send_file` также обеспечивает автоматическую обработку
частичных (range) запросов с помощью Sinatra.

### Доступ к объекту запроса

Объект входящего запроса доступен на уровне обработки запроса (в фильтрах,
маршрутах, обработчиках ошибок) с помощью `request` метода:

```ruby
# приложение запущено на http://example.com/example
get '/foo' do
  t = %w[text/css text/html application/javascript]
  request.accept              # ['text/html', '*/*']
  request.accept? 'text/xml'  # true
  request.preferred_type(t)   # 'text/html'
  request.body                # тело запроса, посланное клиентом (см. ниже)
  request.scheme              # "http"
  request.script_name         # "/example"
  request.path_info           # "/foo"
  request.port                # 80
  request.request_method      # "GET"
  request.query_string        # ""
  request.content_length      # длина тела запроса
  request.media_type          # медиатип тела запроса
  request.host                # "example.com"
  request.get?                # true (есть аналоги для других методов HTTP)
  request.form_data?          # false
  request["some_param"]       # значение параметра some_param. Шорткат для хеша params
  request.referrer            # источник запроса клиента либо '/'
  request.user_agent          # user agent (используется для :agent условия)
  request.cookies             # хеш, содержащий cookies браузера
  request.xhr?                # является ли запрос ajax запросом?
  request.url                 # "http://example.com/example/foo"
  request.path                # "/example/foo"
  request.ip                  # IP-адрес клиента
  request.secure?             # false (true, если запрос сделан через SSL)
  request.forwarded?          # true (если сервер работает за обратным прокси)
  request.env                 # "сырой" env хеш, полученный Rack
end
```

Некоторые опции, такие как `script_name` или `path_info`, доступны для
изменения:

```ruby
before { request.path_info = "/" }

get "/" do
  "all requests end up here"
end
```

`request.body` является IO или StringIO объектом:

```ruby
post "/api" do
  request.body.rewind  # в случае, если кто-то уже прочитал тело запроса
  data = JSON.parse request.body.read
  "Hello #{data['name']}!"
end
```

### Вложения

Вы можете использовать метод `attachment`, чтобы сказать браузеру, что ответ
сервера должен быть сохранен на диск, а не отображен:

```ruby
get '/' do
  attachment
  "store it!"
end
```

Вы также можете указать имя файла:

```ruby
get '/' do
  attachment "info.txt"
  "store it!"
end
```

### Работа со временем и датами

Sinatra предлагает метод-помощник `time_for`, который из заданного значения
создает объект Time. Он также может конвертировать `DateTime`, `Date` и
подобные классы:

```ruby
get '/' do
  pass if Time.now > time_for('Dec 23, 2012')
  "still time"
end
```

Этот метод используется внутри Sinatra методами `expires`, `last_modified` и
им подобными. Поэтому вы легко можете изменить и дополнить поведение этих методов,
переопределив `time_for` в своем приложении:

```ruby
helpers do
  def time_for(value)
    case value
    when :yesterday then Time.now - 24*60*60
    when :tomorrow  then Time.now + 24*60*60
    else super
    end
  end
end

get '/' do
  last_modified :yesterday
  expires :tomorrow
  "hello"
end
```

### Поиск шаблонов

Для поиска шаблонов и их последующего рендеринга используется метод
`find_template`:

```ruby
find_template settings.views, 'foo', Tilt[:haml] do |file|
  puts "could be #{file}"
end
```

Это не слишком полезный пример. Зато полезен тот факт, что вы можете
переопределить этот метод, чтобы использовать свой собственный механизм
поиска. Например, если вы хотите, чтобы можно было использовать несколько
директорий с шаблонами:

```ruby
set :views, ['views', 'templates']

helpers do
  def find_template(views, name, engine, &block)
    Array(views).each { |v| super(v, name, engine, &block) }
  end
end
```

Другой пример, в котором используются разные директории для движков
рендеринга:

```ruby
set :views, :sass => 'views/sass', :haml => 'templates', :default => 'views'

helpers do
  def find_template(views, name, engine, &block)
    _, folder = views.detect { |k,v| engine == Tilt[k] }
    folder ||= views[:default]
    super(folder, name, engine, &block)
  end
end
```

Вы можете легко вынести этот код в расширение и поделиться им с остальными!

Заметьте, что `find_template` не проверяет, существует ли файл на самом деле,
а вызывает заданный блок для всех возможных путей. Дело тут не в
производительности, дело в том, что `render` вызовет `break`, как только файл
не будет найден. Содержимое и местонахождение шаблонов будет закэшировано,
если приложение запущено не в режиме разработки (`set :environment,
:development`). Вы должны помнить об этих нюансах,  если пишите по-настоящему
"сумасшедший" метод.

## Конфигурация

Этот блок исполняется один раз при старте в любом окружении, режиме
(environment):

```ruby
configure do
  # задание одной опции
  set :option, 'value'

  # устанавливаем несколько опций
  set :a => 1, :b => 2

  # то же самое, что и `set :option, true`
  enable :option

  # то же самое, что и `set :option, false`
  disable :option

  # у вас могут быть "динамические" опции с блоками
  set(:css_dir) { File.join(views, 'css') }
end
```

Будет запущено, когда окружение (RACK_ENV переменная) `:production`:

```ruby
configure :production do
  ...
end
```

Будет запущено, когда окружение `:production` или `:test`:

```ruby
configure :production, :test do
  ...
end
```

Вы можете получить доступ к этим опциям с помощью `settings`:

```ruby
configure do
  set :foo, 'bar'
end

get '/' do
  settings.foo? # => true
  settings.foo  # => 'bar'
  ...
end
```

### Настройка защиты от атак

Sinatra использует
[Rack::Protection](https://github.com/rkh/rack-protection#readme) для защиты
приложения от простых атак. Вы можете легко выключить эту защиту (что сделает
ваше приложение чрезвычайно уязвимым):

```ruby
disable :protection
```

Чтобы пропустить какой-либо уровень защиты, передайте хеш опций в параметр
`protection`:

```ruby
set :protection, :except => :path_traversal
```

Вы также можете отключить сразу несколько уровней защиты:

```ruby
set :protection, :except => [:path_traversal, :session_hijacking]
```

### Доступные настройки

<dl>
  <dt>absolute_redirects</dt>
  <dd>
    если отключено, то Sinatra будет позволять использование относительных
    перенаправлений, но при этом перестанет соответствовать RFC 2616 (HTTP
    1.1), который разрешает только абсолютные перенаправления.
  </dd>
  <dd>
    Включайте эту опцию, если ваше приложение работает за обратным прокси,
    который настроен не совсем корректно. Обратите внимание, метод <tt>url</tt> все
    равно будет генерировать абсолютные URL, если вы не передадите <tt>false</tt>
    вторым аргументом.
  </dd>
  <dd>Отключено по умолчанию.</dd>

  <dt>add_charset</dt>
  <dd>
    mime-типы, к которым метод <tt>content_type</tt> будет автоматически добавлять
    информацию о кодировке. Вам следует добавлять значения к этой опции
    вместо ее переопределения: <tt>settings.add_charset &lt;&lt; "application/foobar"</tt>
  </dd>

  <dt>app_file</dt>
  <dd>
    путь к главному файлу приложения, используется для нахождения корневой
    директории проекта, директорий с шаблонами и статическими файлами,
    вложенных шаблонов.
  </dd>

  <dt>bind</dt>
  <dd>
    используемый IP-адрес (по умолчанию: 0.0.0.0). Используется только
    встроенным сервером.
  </dd>

  <dt>default_encoding</dt>
  <dd>кодировка, если неизвестна (по умолчанию: <tt>"utf-8"</tt>).</dd>

  <dt>dump_errors</dt>
  <dd>отображать ошибки в логе.</dd>

  <dt>environment</dt>
  <dd>
    текущее окружение, по умолчанию, значение <tt>ENV['RACK_ENV']</tt> или
    <tt>"development"</tt>, если <tt>ENV['RACK_ENV']</tt> недоступна.
  </dd>

  <dt>logging</dt>
  <dd>использовать логер.</dd>

  <dt>lock</dt>
  <dd>
    создает блокировку для каждого запроса, которая гарантирует обработку
    только одного запроса в текущий момент времени в Ruby процессе.
  </dd>
  <dd>
    Включайте, если ваше приложение не потоко-безопасно (thread-safe).
    Отключено по умолчанию.</dd>

  <dt>method_override</dt>
  <dd>
    использовать "магический" параметр <tt>_method</tt>, для поддержки
    PUT/DELETE форм в браузерах, которые не поддерживают эти методы.
  </dd>

  <dt>port</dt>
  <dd>
    порт, на котором будет работать сервер.
    Используется только встроенным сервером.
  </dd>

  <dt>prefixed_redirects</dt>
  <dd>
    добавлять или нет параметр <tt>request.script_name</tt> к редиректам, если не
    задан абсолютный путь. Таким образом, <tt>redirect '/foo'</tt> будет вести себя
    как <tt>redirect to('/foo')</tt>. Отключено по умолчанию.
  </dd>

  <dt>protection</dt>
  <dd>включена или нет защита от атак. Смотрите секцию выше.</dd>

  <dt>public_dir</dt>
  <dd>Алиас для <tt>public_folder</tt>.</dd>

  <dt>public_folder</dt>
  <dd>
    путь к директории, откуда будут раздаваться статические файлы.
    Используется, только если включена раздача статических файлов
    (см. опцию <tt>static</tt> ниже).
  </dd>

  <dt>reload_templates</dt>
  <dd>
    перезагружать или нет шаблоны на каждый запрос. Включено в режиме
    разработки.
  </dd>

  <dt>root</dt>
  <dd>путь к корневой директории проекта.</dd>

  <dt>raise_errors</dt>
  <dd>
    выбрасывать исключения (будет останавливать приложение).
    По умолчанию включено только в окружении <tt>test</tt>.
  </dd>

  <dt>run</dt>
  <dd>
    если включено, Sinatra будет самостоятельно запускать веб-сервер. Не
    включайте, если используете rackup или аналогичные средства.
  </dd>

  <dt>running</dt>
  <dd>работает ли сейчас встроенный сервер? Не меняйте эту опцию!</dd>

  <dt>server</dt>
  <dd>
    сервер или список серверов, которые следует использовать в качестве
    встроенного сервера. По умолчанию: <tt>['thin', 'mongrel', 'webrick']</tt>, порядок
    задает приоритет.</dd>

  <dt>sessions</dt>
  <dd>
    включить сессии на основе кук (cookie) на базе <tt>Rack::Session::Cookie</tt>.
    Смотрите секцию "Использование сессий" выше.
  </dd>

  <dt>show_exceptions</dt>
  <dd>
    показывать исключения/стек вызовов (stack trace) в браузере. По умолчанию
    включено только в окружении <tt>development</tt>.
  </dd>
  <dd>
    Может быть установлено в
    <tt>:after_handler</tt> для запуска специфичной для приложения обработки ошибок,
    перед показом трассировки стека в браузере.
  </dd>

  <dt>static</dt>
  <dd>должна ли Sinatra осуществлять раздачу статических файлов.</dd>
  <dd>Отключите, когда используете какой-либо веб-сервер для этой цели.</dd>
  <dd>Отключение значительно улучшит производительность приложения.</dd>
  <dd>По умолчанию включено в классических и отключено в модульных приложениях.</dd>

  <dt>static_cache_control</dt>
  <dd>
    когда Sinatra отдает статические файлы, используйте эту опцию, чтобы
    добавить им заголовок <tt>Cache-Control</tt>. Для этого используется
    метод-помощник <tt>cache_control</tt>. По умолчанию отключено.
  </dd>
  <dd>
    Используйте массив, когда надо задать несколько значений:
    <tt>set :static_cache_control, [:public, :max_age => 300]</tt>
  </dd>

  <dt>threaded</dt>
  <dd>
    если включено, то Thin будет использовать <tt>EventMachine.defer</tt> для
    обработки запросов.
  </dd>

  <dt>traps</dt>
  <dd>должна ли Синатра обрабатывать системные сигналы или нет.</tt></dd>

  <dt>views</dt>
  <dd>путь к директории с шаблонами.</dd>
</dl>

## Режим, окружение

Есть 3 предопределенных режима, окружения: `"development"`, `"production"` и
`"test"`. Режим может быть задан через переменную окружения `RACK_ENV`.
Значение по умолчанию — `"development"`. В этом режиме работы все шаблоны
перезагружаются между запросами. А также задаются специальные обработчики
`not_found` и `error`, чтобы вы могли увидеть стек вызовов. В окружениях
`"production"` и `"test"` шаблоны по умолчанию кэшируются.

Для запуска приложения в определенном окружении используйте ключ `-e`

```
ruby my_app.rb -e [ENVIRONMENT]
```

Вы можете использовать предопределенные методы `development?`, `test?` и
+production?, чтобы определить текущее окружение.

## Обработка ошибок

Обработчики ошибок исполняются в том же контексте, что и маршруты, и
`before`-фильтры, а это означает, что всякие прелести вроде `haml`, `erb`,
`halt` и т.д. доступны и им.

### Not Found

Когда выброшено исключение `Sinatra::NotFound`, или кодом ответа является 404,
то будет вызван `not_found` обработчик:

```ruby
not_found do
  'This is nowhere to be found.'
end
```

### Error

Обработчик ошибок `error` будет вызван, когда исключение выброшено из блока
маршрута, либо из фильтра. Объект-исключение доступен как переменная
`sinatra.error` в Rack:

```ruby
error do
  'Sorry there was a nasty error - ' + env['sinatra.error'].message
end
```

Конкретные ошибки:

```ruby
error MyCustomError do
  'So what happened was...' + env['sinatra.error'].message
end
```

Тогда, если это произошло:

```ruby
get '/' do
  raise MyCustomError, 'something bad'
end
```

То вы получите:

```
So what happened was... something bad
```

Также вы можете установить обработчик ошибок для кода состояния HTTP:

```ruby
error 403 do
  'Access forbidden'
end

get '/secret' do
  403
end
```

Либо набора кодов:

```ruby
error 400..510 do
  'Boom'
end
```

Sinatra устанавливает специальные `not_found` и `error` обработчики, когда
приложение запущено в режиме разработки (окружение `:development`).

## Rack "прослойки"

Sinatra использует [Rack](http://rack.github.io/), минимальный стандартный
интерфейс для веб-фреймворков на Ruby. Одной из самых интересных для
разработчиков возможностей Rack является поддержка "прослоек" ("middleware") —
компонентов, находящихся "между" сервером и вашим приложением, которые
отслеживают и/или манипулируют HTTP запросами/ответами для предоставления
различной функциональности.

В Sinatra очень просто использовать такие "прослойки" с помощью метода `use`:

```ruby
require 'sinatra'
require 'my_custom_middleware'

use Rack::Lint
use MyCustomMiddleware

get '/hello' do
  'Hello World'
end
```

Семантика `use` идентична той, что определена для
[Rack::Builder](http://rubydoc.info/github/rack/rack/master/Rack/Builder) DSL
(чаще всего используется в rackup файлах). Например, метод `use` принимает как
множественные переменные, так и блоки:

```ruby
use Rack::Auth::Basic do |username, password|
  username == 'admin' && password == 'secret'
end
```

Rack распространяется с различными стандартными "прослойками" для логирования,
отладки, маршрутизации URL, аутентификации, обработки сессий. Sinatra
использует многие из этих компонентов автоматически, основываясь на
конфигурации, чтобы вам не приходилось подключать (`use`) их вручную.

Вы можете найти полезные прослойки в
[rack](https://github.com/rack/rack/tree/master/lib/rack),
[rack-contrib](https://github.com/rack/rack-contrib#readme),
или в
[Rack wiki](https://github.com/rack/rack/wiki/List-of-Middleware).

## Тестирование

Тесты для Sinatra приложений могут быть написаны с помощью библиотек,
фреймворков, поддерживающих тестирование Rack.
[Rack::Test](http://rdoc.info/github/brynary/rack-test/master/frames)
рекомендован:

```ruby
require 'my_sinatra_app'
require 'minitest/autorun'
require 'rack/test'

class MyAppTest < Minitest::Test
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_my_default
    get '/'
    assert_equal 'Hello World!', last_response.body
  end

  def test_with_params
    get '/meet', :name => 'Frank'
    assert_equal 'Hello Frank!', last_response.body
  end

  def test_with_rack_env
    get '/', {}, 'HTTP_USER_AGENT' => 'Songbird'
    assert_equal "You're using Songbird!", last_response.body
  end
end
```

## Sinatra::Base — "прослойки", библиотеки и модульные приложения

Описание своего приложения самым простейшим способом (с помощью DSL верхнего
уровня, классический стиль) отлично работает для крохотных приложений. В таких
случаях используется конфигурация, рассчитанная на  микро-приложения
(единственный файл приложения, `./public` и `./views` директории, логирование,
страница информации об исключении и т.д.). Тем не менее, такой метод имеет
множество недостатков при создании компонентов, таких как Rack middleware
("прослоек"), Rails metal, простых библиотек с серверными компонентами,
расширений Sinatra. И тут на помощь приходит `Sinatra::Base`:

```ruby
require 'sinatra/base'

class MyApp < Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Hello world!'
  end
end
```

Методы, доступные `Sinatra::Base` подклассам идентичны тем, что доступны
приложениям в DSL верхнего уровня. Большинство таких приложений могут быть
конвертированы в `Sinatra::Base` компоненты с помощью двух модификаций:

* Вы должны подключать `sinatra/base` вместо `sinatra`, иначе все методы,
  предоставляемые Sinatra, будут импортированы в глобальное пространство
  имен.
* Поместите все маршруты, обработчики ошибок, фильтры и опции в подкласс
  `Sinatra::Base`.

`Sinatra::Base` — это чистый лист. Большинство опций, включая встроенный
сервер, по умолчанию отключены. Смотрите
[Опции и конфигурация](http://www.sinatrarb.com/configuration.html)
для детальной информации об опциях и их поведении.

### Модульные приложения против классических

Вопреки всеобщему убеждению, в классическом стиле (самом простом) нет ничего
плохого. Если этот стиль подходит вашему приложению, вы не обязаны
переписывать его в модульное приложение.

Основным недостатком классического стиля является тот факт, что у вас может
быть только одно приложение Sinatra на один процесс Ruby. Если вы планируете
использовать больше, переключайтесь на модульный стиль. Вы можете смело
смешивать модульный и классический стили.

Переходя с одного стиля на другой, примите во внимание следующие изменения в
настройках:

    Опция               Классический            Модульный

    app_file            файл с приложением      файл с подклассом Sinatra::Base
    run                 $0 == app_file          false
    logging             true                    false
    method_override     true                    false
    inline_templates    true                    false
    static              true                    false

### Запуск модульных приложений

Есть два общепринятых способа запускать модульные приложения: запуск напрямую
с помощью `run!`:

```ruby
# my_app.rb
require 'sinatra/base'

class MyApp < Sinatra::Base
  # ... здесь код приложения ...

  # запускаем сервер, если исполняется текущий файл
  run! if app_file == $0
end
```

Затем:

```
ruby my_app.rb
```

Или с помощью конфигурационного файла `config.ru`, который позволяет
использовать любой Rack-совместимый сервер приложений.

```ruby
# config.ru
require './my_app'
run MyApp
```

Запускаем:

```
rackup -p 4567
```

### Запуск классических приложений с config.ru

Файл приложения:

```ruby
# app.rb
require 'sinatra'

get '/' do
  'Hello world!'
end
```

И соответствующий `config.ru`:

```ruby
require './app'
run Sinatra::Application
```

### Когда использовать config.ru?

Вот несколько причин, по которым вы, возможно, захотите использовать
`config.ru`:

* вы хотите разворачивать свое приложение на различных Rack-совместимых
  серверах (Passenger, Unicorn, Heroku, ...);
* вы хотите использовать более одного подкласса `Sinatra::Base`;
* вы хотите использовать Sinatra только в качестве "прослойки" Rack.

**Совсем необязательно переходить на использование `config.ru` лишь потому,
что вы стали использовать модульный стиль приложения. И необязательно
использовать модульный стиль, чтобы запускать приложение с помощью
`config.ru`.**

### Использование Sinatra в качестве "прослойки"

Не только сама Sinatra может использовать "прослойки" Rack, но и любое Sinatra
приложение само может быть добавлено к любому Rack endpoint в качестве
"прослойки". Этим endpoint (конечной точкой) может быть другое Sinatra
приложение, или приложение, основанное на Rack (Rails/Ramaze/Camping/...):

```ruby
require 'sinatra/base'

class LoginScreen < Sinatra::Base
  enable :sessions

  get('/login') { haml :login }

  post('/login') do
    if params['name'] == 'admin' && params['password'] == 'admin'
      session['user_name'] = params['name']
    else
      redirect '/login'
    end
  end
end

class MyApp < Sinatra::Base
  # "прослойка" будет запущена перед фильтрами
  use LoginScreen

  before do
    unless session['user_name']
      halt "Access denied, please <a href='/login'>login</a>."
    end
  end

  get('/') { "Hello #{session['user_name']}." }
end
```

### Создание приложений "на лету"

Иногда требуется создавать Sinatra приложения "на лету" (например, из другого
приложения). Это возможно с помощью `Sinatra.new`:

```ruby
require 'sinatra/base'
my_app = Sinatra.new { get('/') { "hi" } }
my_app.run!
```

Этот метод может принимать аргументом приложение, от которого следует
наследоваться:

```ruby
# config.ru
require 'sinatra/base'

controller = Sinatra.new do
  enable :logging
  helpers MyHelpers
end

map('/a') do
  run Sinatra.new(controller) { get('/') { 'a' } }
end

map('/b') do
  run Sinatra.new(controller) { get('/') { 'b' } }
end
```

Это особенно полезно для тестирования расширений Sinatra и при использовании
Sinatra внутри вашей библиотеки.

Благодаря этому, использовать Sinatra как "прослойку" очень просто:

```ruby
require 'sinatra/base'

use Sinatra do
  get('/') { ... }
end

run RailsProject::Application
```

## Области видимости и привязка

Текущая область видимости определяет методы и переменные, доступные в данный
момент.

### Область видимости приложения / класса

Любое Sinatra приложение соответствует подклассу `Sinatra::Base`. Если вы
используете DSL верхнего уровня (`require 'sinatra'`), то этим классом будет
`Sinatra::Application`, иначе это будет подкласс, который вы создали вручную.
На уровне класса вам будут доступны такие методы, как `get` или `before`, но
вы не сможете получить доступ к объектам `request` или `session`, так как
существует только один класс приложения для всех запросов.

Опции, созданные с помощью `set`, являются методами уровня класса:

```ruby
class MyApp < Sinatra::Base
  # Я в области видимости приложения!
  set :foo, 42
  foo # => 42

  get '/foo' do
    # Я больше не в области видимости приложения!
  end
end
```

У вас будет область видимости приложения внутри:

* тела вашего класса приложения;
* методов, определенных расширениями;
* блока, переданного в `helpers`;
* блоков, использованных как значения для `set`;
* блока, переданного в `Sinatra.new`.

Вы можете получить доступ к объекту области видимости (классу приложения)
следующими способами:

* через объект, переданный блокам конфигурации (`configure { |c| ... }`);
* `settings` внутри области видимости запроса.

### Область видимости запроса/экземпляра

Для каждого входящего запроса будет создан новый экземпляр вашего приложения,
и все блоки обработчика будут запущены в этом контексте. В этой области
видимости вам доступны `request` и `session` объекты, вызовы методов
рендеринга, такие как `erb` или `haml`. Вы можете получить доступ к области
видимости приложения из контекста запроса, используя метод-помощник
`settings`:

```ruby
class MyApp < Sinatra::Base
  # Я в области видимости приложения!
  get '/define_route/:name' do
    # Область видимости запроса '/define_route/:name'
    @value = 42

    settings.get("/#{params['name']}") do
      # Область видимости запроса "/#{params['name']}"
      @value # => nil (другой запрос)
    end

    "Route defined!"
  end
end
```

У вас будет область видимости запроса в:

* get/head/post/put/delete/options блоках;
* before/after фильтрах;
* методах-помощниках;
* шаблонах/отображениях.

### Область видимости делегирования

Область видимости делегирования просто перенаправляет методы в область
видимости класса. Однако, она не полностью ведет себя как область видимости
класса, так как у вас нет привязки к классу. Только методы, явно помеченные
для делегирования, будут доступны, а переменных/состояний области видимости
класса не будет (иначе говоря, у вас будет другой `self` объект). Вы можете
непосредственно добавить методы делегирования, используя
`Sinatra::Delegator.delegate :method_name`.

У вас будет контекст делегирования внутри:

*  привязки верхнего уровня, если вы сделали `require 'sinatra'`;
*  объекта, расширенного с помощью `Sinatra::Delegator`.

Посмотрите сами в код: вот
[примесь Sinatra::Delegator](https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/base.rb#L1609-1633)
[расширяет главный объект](https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/main.rb#L28-30).

## Командная строка

Sinatra приложения могут быть запущены напрямую:

```
ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-o HOST] [-s HANDLER]
```

Опции включают:

```
-h # раздел помощи
-p # указание порта (по умолчанию 4567)
-o # указание хоста (по умолчанию 0.0.0.0)
-e # указание окружения, режима (по умолчанию development)
-s # указание rack сервера/обработчика (по умолчанию thin)
-x # включить мьютекс-блокировку (по умолчанию выключена)
```

## Системные требования

Следующие версии Ruby официально поддерживаются:

<dl>
  <dt>Ruby 1.8.7</dt>
  <dd>1.8.7 полностью поддерживается, тем не менее, если вас ничто не держит на
    этой версии, рекомендуем обновиться до 1.9.2 или перейти на JRuby или
    Rubinius. Поддержка 1.8.7 не будет прекращена до выхода Sinatra 2.0 и Ruby
    2.0, разве что в случае релиза 1.8.8 (что маловероятно). Но даже тогда,
    возможно, поддержка не будет прекращена. <b>Ruby 1.8.6 больше не
    поддерживается.</b> Если вы хотите использовать 1.8.6, откатитесь до Sinatra
    1.2, которая будет получать все исправления ошибок до тех пор, пока не
    будет выпущена Sinatra 1.4.0.</dd>

  <dt>Ruby 1.9.2</dt>
  <dd>1.9.2 полностью поддерживается и рекомендована к использованию.
    Не используйте 1.9.2p0,
    известно, что эта версия очень нестабильна при использовании Sinatra. Эта
    версия будет поддерживаться по крайней мере до выхода Ruby 1.9.4/2.0, а
    поддержка последней версии 1.9 будет осуществляться до тех пор, пока она
    поддерживается командой разработчиков Ruby.</dd>

  <dt>Ruby 1.9.3</dt>
  <dd>1.9.3 полностью поддерживается. Заметьте, что переход на 1.9.3 с
    ранних версий сделает недействительными все сессии.</dd>

  <dt>Rubinius</dt>
  <dd>Rubinius официально поддерживается (Rubinius &gt;= 1.2.4), всё, включая все
  языки шаблонов, работает. Предстоящий релиз 2.0 также поддерживается.</dd>

  <dt>JRuby</dt>
  <dd>JRuby официально поддерживается (JRuby &gt;= 1.6.5). Нет никаких проблем с
  использованием альтернативных шаблонов. Тем не менее, если вы выбираете
  JRuby, то, пожалуйста, посмотрите на JRuby Rack-серверы, так как Thin не
  поддерживается полностью на JRuby. Поддержка расширений на C в JRuby все
  еще экспериментальная, что на данный момент затрагивает только RDiscount,
  Redcarpet и RedCloth.</dd>
</dl>

Мы также следим за предстоящими к выходу версиями Ruby.

Следующие реализации Ruby не поддерживаются официально, но известно, что на
них запускается Sinatra:

* старые версии JRuby и Rubinius;
* Ruby Enterprise Edition;
* MacRuby, Maglev, IronRuby;
* Ruby 1.9.0 и 1.9.1 (настоятельно не рекомендуются к использованию).

То, что версия официально не поддерживается, означает, что, если что-то не
работает на этой версии, а на поддерживаемой работает — это не наша проблема,
а их.

Мы также запускаем наши CI-тесты на версии Ruby, находящейся в разработке
(предстоящей 2.0.0), и на 1.9.4, но мы не можем ничего гарантировать, так как
они находятся в разработке. Предполагается, что 1.9.4p0 и 2.0.0p0 будут
поддерживаться.

Sinatra должна работать на любой операционной системе, в которой есть одна из
указанных выше версий Ruby.

Пока невозможно запустить Sinatra на Cardinal, SmallRuby, BlueRuby и на любой
версии Ruby до 1.8.7.

## На острие

Если вы хотите использовать самый последний код Sinatra, не бойтесь запускать
свое приложение вместе с кодом из master ветки Sinatra, она весьма стабильна.

Мы также время от времени выпускаем предварительные версии, так что вы можете
делать так:

```
gem install sinatra --pre
```

Чтобы воспользоваться некоторыми самыми последними возможностями.

### С помощью Bundler

Если вы хотите запускать свое приложение с последней версией Sinatra, то
рекомендуем использовать [Bundler](http://gembundler.com/).

Сначала установите Bundler, если у вас его еще нет:

```
gem install bundler
```

Затем создайте файл `Gemfile` в директории вашего проекта:

```ruby
source :rubygems
gem 'sinatra', :git => "git://github.com/sinatra/sinatra.git"

# другие зависимости
gem 'haml'                    # например, если используете haml
gem 'activerecord', '~> 3.0'  # может быть, вам нужен и ActiveRecord 3.x
```

Обратите внимание, вам нужно будет указывать все зависимости вашего приложения
в этом файле. Однако, непосредственные зависимости Sinatra (Rack и Tilt)
Bundler автоматически скачает и добавит.

Теперь вы можете запускать свое приложение так:

```
bundle exec ruby myapp.rb
```

### Вручную

Создайте локальный клон репозитория и запускайте свое приложение с
`sinatra/lib` директорией в `$LOAD_PATH`:

```
cd myapp
git clone git://github.com/sinatra/sinatra.git
ruby -Isinatra/lib myapp.rb
```

Чтобы обновить исходники Sinatra:

```
cd myapp/sinatra
git pull
```

### Установка глобально

Вы можете самостоятельно собрать gem:

```
git clone git://github.com/sinatra/sinatra.git
cd sinatra
rake sinatra.gemspec
rake install
```

Если вы устанавливаете пакеты (gem) от пользователя root, то вашим последним
шагом должна быть команда

```
sudo rake install
```

## Версии

Sinatra использует [Semantic Versioning](http://semver.org/), SemVer и
SemVerTag.

## Дальнейшее чтение

* [Веб-сайт проекта](http://www.sinatrarb.com/) — Дополнительная
  документация, новости и ссылки на другие ресурсы.
* [Участие в проекте](http://www.sinatrarb.com/contributing) — Обнаружили
  баг? Нужна помощь? Написали патч?
* [Слежение за проблемами/ошибками](http://github.com/sinatra/sinatra/issues)
* [Twitter](http://twitter.com/sinatra)
* [Группы рассылки](http://groups.google.com/group/sinatrarb/topics)
* [#sinatra](irc://chat.freenode.net/#sinatra) на http://freenode.net
* [Sinatra Book](https://github.com/sinatra/sinatra-book/) учебник и сборник рецептов
* [Sinatra Recipes](http://recipes.sinatrarb.com/) сборник рецептов
* API документация к [последнему релизу](http://rubydoc.info/gems/sinatra)
  или [текущему HEAD](http://rubydoc.info/github/sinatra/sinatra) на
  http://rubydoc.info
* [Сервер непрерывной интеграции](http://travis-ci.org/sinatra/sinatra)
# Sinatra

*Atenção: Este documento é apenas uma tradução da versão em inglês e
pode estar desatualizado.*

Alguns dos trechos de código a seguir utilizam caracteres UTF-8. Então, caso esteja utilizando uma versão de ruby inferior à `2.0.0`, adicione o encoding no início de seus arquivos:

```ruby
# encoding: utf-8
```

Sinatra é uma [DSL](http://pt.wikipedia.org/wiki/Linguagem_de_domínio_específico) para
criar aplicações web em Ruby com o mínimo de esforço e rapidez:

``` ruby
# minha_app.rb
require 'sinatra'

get '/' do
  'Olá Mundo!'
end
```

Instale a gem:

``` shell
gem install sinatra
```

Em seguida execute:

``` shell
ruby minha_app.rb
```

Acesse: [localhost:4567](http://localhost:4567)

É recomendado também executar `gem install thin`. Caso esta gem esteja disponível, o
Sinatra irá utilizá-la.

## Conteúdo

* [Sinatra](#sinatra)
    * [Conteúdo](#conteúdo)
    * [Rotas](#rotas)
    * [Condições](#condições)
    * [Retorno de valores](#retorno-de-valores)
    * [Validadores de rota personalizados](#validadores-de-rota-personalizados)
    * [Arquivos estáticos](#arquivos-estáticos)
    * [Views / Templates](#views--templates)
        * [Literal Templates](#literal-templates)
        * [Linguagens de template disponíveis](#linguagens-de-template-disponíveis)
            * [Haml Templates](#haml-templates)
            * [Erb Templates](#erb-templates)
            * [Builder Templates](#builder-templates)
            * [Nokogiri Templates](#nokogiri-templates)
            * [Sass Templates](#sass-templates)
            * [SCSS Templates](#scss-templates)
            * [Less Templates](#less-templates)
            * [Liquid Templates](#liquid-templates)
            * [Markdown Templates](#markdown-templates)
            * [Textile Templates](#textile-templates)
            * [RDoc Templates](#rdoc-templates)
            * [AsciiDoc Templates](#asciidoc-templates)
            * [Radius Templates](#radius-templates)
            * [Markaby Templates](#markaby-templates)
            * [RABL Templates](#rabl-templates)
            * [Slim Templates](#slim-templates)
            * [Creole Templates](#creole-templates)
            * [MediaWiki Templates](#mediawiki-templates)
            * [CoffeeScript Templates](#coffeescript-templates)
            * [Stylus Templates](#stylus-templates)
            * [Yajl Templates](#yajl-templates)
            * [WLang Templates](#wlang-templates)
        * [Acessando Variáveis nos Templates](#acessando-variáveis-nos-templates)
        * [Templates com `yield` e layouts aninhados](#templates-com-yield-e-layouts-aninhados)
        * [Templates Inline](#templates-inline)
        * [Templates Nomeados](#templates-nomeados)
        * [Associando extensões de arquivos](#associando-extensões-de-arquivos)
        * [Adicionando seu Próprio Engine de Template](#adicionando-seu-próprio-engine-de-template)
        * [Customizando lógica para encontrar templates](#customizando-lógica-para-encontrar-templates)
    * [Filtros](#filtros)
    * [Helpers](#helpers)
        * [Utilizando Sessões](#utilizando-sessões)
        * [Halting](#halting)
        * [Passing](#passing)
        * [Desencadeando Outra Rota](#desencadeando-outra-rota)
    * [Configuração](#configuração)
    * [Tratamento de Erros](#tratamento-de-erros)
        * [Erro](#erro)
    * [Mime Types](#mime-types)
    * [Rack Middleware](#rack-middleware)
    * [Testando](#testando)
    * [Sinatra::Base - Middleware, Bibliotecas e aplicativos modulares](#sinatrabase---middleware-bibliotecas-e-aplicativos-modulares)
    * [Linha de comando](#linha-de-comando)
    * [A última versão](#a-última-versão)
    * [Mais](#mais)

## Rotas

No Sinatra, uma rota é um método HTTP emparelhado com um padrão de URL.
Cada rota possui um bloco de execução:

``` ruby
get '/' do
  .. mostrando alguma coisa ..
end

post '/' do
  .. criando alguma coisa ..
end

put '/' do
  .. atualizando alguma coisa ..
end

patch '/' do
  .. modificando alguma coisa ..
end

delete '/' do
  .. removendo alguma coisa ..
end

options '/' do
  .. estabelecendo alguma coisa ..pe
end
```

As rotas são interpretadas na ordem em que são definidas. A primeira
rota encontrada responde a requisição.

Padrões de rota podem conter parâmetros nomeados, acessíveis por meio do
hash `params`:

``` ruby
get '/ola/:nome' do
  # corresponde a "GET /ola/foo" e "GET /ola/bar"
  # params['nome'] é 'foo' ou 'bar'
  "Olá #{params['nome']}!"
end
```

Você também pode acessar parâmetros nomeados por meio dos parâmetros de
um bloco:

``` ruby
get '/ola/:nome' do |n|
  # corresponde a "GET /ola/foo" e "GET /ola/bar"
  # params['nome'] é 'foo' ou 'bar'
  # n guarda o valor de params['nome']
  "Olá #{n}!"
end
```

Padrões de rota também podem conter parâmetros splat (curinga),
acessível por meio do array `params['splat']`:

``` ruby
get '/diga/*/para/*' do
  # corresponde a /diga/ola/para/mundo
  params['splat'] # => ["ola", "mundo"]
end

get '/download/*.*' do
  # corresponde a /download/caminho/do/arquivo.xml
  params['splat'] # => ["caminho/do/arquivo", "xml"]
end
```

Ou com parâmetros de um bloco:

``` ruby
get '/download/*.*' do |caminho, ext|
  [caminho, ext] # => ["caminho/do/arquivo", "xml"]
end
```

Rotas podem casar com expressões regulares:

``` ruby
get /\A\/ola\/([\w]+)\z/ do
  "Olá, #{params['captures'].first}!"
end
```

Ou com parâmetros de um bloco:

``` ruby
get %r{/ola/([\w]+)} do |c|
  # corresponde a "GET /meta/ola/mundo", "GET /ola/mundo/1234" etc.
  "Olá, #{c}!"
end
```

Padrões de rota podem contar com parâmetros opcionais:

``` ruby
get '/posts.?:formato?' do
  # corresponde a "GET /posts" e qualquer extensão "GET /posts.json", "GET /posts.xml", etc.
end
```

Rotas também podem utilizar query strings:

``` ruby
get '/posts' do
  # corresponde a "GET /posts?titulo=foo&autor=bar"
  titulo = params['titulo']
  autor = params['autor']
  # utiliza as variaveis titulo e autor; a query é opicional para a rota /posts
end
```

A propósito, a menos que você desative a proteção contra ataques (veja
abaixo), o caminho solicitado pode ser alterado antes de concluir a
comparação com as suas rotas.

## Condições

Rotas podem incluir uma variedade de condições, tal como o `user agent`:

``` ruby
get '/foo', :agent => /Songbird (\d\.\d)[\d\/]*?/ do
  "Você está usando o Songbird versão #{params['agent'][0]}"
end

get '/foo' do
  # Correspondente a navegadores que não sejam Songbird
end
```

Outras condições disponíveis são `host_name` e `provides`:

``` ruby
get '/', :host_name => /^admin\./ do
  "Área administrativa. Acesso negado!"
end

get '/', :provides => 'html' do
  haml :index
end

get '/', :provides => ['rss', 'atom', 'xml'] do
  builder :feed
end
```
`provides` procura pelos Accept header das requisições

Você pode facilmente definir suas próprias condições:

``` ruby
set(:probabilidade) { |valor| condition { rand <= valor } }

get '/ganha_um_carro', :probabilidade => 0.1 do
  "Você ganhou!"
end

get '/ganha_um_carro' do
  "Sinto muito, você perdeu."
end
```

Use splat, para uma condição que leva vários valores:

``` ruby
set(:auth) do |*roles|   # <- observe o splat aqui
  condition do
    unless logged_in? && roles.any? {|role| current_user.in_role? role }
      redirect "/login/", 303
    end
  end
end

get "/minha/conta/", :auth => [:usuario, :administrador] do
  "Detalhes da sua conta"
end

get "/apenas/administrador/", :auth => :administrador do
  "Apenas administradores são permitidos aqui!"
end
```

## Retorno de valores

O valor de retorno do bloco de uma rota determina pelo menos o corpo da
resposta passado para o cliente HTTP, ou pelo menos o próximo middleware
na pilha Rack. Frequentemente, isto é uma `string`, tal como nos
exemplos acima. Entretanto, outros valores também são aceitos.

Você pode retornar uma resposta válida ou um objeto para o Rack, sendo
eles de qualquer tipo de objeto que queira. Além disso, é possível
retornar um código de status HTTP.

* Um array com três elementros: `[status (Fixnum), cabecalho (Hash),
    corpo da resposta (responde à #each)]`

* Um array com dois elementros: `[status (Fixnum), corpo da resposta
    (responde à #each)]`

* Um objeto que responda à `#each` sem passar nada, mas, sim, `strings`
    para um dado bloco

* Um objeto `Fixnum` representando o código de status

Dessa forma, podemos implementar facilmente um exemplo de streaming:

``` ruby
class Stream
  def each
    100.times { |i| yield "#{i}\n" }
  end
end

get('/') { Stream.new }
```

Você também pode usar o método auxiliar `stream` (descrito abaixo) para
incorporar a lógica de streaming na rota.

## Validadores de Rota Personalizados

Como apresentado acima, a estrutura do Sinatra conta com suporte
embutido para uso de padrões de String e expressões regulares como
validadores de rota. No entanto, ele não pára por aí. Você pode
facilmente definir os seus próprios validadores:

``` ruby
class AllButPattern
  Match = Struct.new(:captures)

  def initialize(except)
    @except   = except
    @captures = Match.new([])
  end

  def match(str)
    @captures unless @except === str
  end
end

def all_but(pattern)
  AllButPattern.new(pattern)
end

get all_but("/index") do
  # ...
end
```

Note que o exemplo acima pode ser robusto e complicado em excesso. Pode
também ser implementado como:

``` ruby
get // do
  pass if request.path_info == "/index"
  # ...
end
```

Ou, usando algo mais denso à frente:

``` ruby
get %r{^(?!/index$)} do
  # ...
end
```

## Arquivos estáticos

Arquivos estáticos são disponibilizados a partir do diretório
`./public`. Você pode especificar um local diferente pela opção
`:public_folder`

``` ruby
set :public_folder, File.dirname(__FILE__) + '/estatico'
```

Note que o nome do diretório público não é incluido na URL. Um arquivo
`./public/css/style.css` é disponibilizado como
`http://exemplo.com/css/style.css`.

## Views / Templates

Cada linguagem de template é exposta através de seu próprio método de renderização. Estes metodos simplesmente retornam uma string:

``` ruby
get '/' do
  erb :index
end
```

Isto renderiza `views/index.rb`

Ao invés do nome do template, você também pode passar direto o conteúdo do template:

```ruby
get '/' do
  code = "<%= Time.now %>"
  erb code
end
```

Templates também aceitam um segundo argumento, um hash de opções:

``` ruby
get '/' do
  erb :index, :layout => :post
end
```

Isto irá renderizar a `views/index.erb` inclusa dentro da `views/post.erb` (o padrão é a `views/layout.erb`, se existir).

Qualquer opção não reconhecida pelo Sinatra será passada adiante para o engine de template:

``` ruby
get '/' do
  haml :index, :format => :html5
end
```

Você também pode definir opções padrões para um tipo de template:

``` ruby
set :haml, :format => :html5

get '/' do
  haml :index
end
```

Opções passadas para o método de renderização sobrescreve as opções definitas através do método `set`.

Opções disponíveis:

<dl>
  <dt>locals</dt>
  <dd>
    Lista de locais passado para o documento. Conveniente para *partials*
    Exemplo: <tt>erb "<%= foo %>", :locals => {:foo => "bar"}</tt>
  </dd>

  <dt>default_encoding</dt>
  <dd>
    String encoding para ser utilizada em caso de incerteza. o padrão é <tt>settings.default_encoding</tt>.
  </dd>

  <dt>views</dt>
  <dd>
    Diretório de onde os templates são carregados. O padrão é <tt>settings.views</tt>.
  </dd>

  <dt>layout</dt>
  <dd>
    Para definir quando utilizar ou não um
    layout (<tt>true</tt> ou <tt>false</tt>). E se for um
    Symbol, especifica qual template usar. Exemplo:
    <tt>erb :index, :layout => !request.xhr?</tt>
  </dd>

  <dt>content_type</dt>
  <dd>
    O *Content-Type* que o template produz. O padrão depente
    da linguagem de template utilizada.
  </dd>

  <dt>scope</dt>
  <dd>
    Escopo em que o template será renderizado. Padrão é a
    instancia da aplicação. Se você mudar isto as variáveis
    de instânciae metodos auxiliares não serão
    disponibilizados.
  </dd>

  <dt>layout_engine</dt>
  <dd>
    A engine de template utilizada para renderizar seu layout.
    Útil para linguagens que não suportam templates de outra
    forma. O padrão é a engine do template utilizado. Exemplo: 
    <tt>set :rdoc, :layout_engine => :erb</tt>
  </dd>

  <dt>layout_options</dt>
  <dd>
    Opções especiais utilizadas apenas para renderizar o
    layout. Exemplo:
    <tt>set :rdoc, :layout_options => { :views => 'views/layouts' }</tt>
  </dd>
</dl>

É pressuposto que os templates estarão localizados direto sob o diretório `./views`. Para usar um diretório diferente:

```ruby
set :views, settings.root + '/templates'
```

Uma coisa importante para se lembrar é que você sempre deve
referenciar os templates utilizando *symbols*, mesmo que
eles estejam em um subdiretório (neste caso use:
`:'subdir/template'` or `'subdir/template'.to_sym`). Você deve 
utilizar um *symbol* porque senão o método de renderização irá
renderizar qualquer outra string que você passe diretamente
para ele

### Literal Templates

``` ruby
get '/' do
  haml '%div.title Olá Mundo'
end
```

Renderiza um template string.

### Linguagens de template disponíveis

Algumas linguagens possuem multiplas implementações. Para especificar qual implementação deverá ser utilizada (e para ser *thread-safe*), você deve simplesmente requere-la primeiro:

``` ruby
require 'rdiscount' # ou require 'bluecloth'
get('/') { markdown :index }
```

#### Haml Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="http://haml.info/" title="haml">haml</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.haml</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>haml :index, :format => :html5</tt></td>
  </tr>
</table>

#### Erb Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td>
      <a href="http://www.kuwata-lab.com/erubis/" title="erubis">erubis</a>
      or erb (included in Ruby)
    </td>
  </tr>
  <tr>
    <td>Extencao do Arquivos</td>
    <td><tt>.erb</tt>, <tt>.rhtml</tt> or <tt>.erubis</tt> (Erubis only)</td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>erb :index</tt></td>
  </tr>
</table>

#### Builder Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td>
      <a href="https://github.com/jimweirich/builder" title="builder">builder</a>
    </td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.builder</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>builder { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

It also takes a block for inline templates (see exemplo).

#### Nokogiri Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="http://nokogiri.org/" title="nokogiri">nokogiri</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.nokogiri</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>nokogiri { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

It also takes a block for inline templates (see exemplo).

#### Sass Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.sass</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>sass :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>

#### SCSS Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.scss</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>scss :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>

#### Less Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="http://www.lesscss.org/" title="less">less</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.less</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>less :stylesheet</tt></td>
  </tr>
</table>

#### Liquid Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="http://www.liquidmarkup.org/" title="liquid">liquid</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.liquid</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>liquid :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

Já que você não pode chamar o Ruby (exceto pelo método `yield`) pelo template Liquid,
você quase sempre precisará passar o `locals` para ele.

#### Markdown Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td>
      Anyone of:
        <a href="https://github.com/rtomayko/rdiscount" title="RDiscount">RDiscount</a>,
        <a href="https://github.com/vmg/redcarpet" title="RedCarpet">RedCarpet</a>,
        <a href="http://deveiate.org/projects/BlueCloth" title="BlueCloth">BlueCloth</a>,
        <a href="http://kramdown.gettalong.org/" title="kramdown">kramdown</a>,
        <a href="https://github.com/bhollis/maruku" title="maruku">maruku</a>
    </td>
  </tr>
  <tr>
    <td>Extencao do Arquivos</td>
    <td><tt>.markdown</tt>, <tt>.mkd</tt> and <tt>.md</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>markdown :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

Não é possível chamar métodos por este template, nem passar *locals* para o mesmo. Portanto normalmente é utilizado junto a outra engine de renderização:

``` ruby
erb :overview, :locals => { :text => markdown(:introducao) }
```

Note que vcoê também pode chamar o método `markdown` dentro de outros templates:

``` ruby
%h1 Olá do Haml!
%p= markdown(:saudacoes)
```

Já que você não pode chamar o Ruby pelo Markdown, você não
pode utilizar um layout escrito em Markdown. Contudo é
possível utilizar outra engine de renderização como template, 
deve-se passar a `:layout_engine` como opção.

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="http://redcloth.org/" title="RedCloth">RedCloth</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.textile</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>textile :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

Não é possível chamar métodos por este template, nem passar *locals* para o mesmo. Portanto normalmente é utilizado junto a outra engine de renderização:

``` ruby
erb :overview, :locals => { :text => textile(:introducao) }
```

Note que vcoê também pode chamar o método `textile` dentro de outros templates:

``` ruby
%h1 Olá do Haml!
%p= textile(:saudacoes)
```

Já que você não pode chamar o Ruby pelo Textile, você não
pode utilizar um layout escrito em Textile. Contudo é
possível utilizar outra engine de renderização como template, 
deve-se passar a `:layout_engine` como opção.

#### RDoc Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="http://rdoc.sourceforge.net/" title="RDoc">RDoc</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.rdoc</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>rdoc :README, :layout_engine => :erb</tt></td>
  </tr>
</table>

Não é possível chamar métodos por este template, nem passar *locals* para o mesmo. Portanto normalmente é utilizado junto a outra engine de renderização:

``` ruby
erb :overview, :locals => { :text => rdoc(:introducao) }
```

Note que vcoê também pode chamar o método `rdoc` dentro de outros templates:

``` ruby
%h1 Olá do Haml!
%p= rdoc(:saudacoes)
```

Já que você não pode chamar o Ruby pelo RDoc, você não
pode utilizar um layout escrito em RDoc. Contudo é
possível utilizar outra engine de renderização como template, 
deve-se passar a `:layout_engine` como opção.

#### AsciiDoc Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="http://asciidoctor.org/" title="Asciidoctor">Asciidoctor</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.asciidoc</tt>, <tt>.adoc</tt> and <tt>.ad</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>asciidoc :README, :layout_engine => :erb</tt></td>
  </tr>
</table>

Já que você não pode chamar o Ruby pelo template AsciiDoc,
você quase sempre precisará passar o `locals` para ele.

#### Radius Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="https://github.com/jlong/radius" title="Radius">Radius</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.radius</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>radius :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

Já que você não pode chamar o Ruby pelo template Radius,
você quase sempre precisará passar o `locals` para ele.

#### Markaby Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="http://markaby.github.com/" title="Markaby">Markaby</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.mab</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>markaby { h1 "Welcome!" }</tt></td>
  </tr>
</table>

Este também recebe um bloco para templates (veja o exemplo).

#### RABL Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="https://github.com/nesquena/rabl" title="Rabl">Rabl</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.rabl</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>rabl :index</tt></td>
  </tr>
</table>

#### Slim Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="http://slim-lang.com/" title="Slim Lang">Slim Lang</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.slim</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>slim :index</tt></td>
  </tr>
</table>

#### Creole Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="https://github.com/minad/creole" title="Creole">Creole</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.creole</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>creole :wiki, :layout_engine => :erb</tt></td>
  </tr>
</table>

Não é possível chamar métodos por este template, nem passar *locals* para o mesmo. Portanto normalmente é utilizado junto a outra engine de renderização:

``` ruby
erb :overview, :locals => { :text => creole(:introduction) }
```

Note que vcoê também pode chamar o método `creole` dentro de outros templates:

``` ruby
%h1 Olá do Haml!
%p= creole(:saudacoes)
```

Já que você não pode chamar o Ruby pelo Creole, você não
pode utilizar um layout escrito em Creole. Contudo é
possível utilizar outra engine de renderização como template, 
deve-se passar a `:layout_engine` como opção.

#### MediaWiki Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="https://github.com/nricciar/wikicloth" title="WikiCloth">WikiCloth</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.mediawiki</tt> and <tt>.mw</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>mediawiki :wiki, :layout_engine => :erb</tt></td>
  </tr>
</table>

It is not possible to call methods from MediaWiki markup, nor to pass locals to
it. You therefore will usually use it in combination with another rendering
engine:

``` ruby
erb :overview, :locals => { :text => mediawiki(:introduction) }
```

Note that you may also call the `mediawiki` method from within other templates:

``` ruby
%h1 Hello From Haml!
%p= mediawiki(:greetings)
```

Já que você não pode chamar o Ruby pelo MediaWiki, você não
pode utilizar um layout escrito em MediaWiki. Contudo é
possível utilizar outra engine de renderização como template, 
deve-se passar a `:layout_engine` como opção.

#### CoffeeScript Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td>
      <a href="https://github.com/josh/ruby-coffee-script" title="Ruby CoffeeScript">
        CoffeeScript
      </a> and a
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        way to execute javascript
      </a>
    </td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.coffee</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>coffee :index</tt></td>
  </tr>
</table>

#### Stylus Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td>
      <a href="https://github.com/lucasmazza/ruby-stylus" title="Ruby Stylus">
        Stylus
      </a> and a
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        way to execute javascript
      </a>
    </td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.styl</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>stylus :index</tt></td>
  </tr>
</table>

Antes que vcoê possa utilizar o template Stylus primeiro você deve carregar `stylus` e `stylus/tilt`:

``` ruby
require 'sinatra'
require 'stylus'
require 'stylus/tilt'

get '/' do
  stylus :exemplo
end
```

#### Yajl Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="https://github.com/brianmario/yajl-ruby" title="yajl-ruby">yajl-ruby</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.yajl</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td>
      <tt>
        yajl :index,
             :locals => { :key => 'qux' },
             :callback => 'present',
             :variable => 'resource'
      </tt>
    </td>
  </tr>
</table>

O código-fonte do template é executado como uma string Ruby e a variável resultante em json é convertida utilizando `#to_json`:

``` ruby
json = { :foo => 'bar' }
json[:baz] = key
```

O `:callback` e `:variable` são opções que podem ser utilizadas para o objeto de renderização:

``` javascript
var resource = {"foo":"bar","baz":"qux"};
present(resource);
```

#### WLang Templates

<table>
  <tr>
    <td>Dependencia</td>
    <td><a href="https://github.com/blambeau/wlang/" title="WLang">WLang</a></td>
  </tr>
  <tr>
    <td>Extencao do Arquivo</td>
    <td><tt>.wlang</tt></td>
  </tr>
  <tr>
    <td>Exemplo</td>
    <td><tt>wlang :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

Já que você não pode chamar o Ruby (exceto pelo método
`yield`) pelo template WLang,
você quase sempre precisará passar o `locals` para ele.

## Acessando Variáveis nos Templates

Templates são avaliados dentro do mesmo contexto como manipuladores de
rota. Variáveis de instância setadas em rotas manipuladas são
diretamente acessadas por templates:

``` ruby
get '/:id' do
  @foo = Foo.find(params['id'])
  haml '%h1= @foo.nome'
end
```

Ou, especifique um hash explícito para variáveis locais:

``` ruby
get '/:id' do
  foo = Foo.find(params['id'])
  haml '%h1= foo.nome', :locals => { :foo => foo }
end
```

Isso é tipicamente utilizando quando renderizamos templates como
partials dentro de outros templates.

### Templates com `yield` e layouts aninhados

O layout geralmente é apenas um template que executa `yield`. 
Tal template pode ser utilizado pela opção `:template` descrita acima ou pode ser renderizado através de um bloco, como a seguir:

``` ruby
erb :post, :layout => false do
  erb :index
end
```

Este código é quase equivalente a `erb :index, :layout => :post`

Passando blocos para os métodos de renderização é útil para criar layouts aninhados:

``` ruby
erb :main_layout, :layout => false do
  erb :admin_layout do
    erb :user
  end
end
```

Também pode ser feito com menos linhas de código:

``` ruby
erb :admin_layout, :layout => :main_layout do
  erb :user
end
```

Atualmente os métodos listados aceitam blocos: `erb`, `haml`,
`liquid`, `slim `, `wlang`. E também o método `render`.

### Templates Inline

Templates podem ser definidos no final do arquivo fonte(.rb):

``` ruby
require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.title Olá Mundo.
```

NOTA: Templates inline definidos no arquivo fonte são automaticamente
carregados pelo sinatra. Digite \`enable :inline\_templates\` se você
tem templates inline no outro arquivo fonte.

### Templates nomeados

Templates também podem ser definidos utilizando o método top-level
`template`:

``` ruby
template :layout do
  "%html\n  =yield\n"
end

template :index do
  '%div.title Olá Mundo!'
end

get '/' do
  haml :index
end
```

Se existir um template com nome “layout”, ele será utilizado toda vez
que um template for renderizado. Você pode desabilitar layouts passando
`:layout => false`.

``` ruby
get '/' do
  haml :index, :layout => !request.xhr?
end
```

### Associando extensões de arquivos

Para associar uma extensão de arquivo com um engine de template use o método `Tilt.register`. Por exemplo, se você quiser usar a extensão `tt` para os templates Textile você pode fazer o seguinte:

``` ruby
Tilt.register :tt, Tilt[:textile]
```

### Adicionando seu Próprio Engine de Template

Primeiro registre seu engine utilizando o Tilt, e então crie um método de renderização:

``` ruby
Tilt.register :myat, MyAwesomeTemplateEngine

helpers do
  def myat(*args) render(:myat, *args) end
end

get '/' do
  myat :index
end
```

Renderize `./views/index.myat`. Veja
https://github.com/rtomayko/tilt para saber mais sobre Tilt.

### Customizando lógica para encontrar templates

Para implementar sua própria lógica para busca de templates você pode escrever seu próprio método `#find_template`

``` ruby
configure do
  set :views [ './views/a', './views/b' ]
end

def find_template(views, name, engine, &block)
  Array(views).each do |v|
    super(v, name, engine, &block)
  end
end
```

## Filtros

Filtros Before são avaliados antes de cada requisição dentro do contexto
da requisição e podem modificar a requisição e a reposta. Variáveis de
instância setadas nos filtros são acessadas através de rotas e
templates:

``` ruby
before do
  @nota = 'Oi!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @nota #=> 'Oi!'
  params['splat'] #=> 'bar/baz'
end
```

Filtros After são avaliados após cada requisição dentro do contexto da
requisição e também podem modificar a requisição e a resposta. Variáveis de
instância e rotas definidas nos filtros before são acessadas através dos
filtros after:

``` ruby
after do
  puts response.status
end
```

Filtros opcionalmente têm um padrão, fazendo com que sejam avaliados
somente se o caminho do pedido coincidir com esse padrão:

``` ruby
before '/protected/*' do
  authenticate!
end

after '/create/:slug' do |slug|
  session[:last_slug] = slug
end
```

## Helpers

Use o método de alto nível `helpers` para definir métodos auxiliares
para utilizar em manipuladores de rotas e modelos:

``` ruby
helpers do
  def bar(nome)
    "#{nome}bar"
  end
end

get '/:nome' do
  bar(params['nome'])
end
```

### Utilizando Sessões

Sessões são usadas para manter um estado durante uma requisição. Se ativa, você terá disponível um hash de sessão para cada sessão de usuário:

``` ruby
enable :sessions

get '/' do
  "value = " << session[:value].inspect
end

get '/:value' do
  session['value'] = params['value']
end
```

Note que `enable :sessions` utilizará um cookie para guardar todos os dados da sessão. Isso nem sempre pode ser o que você quer (guardar muitos dados irá aumentar o seu tráfego, por exemplo). Você pode utilizar qualquer Rack middleware de sessão: para fazer isso **não** utilize o método `enable :sessions`, ao invés disso utilize seu middleware de sessão como utilizaria qualquer outro:

``` ruby
use Rack::Session::Pool, :expire_after => 2592000

get '/' do
  "value = " << session[:value].inspect
end

get '/:value' do
  session['value'] = params['value']
end
```

Para melhorar a segurança, os dados da sessão guardados no cookie é assinado com uma chave secreta da sessão. Uma chave aleatória é gerada para você pelo Sinatra. Contudo, já que a chave mudará cada vez que você inicia sua aplicação, você talvez queira defini-la você mesmo para que todas as instâncias da aplicação compartilhe-a:

``` ruby
set :session_secret, 'super secret'
```

Se você quiser fazer outras configurações, você também pode guardar um hash com as opções nas configurações da `session`:

``` ruby
set :sessions, :domain => 'foo.com'
```

Para compartilhar sua sessão entre outros aplicativos em um subdomínio de foo.com, utilize o prefixo *.*:

``` ruby
set :sessions, :domain => '.foo.com'
```

### Halting

Para parar imediatamente uma requisição com um filtro ou rota utilize:

``` ruby
halt
```

Você também pode especificar o status quando parar…

``` ruby
halt 410
```

Ou com corpo de texto…

``` ruby
halt 'isso será o corpo do texto'
```

Ou também…

``` ruby
halt 401, 'vamos embora!'
```

Com cabeçalhos…

``` ruby
halt 402, {'Content-Type' => 'text/plain'}, 'revanche'
```

É obviamente possivel combinar um template com o `halt`:

``` ruby
halt erb(:error)
```

### Passing

Uma rota pode processar aposta para a próxima rota correspondente usando
`pass`:

``` ruby
get '/adivinhar/:quem' do
  pass unless params['quem'] == 'Frank'
  'Você me pegou!'
end

get '/adivinhar/*' do
  'Você falhou!'
end
```

O bloqueio da rota é imediatamente encerrado e o controle continua com a
próxima rota de parâmetro. Se o parâmetro da rota não for encontrado, um
404 é retornado.

### Desencadeando Outra Rota

As vezes o `pass` não é o que você quer, ao invés dele talvez você queira obter o resultado chamando outra rota. Utilize o método `call` neste caso:

``` ruby
get '/foo' do
  status, headers, body = call env.merge("PATH_INFO" => '/bar')
  [status, headers, body.map(&:upcase)]
end

get '/bar' do
  "bar"
end
```

Note que no exemplo acima você ganharia performance ao simplemente mover o `"bar"` em um helper usado por ambos `/foo` e `/bar`.

Se você quer que a requisição seja enviada para a mesma instancia da aplicação ao invês de uma duplicada, use `call!` no lugar de `call`.

Veja a especificação do Rack se você quer aprender mais sobre o `call`.

## Configuração

Rodando uma vez, na inicialização, em qualquer ambiente:

``` ruby
configure do
  ...
end
```

Rodando somente quando o ambiente (`RACK_ENV` environment variável) é
setado para `:production`:

``` ruby
configure :production do
  ...
end
```

Rodando quando o ambiente é setado para `:production` ou `:test`:

``` ruby
configure :production, :test do
  ...
end
```

## Tratamento de Erros

Tratamento de erros rodam dentro do mesmo contexto como rotas e filtros
before, o que significa que você pega todos os presentes que tem para
oferecer, como `haml`, `erb`, `halt`, etc.

### Não Encontrado

Quando um `Sinatra::NotFound` exception é levantado, ou o código de
status da reposta é 404, o manipulador `not_found` é invocado:

``` ruby
not_found do
  'Isto está longe de ser encontrado'
end
```

### Erro

O manipulador `error` é invocado toda a vez que uma exceção é lançada a
partir de um bloco de rota ou um filtro. O objeto da exceção pode ser
obtido a partir da variável Rack `sinatra.error`:

``` ruby
error do
  'Desculpe, houve um erro desagradável - ' + env['sinatra.error'].message
end
```

Erros customizados:

``` ruby
error MeuErroCustomizado do
  'Então que aconteceu foi...' + env['sinatra.error'].message
end
```

Então, se isso acontecer:

``` ruby
get '/' do
  raise MeuErroCustomizado, 'alguma coisa ruim'
end
```

Você receberá isso:

    Então que aconteceu foi... alguma coisa ruim

Alternativamente, você pode instalar manipulador de erro para um código
de status:

``` ruby
error 403 do
  'Accesso negado'
end

get '/secreto' do
  403
end
```

Ou um range:

``` ruby
error 400..510 do
  'Boom'
end
```

O Sinatra instala os manipuladores especiais `not_found` e `error`
quando roda sobre o ambiente de desenvolvimento.

## Mime Types

Quando utilizamos `send_file` ou arquivos estáticos você pode ter mime
types Sinatra não entendidos. Use `mime_type` para registrar eles por
extensão de arquivos:

``` ruby
mime_type :foo, 'text/foo'
```

Você também pode utilizar isto com o helper `content_type`:

``` ruby
content_type :foo
```

## Rack Middleware

O Sinatra roda no [Rack](http://rack.github.io/), uma interface
padrão mínima para frameworks web em Ruby. Um das capacidades mais
interessantes do Rack para desenvolver aplicativos é suporte a
“middleware” – componentes que ficam entre o servidor e sua aplicação
monitorando e/ou manipulando o request/response do HTTP para prover
vários tipos de funcionalidades comuns.

O Sinatra faz construtores pipelines do middleware Rack facilmente em um
nível superior utilizando o método `use`:

``` ruby
require 'sinatra'
require 'meu_middleware_customizado'

use Rack::Lint
use MeuMiddlewareCustomizado

get '/ola' do
  'Olá mundo'
end
```

A semântica de `use` é idêntica aquela definida para a DSL
[Rack::Builder](http://rubydoc.info/github/rack/rack/master/Rack/Builder)
(mais frequentemente utilizada para arquivos rackup). Por exemplo, o
método `use` aceita múltiplos argumentos/variáveis bem como blocos:

``` ruby
use Rack::Auth::Basic do |usuario, senha|
  usuario == 'admin' && senha == 'secreto'
end
```

O Rack é distribuido com uma variedade de middleware padrões para logs,
debugs, rotas de URL, autenticação, e manipuladores de sessão. Sinatra
utilizada muitos desses componentes automaticamente baseando sobre
configuração, então, tipicamente você não tem `use` explicitamente.

## Testando

Testes no Sinatra podem ser escritos utilizando qualquer biblioteca ou
framework de teste baseados no Rack.
[Rack::Test](http://gitrdoc.com/brynary/rack-test) é recomendado:

``` ruby
require 'minha_aplicacao_sinatra'
require 'rack/test'

class MinhaAplicacaoTeste < Minitest::Test
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def meu_test_default
    get '/'
    assert_equal 'Ola Mundo!', last_response.body
  end

  def teste_com_parametros
    get '/atender', :name => 'Frank'
    assert_equal 'Olá Frank!', last_response.bodymeet
  end

  def test_com_ambiente_rack
    get '/', {}, 'HTTP_USER_AGENT' => 'Songbird'
    assert_equal "Você está utilizando o Songbird!", last_response.body
  end
end
```

NOTA: Os módulos de classe embutidos `Sinatra::Test` e
`Sinatra::TestHarness` são depreciados na versão 0.9.2.

## Sinatra::Base - Middleware, Bibliotecas e aplicativos modulares

Definir sua aplicação em um nível superior de trabalho funciona bem para
micro aplicativos, mas tem consideráveis incovenientes na construção de
componentes reutilizáveis como um middleware Rack, metal Rails,
bibliotecas simples como um componente de servidor, ou mesmo extensões
Sinatra. A DSL de nível superior polui o espaço do objeto e assume um
estilo de configuração de micro aplicativos (exemplo: uma simples
arquivo de aplicação, diretórios `./public` e `./views`, logs, página de
detalhes de exceção, etc.). É onde o `Sinatra::Base` entra em jogo:

``` ruby
require 'sinatra/base'

class MinhaApp < Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Ola mundo!'
  end
end
```

A classe `MinhaApp` é um componente Rack independente que pode agir como
um middleware Rack, uma aplicação Rack, ou metal Rails. Você pode
utilizar ou executar esta classe com um arquivo rackup `config.ru`;
ou, controlar um componente de servidor fornecendo como biblioteca:

``` ruby
MinhaApp.run! :host => 'localhost', :port => 9090
```

Os métodos disponíveis para subclasses `Sinatra::Base` são exatamente como
aqueles disponíveis via a DSL de nível superior. Aplicações de nível
mais alto podem ser convertidas para componentes `Sinatra::Base` com duas
modificações:

-   Seu arquivo deve requerer `sinatra/base` ao invés de `sinatra`;
    outra coisa, todos os métodos DSL do Sinatra são importados para o
    espaço principal.

-   Coloque as rotas da sua aplicação, manipuladores de erro, filtros e
    opções na subclasse de um `Sinatra::Base`.

`Sinatra::Base` é um quadro branco. Muitas opções são desabilitadas por
padrão, incluindo o servidor embutido. Veja [Opções e
Configurações](http://sinatra.github.com/configuration.html) para
detalhes de opções disponíveis e seus comportamentos.

SIDEBAR: A DSL de alto nível do Sinatra é implementada utilizando um simples
sistema de delegação. A classe `Sinatra::Application` – uma subclasse especial
da `Sinatra::Base` – recebe todos os `:get`, `:put`, `:post`, `:delete`,
`:before`, `:error`, `:not_found`, `:configure`, e `:set messages` enviados
para o alto nível. Dê uma olhada no código você mesmo: aqui está o
[Sinatra::Delegator
mixin](http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/base.rb#L1128)
sendo [incluido dentro de um espaço
principal](http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/main.rb#L28)

## Linha de Comando

Aplicações Sinatra podem ser executadas diretamente:

``` shell
ruby minhaapp.rb [-h] [-x] [-e AMBIENTE] [-p PORTA] [-o HOST] [-s SERVIDOR]
```

As opções são:

```
-h # ajuda
-p # define a porta (padrão é 4567)
-o # define o host (padrão é 0.0.0.0)
-e # define o ambiente (padrão é development)
-s # especifica o servidor/manipulador rack (padrão é thin)
-x # ativa o bloqueio (padrão é desligado)
```

## A última versão

Se você gostaria de utilizar o código da última versão do Sinatra, crie
um clone local e execute sua aplicação com o diretório `sinatra/lib` no
`LOAD_PATH`:

``` shell
cd minhaapp
git clone git://github.com/sinatra/sinatra.git
ruby -I sinatra/lib minhaapp.rb
```

Alternativamente, você pode adicionar o diretório do `sinatra/lib` no
`LOAD_PATH` do seu aplicativo:

``` ruby
$LOAD_PATH.unshift File.dirname(__FILE__) + '/sinatra/lib'
require 'rubygems'
require 'sinatra'

get '/sobre' do
  "Estou rodando a versão" + Sinatra::VERSION
end
```

Para atualizar o código do Sinatra no futuro:

``` shell
cd meuprojeto/sinatra
git pull
```

## Mais

* [Website do Projeto](http://www.sinatrarb.com/) - Documentação
    adicional, novidades e links para outros recursos.
* [Contribuir](http://www.sinatrarb.com/contributing) - Encontrar um
    bug? Precisa de ajuda? Tem um patch?
* [Acompanhar Questões](http://github.com/sinatra/sinatra/issues)
* [Twitter](http://twitter.com/sinatra)
* [Lista de Email](http://groups.google.com/group/sinatrarb/topics)
* [Sinatra Book](https://github.com/sinatra/sinatra-book/) Livro de Receitas
* Documentação da API para a [última release](http://rubydoc.info/gems/sinatra)
* [IRC: \#sinatra](irc://chat.freenode.net/#sinatra) em
    [freenode.net](http://freenode.net)
* [Servidor de CI](http://travis-ci.org/sinatra/sinatra)
# Sinatra

*注：本文档是英文版的翻译，内容更新有可能不及时。
如有不一致的地方，请以英文版为准。*

Sinatra是一个基于Ruby语言的[DSL](http://en.wikipedia.org/wiki/Domain-specific_language)（
领域专属语言），可以轻松、快速的创建web应用。

~~~~ ruby
# myapp.rb
require 'sinatra'

get '/' do
  'Hello world!'
end
~~~~

安装gem，然后运行：

~~~~ shell
gem install sinatra
ruby myapp.rb
~~~~

在该地址查看： http://localhost:4567

这个时候访问地址将绑定到 127.0.0.1 和 localhost ，如果使用 vagrant 进行开发，访问会失败，此时就需要进行 ip 绑定了：

~~~~ shell
ruby myapp.rb -o 0.0.0.0
~~~~

```-o``` 这个参数就是进行 Listening 时候监听的绑定，能从通过 IP、127.0.0.1、localhost + 端口号进行访问。

安装Sintra后，最好再运行`gem install thin`安装Thin。这样，Sinatra会优先选择Thin作为服务器。

## 路由(route)

在Sinatra中，一个路由分为两部分：HTTP方法(GET, POST等)和URL匹配范式。
每个路由都有一个要执行的代码块：

~~~~ ruby
get '/' do
  .. 显示内容 ..
end

post '/' do
  .. 创建内容 ..
end

put '/' do
  .. 更新内容 ..
end

delete '/' do
  .. 删除内容 ..
end

options '/' do
  .. 显示命令列表 ..
end

link '/' do
  .. 建立某种联系 ..
end

unlink '/' do
  .. 解除某种联系 ..
end


~~~~

路由按照它们被定义的顺序进行匹配。 第一个与请求匹配的路由会被调用。

路由范式可以包括具名参数，可通过`params`哈希表获得：

~~~~ ruby
get '/hello/:name' do
  # 匹配 "GET /hello/foo" 和 "GET /hello/bar"
  # params['name'] 的值是 'foo' 或者 'bar'
  "Hello #{params['name']}!"
end
~~~~

你同样可以通过代码块参数获得具名参数：

~~~~ ruby
get '/hello/:name' do |n|
  "Hello #{n}!"
end
~~~~

路由范式也可以包含通配符参数， 可以通过`params['splat']`数组获得。

~~~~ ruby
get '/say/*/to/*' do
  # 匹配 /say/hello/to/world
  params['splat'] # => ["hello", "world"]
end

get '/download/*.*' do
  # 匹配 /download/path/to/file.xml
  params['splat'] # => ["path/to/file", "xml"]
end
~~~~

通过正则表达式匹配的路由：

~~~~ ruby
get /\A\/hello\/([\w]+)\z/ do
  "Hello, #{params['captures'].first}!"
end
~~~~

或者使用代码块参数：

~~~~ ruby
get %r{/hello/([\w]+)} do |c|
  "Hello, #{c}!"
end
~~~~

### 条件

路由也可以包含多样的匹配条件，比如user agent：

~~~~ ruby
get '/foo', :agent => /Songbird (\d\.\d)[\d\/]*?/ do
  "你正在使用Songbird，版本是 #{params['agent'][0]}"
end

get '/foo' do
  # 匹配除Songbird以外的浏览器
end
~~~~

其他可选的条件是 `host_name` 和 `provides`：

~~~~ ruby
get '/', :host_name => /^admin\./ do
  "管理员区域，无权进入！"
end

get '/', :provides => 'html' do
  haml :index
end

get '/', :provides => ['rss', 'atom', 'xml'] do
  builder :feed
end
~~~~

你也可以自定义条件：

~~~~ ruby
set(:probability) { |value| condition { rand <= value } }

get '/win_a_car', :probability => 0.1 do
  "You won!"
end

get '/win_a_car' do
  "Sorry, you lost."
end
~~~~

### 返回值

路由代码块的返回值至少决定了返回给HTTP客户端的响应体，
或者至少决定了在Rack堆栈中的下一个中间件。
大多数情况下，将是一个字符串，就像上面的例子中的一样。
但是其他值也是可以接受的。

你可以返回任何对象，或者是一个合理的Rack响应， Rack
body对象或者HTTP状态码：

-   一个包含三个元素的数组:
    `[状态 (Fixnum), 头 (Hash), 响应体 (回应 #each)]`

-   一个包含两个元素的数组: `[状态 (Fixnum), 响应体 (回应 #each)]`

-   一个能够回应 `#each` ，只传回字符串的对象

-   一个代表状态码的数字

那样，我们可以轻松的实现例如流式传输的例子：

~~~~ ruby
class Stream
  def each
    100.times { |i| yield "#{i}\n" }
  end
end

get('/') { Stream.new }
~~~~

### 自定义路由匹配器

如上显示，Sinatra内置了对于使用字符串和正则表达式作为路由匹配的支持。
但是，它并没有只限于此。 你可以非常容易地定义你自己的匹配器:

~~~~ ruby
class AllButPattern
  Match = Struct.new(:captures)

  def initialize(except)
    @except   = except
    @captures = Match.new([])
  end

  def match(str)
    @captures unless @except === str
  end
end

def all_but(pattern)
  AllButPattern.new(pattern)
end

get all_but("/index") do
  # ...
end
~~~~

上面的例子可能太繁琐了， 因为它也可以用更简单的方式表述:

~~~~ ruby
get // do
  pass if request.path_info == "/index"
  # ...
end
~~~~

或者，使用消极向前查找:

~~~~ ruby
get %r{^(?!/index$)} do
  # ...
end
~~~~

## 静态文件

静态文件是从 `./public_folder` 目录提供服务。你可以通过设置`:public`
选项设定一个不同的位置：

~~~~ ruby
set :public_folder, File.dirname(__FILE__) + '/static'
~~~~

请注意public目录名并没有被包含在URL之中。文件
`./public/css/style.css`是通过
`http://example.com/css/style.css`地址访问的。

## 视图 / 模板

模板被假定直接位于`./views`目录。 要使用不同的视图目录：

~~~~ ruby
set :views, File.dirname(__FILE__) + '/templates'
~~~~

重要提示：你只可以通过符号引用模板， 即使它们在子目录下
（在这种情况下，使用 `:'subdir/template'`）。 如果你不用符号、而用字符串的话，
填充方法会只把你传入的字符串当成内容显示出来，而不调用模板。

### Haml模板

需要引入 `haml` gem/library以填充 HAML 模板：

~~~~ ruby
# 你需要在你的应用中引入 haml
require 'haml'

get '/' do
  haml :index
end
~~~~

填充 `./views/index.haml`。

[Haml的选项](http://haml.info/docs/yardoc/file.HAML_REFERENCE.html#options)
可以通过Sinatra的配置全局设定， 参见
[选项和配置](http://www.sinatrarb.com/configuration.html)，
也可以个别的被覆盖。

~~~~ ruby
set :haml, {:format => :html5 } # 默认的Haml输出格式是 :xhtml

get '/' do
  haml :index, :haml_options => {:format => :html4 } # 被覆盖，变成:html4
end
~~~~

### Erb模板

~~~~ ruby
# 你需要在你的应用中引入 erb
require 'erb'

get '/' do
  erb :index
end
~~~~

这里调用的是 `./views/index.erb`

### Erubis

需要引入 `erubis` gem/library以填充 erubis 模板：

~~~~ ruby
# 你需要在你的应用中引入 erubis
require 'erubis'

get '/' do
  erubis :index
end
~~~~

这里调用的是 `./views/index.erubis`

使用Erubis代替Erb也是可能的:

~~~~ ruby
require 'erubis'
Tilt.register :erb, Tilt[:erubis]

get '/' do
  erb :index
end
~~~~

使用Erubis来填充 `./views/index.erb`。

### Builder 模板

需要引入 `builder` gem/library 以填充 builder templates：

~~~~ ruby
# 需要在你的应用中引入builder
require 'builder'

get '/' do
  builder :index
end
~~~~

这里调用的是 `./views/index.builder`。

### Nokogiri 模板

需要引入 `nokogiri` gem/library 以填充 nokogiri 模板：

~~~~ ruby
# 需要在你的应用中引入 nokogiri
require 'nokogiri'

get '/' do
  nokogiri :index
end
~~~~

这里调用的是 `./views/index.nokogiri`。

### Sass 模板

需要引入 `haml` 或者 `sass` gem/library 以填充 Sass 模板：

~~~~ ruby
# 需要在你的应用中引入 haml 或者 sass
require 'sass'

get '/stylesheet.css' do
  sass :stylesheet
end
~~~~

这里调用的是 `./views/stylesheet.sass`。

[Sass
的选项](http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options)
可以通过Sinatra选项全局设定， 参考
[选项和配置（英文）](http://www.sinatrarb.com/configuration.html),
也可以在个体的基础上覆盖。

~~~~ ruby
set :sass, {:style => :compact } # 默认的 Sass 样式是 :nested

get '/stylesheet.css' do
  sass :stylesheet, :style => :expanded # 覆盖
end
~~~~

### Scss 模板

需要引入 `haml` 或者 `sass` gem/library 来填充 Scss templates：

~~~~ ruby
# 需要在你的应用中引入 haml 或者 sass
require 'sass'

get '/stylesheet.css' do
  scss :stylesheet
end
~~~~

这里调用的是 `./views/stylesheet.scss`。

[Scss的选项](http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options)
可以通过Sinatra选项全局设定， 参考
[选项和配置（英文）](http://www.sinatrarb.com/configuration.html),
也可以在个体的基础上覆盖。

~~~~ ruby
set :scss, :style => :compact # default Scss style is :nested

get '/stylesheet.css' do
  scss :stylesheet, :style => :expanded # overridden
end
~~~~

### Less 模板

需要引入 `less` gem/library 以填充 Less 模板：

~~~~ ruby
# 需要在你的应用中引入 less
require 'less'

get '/stylesheet.css' do
  less :stylesheet
end
~~~~

这里调用的是 `./views/stylesheet.less`。

### Liquid 模板

需要引入 `liquid` gem/library 来填充 Liquid 模板：

~~~~ ruby
# 需要在你的应用中引入 liquid
require 'liquid'

get '/' do
  liquid :index
end
~~~~

这里调用的是 `./views/index.liquid`。

因为你不能在Liquid 模板中调用 Ruby 方法 (除了 `yield`) ，
你几乎总是需要传递locals给它：

~~~~ ruby
liquid :index, :locals => { :key => 'value' }
~~~~

### Markdown 模板

需要引入 `rdiscount` gem/library 以填充 Markdown 模板：

~~~~ ruby
# 需要在你的应用中引入rdiscount
require "rdiscount"

get '/' do
  markdown :index
end
~~~~

这里调用的是 `./views/index.markdown` (`md` 和 `mkd` 也是合理的文件扩展名)。

在markdown中是不可以调用方法的，也不可以传递 locals给它。
你因此一般会结合其他的填充引擎来使用它：

~~~~ ruby
erb :overview, :locals => { :text => markdown(:introduction) }
~~~~

请注意你也可以从其他模板中调用 markdown 方法：

~~~~ ruby
%h1 Hello From Haml!
%p= markdown(:greetings)
~~~~

既然你不能在Markdown中调用Ruby，你不能使用Markdown编写的布局。
不过，使用其他填充引擎作为模版的布局是可能的，
通过传递`:layout_engine`选项:

~~~~ ruby
get '/' do
  markdown :index, :layout_engine => :erb
end
~~~~

这将会调用 `./views/index.md` 并使用 `./views/layout.erb` 作为布局。

请记住你可以全局设定这个选项:

~~~~ ruby
set :markdown, :layout_engine => :haml, :layout => :post

get '/' do
  markdown :index
end
~~~~

这将会调用 `./views/index.markdown` (和任何其他的 Markdown 模版) 并使用
`./views/post.haml` 作为布局.

也可能使用BlueCloth而不是RDiscount来解析Markdown文件:

~~~~ ruby
require 'bluecloth'

Tilt.register 'markdown', BlueClothTemplate
Tilt.register 'mkd',      BlueClothTemplate
Tilt.register 'md',       BlueClothTemplate

get '/' do
  markdown :index
end
~~~~

使用BlueCloth来填充 `./views/index.md` 。

### Textile 模板

需要引入 `RedCloth` gem/library 以填充 Textile 模板：

~~~~ ruby
# 在你的应用中引入redcloth
require "redcloth"

get '/' do
  textile :index
end
~~~~

这里调用的是 `./views/index.textile`。

在textile中是不可以调用方法的，也不可以传递 locals给它。
你因此一般会结合其他的填充引擎来使用它：

~~~~ ruby
erb :overview, :locals => { :text => textile(:introduction) }
~~~~

请注意你也可以从其他模板中调用`textile`方法：

~~~~ ruby
%h1 Hello From Haml!
%p= textile(:greetings)
~~~~

既然你不能在Textile中调用Ruby，你不能使用Textile编写的布局。
不过，使用其他填充引擎作为模版的布局是可能的，
通过传递`:layout_engine`选项:

~~~~ ruby
get '/' do
  textile :index, :layout_engine => :erb
end
~~~~

这将会填充 `./views/index.textile` 并使用 `./views/layout.erb`
作为布局。

请记住你可以全局设定这个选项:

~~~~ ruby
set :textile, :layout_engine => :haml, :layout => :post

get '/' do
  textile :index
end
~~~~

这将会调用 `./views/index.textile` (和任何其他的 Textile 模版) 并使用
`./views/post.haml` 作为布局.

### RDoc 模板

需要引入 `RDoc` gem/library 以填充RDoc模板：

~~~~ ruby
# 需要在你的应用中引入rdoc/markup/to_html
require "rdoc"
require "rdoc/markup/to_html"

get '/' do
  rdoc :index
end
~~~~

这里调用的是 `./views/index.rdoc`。

在rdoc中是不可以调用方法的，也不可以传递locals给它。
你因此一般会结合其他的填充引擎来使用它：

~~~~ ruby
erb :overview, :locals => { :text => rdoc(:introduction) }
~~~~

请注意你也可以从其他模板中调用`rdoc`方法：

~~~~ ruby
%h1 Hello From Haml!
%p= rdoc(:greetings)
~~~~

既然你不能在RDoc中调用Ruby，你不能使用RDoc编写的布局。
不过，使用其他填充引擎作为模版的布局是可能的，
通过传递`:layout_engine`选项:

~~~~ ruby
get '/' do
  rdoc :index, :layout_engine => :erb
end
~~~~

这将会调用 `./views/index.rdoc` 并使用 `./views/layout.erb` 作为布局。

请记住你可以全局设定这个选项:

~~~~ ruby
set :rdoc, :layout_engine => :haml, :layout => :post

get '/' do
  rdoc :index
end
~~~~

这将会调用 `./views/index.rdoc` (和任何其他的 RDoc 模版) 并使用
`./views/post.haml` 作为布局.

### Radius 模板

需要引入 `radius` gem/library 以填充 Radius 模板：

~~~~ ruby
# 需要在你的应用中引入radius
require 'radius'

get '/' do
  radius :index
end
~~~~

这里调用的是 `./views/index.radius`。

因为你不能在Radius 模板中调用 Ruby 方法 (除了 `yield`) ，
你几乎总是需要传递locals给它：

~~~~ ruby
radius :index, :locals => { :key => 'value' }
~~~~

### Markaby 模板

需要引入`markaby` gem/library以填充Markaby模板：

~~~~ ruby
#需要在你的应用中引入 markaby
require 'markaby'

get '/' do
  markaby :index
end
~~~~

这里调用的是 `./views/index.mab`。

你也可以使用嵌入的 Markaby:

~~~~ ruby
get '/' do
  markaby { h1 "Welcome!" }
end
~~~~

### Slim 模板

需要引入 `slim` gem/library 来填充 Slim 模板：

~~~~ ruby
# 需要在你的应用中引入 slim
require 'slim'

get '/' do
  slim :index
end
~~~~

这里调用的是 `./views/index.slim`。

### Creole 模板

需要引入 `creole` gem/library 来填充 Creole 模板：

~~~~ ruby
# 需要在你的应用中引入 creole
require 'creole'

get '/' do
  creole :index
end
~~~~

这里调用的是 `./views/index.creole`。

### CoffeeScript 模板

需要引入 `coffee-script` gem/library 并至少满足下面条件一项
以执行Javascript:

-   `node` (来自 Node.js) 在你的路径中

-   你正在运行 OSX

-   `therubyracer` gem/library

请察看
[github.com/josh/ruby-coffee-script](http://github.com/josh/ruby-coffee-script)
获取更新的选项。

现在你可以调用 CoffeeScript 模版了:

~~~~ ruby
# 需要在你的应用中引入coffee-script
require 'coffee-script'

get '/application.js' do
  coffee :application
end
~~~~

这里调用的是 `./views/application.coffee`。

### 嵌入模板字符串

~~~~ ruby
get '/' do
  haml '%div.title Hello World'
end
~~~~

调用嵌入模板字符串。

### 在模板中访问变量

模板和路由执行器在同样的上下文求值。
在路由执行器中赋值的实例变量可以直接被模板访问。

~~~~ ruby
get '/:id' do
  @foo = Foo.find(params['id'])
  haml '%h1= @foo.name'
end
~~~~

或者，显式地指定一个本地变量的哈希：

~~~~ ruby
get '/:id' do
  foo = Foo.find(params['id'])
  haml '%h1= foo.name', :locals => { :foo => foo }
end
~~~~

典型的使用情况是在别的模板中按照局部模板的方式来填充。

### 内联模板

模板可以在源文件的末尾定义：

~~~~ ruby
require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.title Hello world!!!!!
~~~~

注意：引入sinatra的源文件中定义的内联模板才能被自动载入。
如果你在其他源文件中有内联模板，
需要显式执行调用`enable :inline_templates`。

### 具名模板

模板可以通过使用顶层 `template` 方法定义：

~~~~ ruby
template :layout do
  "%html\n  =yield\n"
end

template :index do
  '%div.title Hello World!'
end

get '/' do
  haml :index
end
~~~~

如果存在名为“layout”的模板，该模板会在每个模板填充的时候被使用。
你可以单独地通过传送 `:layout => false`来禁用，
或者通过`set :haml, :layout => false`来禁用他们。

~~~~ ruby
get '/' do
  haml :index, :layout => !request.xhr?
end
~~~~

### 关联文件扩展名

为了关联一个文件扩展名到一个模版引擎，使用
`Tilt.register`。比如，如果你喜欢使用 `tt`
作为Textile模版的扩展名，你可以这样做:

~~~~ ruby
Tilt.register :tt, Tilt[:textile]
~~~~

### 添加你自己的模版引擎

首先，通过Tilt注册你自己的引擎，然后创建一个填充方法:

~~~~ ruby
Tilt.register :myat, MyAwesomeTemplateEngine

helpers do
  def myat(*args) render(:myat, *args) end
end

get '/' do
  myat :index
end
~~~~

这里调用的是 `./views/index.myat`。察看
[github.com/rtomayko/tilt](https://github.com/rtomayko/tilt)
来更多了解Tilt.

## 过滤器

前置过滤器在每个请求前，在请求的上下文环境中被执行，
而且可以修改请求和响应。 在过滤器中设定的实例变量可以被路由和模板访问：

~~~~ ruby
before do
  @note = 'Hi!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @note #=> 'Hi!'
  params['splat'] #=> 'bar/baz'
end
~~~~

后置过滤器在每个请求之后，在请求的上下文环境中执行，
而且可以修改请求和响应。
在前置过滤器和路由中设定的实例变量可以被后置过滤器访问：

~~~~ ruby
after do
  puts response.status
end
~~~~

请注意：除非你显式使用 `body` 方法，而不是在路由中直接返回字符串，
消息体在后置过滤器是不可用的， 因为它在之后才会生成。

过滤器可以可选地带有范式， 只有请求路径满足该范式时才会执行：

~~~~ ruby
before '/protected/*' do
  authenticate!
end

after '/create/:slug' do |slug|
  session['last_slug'] = slug
end
~~~~

和路由一样，过滤器也可以带有条件:

~~~~ ruby
before :agent => /Songbird/ do
  # ...
end

after '/blog/*', :host_name => 'example.com' do
  # ...
end
~~~~

## 辅助方法

使用顶层的 `helpers` 方法来定义辅助方法， 以便在路由处理器和模板中使用：

~~~~ ruby
helpers do
  def bar(name)
    "#{name}bar"
  end
end

get '/:name' do
  bar(params['name'])
end
~~~~

### 使用 Sessions

Session被用来在请求之间保持状态。如果被激活，每一个用户会话
对应有一个session哈希:

~~~~ ruby
enable :sessions

get '/' do
  "value = " << session['value'].inspect
end

get '/:value' do
  session['value'] = params['value']
end
~~~~

请注意 `enable :sessions` 实际上保存所有的数据在一个cookie之中。
这可能不会总是做你想要的（比如，保存大量的数据会增加你的流量）。
你可以使用任何的Rack session中间件，为了这么做， \*不要\*调用
`enable :sessions`，而是 按照自己的需要引入你的中间件：

~~~~ ruby
use Rack::Session::Pool, :expire_after => 2592000

get '/' do
  "value = " << session['value'].inspect
end

get '/:value' do
  session['value'] = params['value']
end
~~~~

### 挂起

要想直接地停止请求，在过滤器或者路由中使用：

~~~~ ruby
halt
~~~~

你也可以指定挂起时的状态码：

~~~~ ruby
halt 410
~~~~

或者消息体：

~~~~ ruby
halt 'this will be the body'
~~~~

或者两者;

~~~~ ruby
halt 401, 'go away!'
~~~~

也可以带消息头：

~~~~ ruby
halt 402, {'Content-Type' => 'text/plain'}, 'revenge'
~~~~

### 让路

一个路由可以放弃处理，将处理让给下一个匹配的路由，使用 `pass`：

~~~~ ruby
get '/guess/:who' do
  pass unless params['who'] == 'Frank'
  'You got me!'
end

get '/guess/*' do
  'You missed!'
end
~~~~

路由代码块被直接退出，控制流继续前进到下一个匹配的路由。
如果没有匹配的路由，将返回404。

### 触发另一个路由

有些时候，`pass` 并不是你想要的，你希望得到的是另一个路由的结果
。简单的使用 `call` 可以做到这一点:

~~~~ ruby
get '/foo' do
  status, headers, body = call env.merge("PATH_INFO" => '/bar')
  [status, headers, body.map(&:upcase)]
end

get '/bar' do
  "bar"
end
~~~~

请注意在以上例子中，你可以更加简化测试并增加性能，只要简单的移动

    <tt>"bar"</tt>到一个被<tt>/foo</tt>

和 `/bar`同时使用的helper。

如果你希望请求被发送到同一个应用，而不是副本， 使用 `call!` 而不是
`call`.

如果想更多了解 `call`，请察看 Rack specification。

### 设定 消息体，状态码和消息头

通过路由代码块的返回值来设定状态码和消息体不仅是可能的，而且是推荐的。
但是，在某些场景中你可能想在作业流程中的特定点上设置消息体。 你可以通过
`body` 辅助方法这么做。 如果你这样做了，
你可以在那以后使用该方法获得消息体:

~~~~ ruby
get '/foo' do
  body "bar"
end

after do
  puts body
end
~~~~

也可以传一个代码块给 `body`，它将会被Rack处理器执行（
这将可以被用来实现streaming，参见“返回值”）。

和消息体类似，你也可以设定状态码和消息头:

~~~~ ruby
get '/foo' do
  status 418
  headers \
    "Allow"   => "BREW, POST, GET, PROPFIND, WHEN",
    "Refresh" => "Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt"
  body "I'm a tea pot!"
end
~~~~

如同 `body`, 不带参数的 `headers` 和 `status` 可以用来访问
他们你的当前值.

### 媒体(MIME)类型

使用 `send_file` 或者静态文件的时候，Sinatra可能不能识别你的媒体类型。
使用 `mime_type` 通过文件扩展名来注册它们：

~~~~ ruby
mime_type :foo, 'text/foo'
~~~~

你也可以使用 `content_type` 辅助方法：

~~~~ ruby
get '/' do
  content_type :foo
  "foo foo foo"
end
~~~~

### 生成 URL

为了生成URL，你需要使用 `url` 辅助方法， 例如，在Haml中:

~~~~ ruby
%a{:href => url('/foo')} foo
~~~~

如果使用反向代理和Rack路由，生成URL的时候会考虑这些因素。

这个方法还有一个别名 `to` (见下面的例子).

### 浏览器重定向

你可以通过 `redirect` 辅助方法触发浏览器重定向:

~~~~ ruby
get '/foo' do
  redirect to('/bar')
end
~~~~

其他参数的用法，与 `halt`相同:

~~~~ ruby
redirect to('/bar'), 303
redirect 'http://google.com', 'wrong place, buddy'
~~~~

用 `redirect back`可以把用户重定向到原始页面:

~~~~ ruby
get '/foo' do
  "<a href='/bar'>do something</a>"
end

get '/bar' do
  do_something
  redirect back
end
~~~~

如果想传递参数给redirect，可以用query string:

~~~~ ruby
redirect to('/bar?sum=42')
~~~~

或者用session:

~~~~ ruby
enable :sessions

get '/foo' do
  session['secret'] = 'foo'
  redirect to('/bar')
end

get '/bar' do
  session['secret']
end
~~~~

### 缓存控制

要使用HTTP缓存，必须正确地设定消息头。

你可以这样设定 Cache-Control 消息头:

~~~~ ruby
get '/' do
  cache_control :public
  "cache it!"
end
~~~~

核心提示: 在前置过滤器中设定缓存.

~~~~ ruby
before do
  cache_control :public, :must_revalidate, :max_age => 60
end
~~~~

如果你正在用 `expires` 辅助方法设定对应的消息头 `Cache-Control`
会自动设定：

~~~~ ruby
before do
  expires 500, :public, :must_revalidate
end
~~~~

为了合适地使用缓存，你应该考虑使用 `etag` 和 `last_modified`方法。
推荐在执行繁重任务\*之前\*使用这些helpers，这样一来，
如果客户端在缓存中已经有相关内容，就会立即得到显示。


~~~~ ruby
get '/article/:id' do
  @article = Article.find params['id']
  last_modified @article.updated_at
  etag @article.sha1
  erb :article
end
~~~~

使用 [weak
ETag](http://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation)
也是有可能的:

~~~~ ruby
etag @article.sha1, :weak
~~~~

这些辅助方法并不会为你做任何缓存，而是将必要的信息传送给你的缓存
如果你在寻找缓存的快速解决方案，试试
[rack-cache](https://github.com/rtomayko/rack-cache):

~~~~ ruby
require "rack/cache"
require "sinatra"

use Rack::Cache

get '/' do
  cache_control :public, :max_age => 36000
  sleep 5
  "hello"
end
~~~~

### 发送文件

为了发送文件，你可以使用 `send_file` 辅助方法:

~~~~ ruby
get '/' do
  send_file 'foo.png'
end
~~~~

也可以带一些选项:

~~~~ ruby
send_file 'foo.png', :type => :jpg
~~~~

可用的选项有:

<dl>
    <dt>filename</dt>
    <dd>响应中的文件名，默认是真实文件的名字。</dd>

    <dt>last_modified</dt>
    <dd>Last-Modified 消息头的值，默认是文件的mtime（修改时间）。</dd>

    <dt>type</dt>
    <dd>使用的内容类型，如果没有会从文件扩展名猜测。</dd>

    <dt>disposition</dt>
    <dd>
        用于 Content-Disposition，可能的包括： <tt>nil</tt> (默认), <tt>:attachment</tt> 和
        <tt>:inline</tt>
    </dd>

    <dt>length</dt>
    <dd>Content-Length 的值，默认是文件的大小。</dd>
</dl>

如果Rack处理器支持的话，Ruby进程也能使用除streaming以外的方法。
如果你使用这个辅助方法， Sinatra会自动处理range请求。

### 访问请求对象

传入的请求对象可以在请求层（过滤器，路由，错误处理） 通过 `request`
方法被访问：

~~~~ ruby
# 在 http://example.com/example 上运行的应用
get '/foo' do
  request.body              # 被客户端设定的请求体（见下）
  request.scheme            # "http"
  request.script_name       # "/example"
  request.path_info         # "/foo"
  request.port              # 80
  request.request_method    # "GET"
  request.query_string      # ""
  request.content_length    # request.body的长度
  request.media_type        # request.body的媒体类型
  request.host              # "example.com"
  request.get?              # true (其他动词也具有类似方法)
  request.form_data?        # false
  request["SOME_HEADER"]    # SOME_HEADER header的值
  request.referrer          # 客户端的referrer 或者 '/'
  request.user_agent        # user agent (被 :agent 条件使用)
  request.cookies           # 浏览器 cookies 哈希
  request.xhr?              # 这是否是ajax请求？
  request.url               # "http://example.com/example/foo"
  request.path              # "/example/foo"
  request.ip                # 客户端IP地址
  request.secure?           # false（如果是ssl则为true）
  request.forwarded?        # true （如果是运行在反向代理之后）
  request.env               # Rack中使用的未处理的env哈希
end
~~~~

一些选项，例如 `script_name` 或者 `path_info` 也是可写的：

~~~~ ruby
before { request.path_info = "/" }

get "/" do
  "all requests end up here"
end
~~~~

`request.body` 是一个IO或者StringIO对象：

~~~~ ruby
post "/api" do
  request.body.rewind  # 如果已经有人读了它
  data = JSON.parse request.body.read
  "Hello #{data['name']}!"
end
~~~~

### 附件

你可以使用 `attachment` 辅助方法来告诉浏览器响应
应当被写入磁盘而不是在浏览器中显示。

~~~~ ruby
get '/' do
  attachment
  "store it!"
end
~~~~

你也可以传递一个文件名:

~~~~ ruby
get '/' do
  attachment "info.txt"
  "store it!"
end
~~~~

### 查找模板文件

`find_template` 辅助方法被用于在填充时查找模板文件:

~~~~ ruby
find_template settings.views, 'foo', Tilt[:haml] do |file|
  puts "could be #{file}"
end
~~~~

这并不是很有用。但是在你需要重载这个方法
来实现你自己的查找机制的时候有用。 比如，如果你想支持多于一个视图目录:

~~~~ ruby
set :views, ['views', 'templates']

helpers do
  def find_template(views, name, engine, &block)
    Array(views).each { |v| super(v, name, engine, &block) }
  end
end
~~~~

另一个例子是为不同的引擎使用不同的目录:

~~~~ ruby
set :views, :sass => 'views/sass', :haml => 'templates', :default => 'views'

helpers do
  def find_template(views, name, engine, &block)
    _, folder = views.detect { |k,v| engine == Tilt[k] }
    folder ||= views[:default]
    super(folder, name, engine, &block)
  end
end
~~~~

你可以很容易地包装成一个扩展然后与他人分享！

请注意 `find_template` 并不会检查文件真的存在，
而是对任何可能的路径调用给入的代码块。这并不会带来性能问题， 因为
`render` 会在找到文件的时候马上使用 `break` 。
同样的，模板的路径（和内容）会在除development mode以外的场合
被缓存。你应该时刻提醒自己这一点， 如果你真的想写一个非常疯狂的方法。

## 配置

运行一次，在启动的时候，在任何环境下：

~~~~ ruby
configure do
  # setting one option
  set :option, 'value'

  # setting multiple options
  set :a => 1, :b => 2

  # same as `set :option, true`
  enable :option

  # same as `set :option, false`
  disable :option

  # you can also have dynamic settings with blocks
  set(:css_dir) { File.join(views, 'css') }
end
~~~~

只当环境 (RACK\_ENV environment 变量) 被设定为 `:production`的时候运行：

~~~~ ruby
configure :production do
  ...
end
~~~~

当环境被设定为 `:production` 或者 `:test`的时候运行：

~~~~ ruby
configure :production, :test do
  ...
end
~~~~

你可以使用 `settings` 获得这些配置:

~~~~ ruby
configure do
  set :foo, 'bar'
end

get '/' do
  settings.foo? # => true
  settings.foo  # => 'bar'
  ...
end
~~~~

### 可选的设置

<dl>
    <dt>absolute_redirects</dt>
    <dd>
        <p>
            如果被禁用，Sinatra会允许使用相对路径重定向， 但是，Sinatra就不再遵守
            RFC 2616标准 (HTTP 1.1), 该标准只允许绝对路径重定向。
        </p>

        <p>
            如果你的应用运行在一个未恰当设置的反向代理之后，
            你需要启用这个选项。注意 <tt>url</tt> 辅助方法 仍然会生成绝对 URL，除非你传入
            <tt>false</tt> 作为第二参数。
        </p>
        <p>
            默认禁用。
        </p>
    </dd>

    <dt>add_charset</dt>
    <dd>
        <p>
            设定 <tt>content_type</tt> 辅助方法会 自动加上字符集信息的多媒体类型。
        </p>

        <p>
            你应该添加而不是覆盖这个选项:
            <tt>settings.add_charset << "application/foobar"</tt>
        </p>
    </dd>

    <dt>app_file</dt>
    <dd>
        主应用文件，用来检测项目的根路径， views和public文件夹和内联模板。
    </dd>

    <dt>bind</dt>
    <dd>
        绑定的IP 地址 (默认: 0.0.0.0)。 仅对于内置的服务器有用。
    </dd>

    <dt>default_encoding</dt>
    <dd>
        默认编码 (默认为 <tt>"utf-8"</tt>)。
    </dd>

    <dt>dump_errors</dt>
    <dd>
        在log中显示错误。
    </dd>

    <dt>environment</dt>
    <dd>
        当前环境，默认是 <tt>ENV['RACK_ENV']</tt>， 或者 <tt>"development"</tt> 如果不可用。
    </dd>

    <dt>logging</dt>
    <dd>
        使用logger
    </dd>

    <dt>lock</dt>
    <dd>
        <p>
            对每一个请求放置一个锁， 只使用进程并发处理请求。
        </p>

        <p>
            如果你的应用不是线程安全则需启动。 默认禁用。
        </p>
    </dd>

    <dt>method_override</dt>
    <dd>
        使用 <tt>_method</tt> 魔法以允许在旧的浏览器中在 表单中使用 put/delete 方法
    </dd>

    <dt>port</dt>
    <dd>
        监听的端口号。只对内置服务器有用。
    </dd>

    <dt>prefixed_redirects</dt>
    <dd>
        是否添加 <tt>request.script_name</tt> 到
        重定向请求，如果没有设定绝对路径。那样的话 <tt>redirect '/foo'</tt> 会和
        <tt>redirect to('/foo')</tt>起相同作用。默认禁用。
    </dd>

    <dt>public_folder</dt>
    <dd>
        public文件夹的位置。
    </dd>

    <dt>reload_templates</dt>
    <dd>
        是否每个请求都重新载入模板。 在development mode和 Ruby 1.8.6
        中被企业（用来 消除一个Ruby内存泄漏的bug）。
    </dd>

    <dt>root</dt>
    <dd>
        项目的根目录。
    </dd>

    <dt>raise_errors</dt>
    <dd>
        抛出异常（应用会停下）。
    </dd>

    <dt>run</dt>
    <dd>
        如果启用，Sinatra会开启web服务器。 如果使用rackup或其他方式则不要启用。
    </dd>

    <dt>running</dt>
    <dd>
        内置的服务器在运行吗？ 不要修改这个设置！
    </dd>

    <dt>server</dt>
    <dd>
        服务器，或用于内置服务器的列表。 默认是 [‘thin’, ‘mongrel’, ‘webrick’],
        顺序表明了 优先级。
    </dd>

    <dt>sessions</dt>
    <dd>
        开启基于cookie的sesson。
    </dd>

    <dt>show_exceptions</dt>
    <dd>
        在浏览器中显示一个stack trace。
    </dd>

    <dt>static</dt>
    <dd>
        Sinatra是否处理静态文件。 当服务器能够处理则禁用。 禁用会增强性能。
        默认开启。
    </dd>

    <dt>views</dt>
    <dd>
        views 文件夹。
    </dd>
</dl>


## 错误处理

错误处理在与路由和前置过滤器相同的上下文中运行，
这意味着你可以使用许多好东西，比如 `haml`, `erb`, `halt`，等等。

### 未找到

当一个 `Sinatra::NotFound` 错误被抛出的时候，
或者响应状态码是404，`not_found` 处理器会被调用：

~~~~ ruby
not_found do
  'This is nowhere to be found'
end
~~~~

### 错误

`error` 处理器，在任何路由代码块或者过滤器抛出异常的时候会被调用。
异常对象可以通过`sinatra.error` Rack 变量获得：

~~~~ ruby
error do
  'Sorry there was a nasty error - ' + env['sinatra.error'].message
end
~~~~

自定义错误：

~~~~ ruby
error MyCustomError do
  'So what happened was...' + env['sinatra.error'].message
end
~~~~

那么，当这个发生的时候：

~~~~ ruby
get '/' do
  raise MyCustomError, 'something bad'
end
~~~~

你会得到：

    So what happened was... something bad

另一种替代方法是，为一个状态码安装错误处理器：

~~~~ ruby
error 403 do
  'Access forbidden'
end

get '/secret' do
  403
end
~~~~

或者一个范围：

~~~~ ruby
error 400..510 do
  'Boom'
end
~~~~

在运行在development环境下时，Sinatra会安装特殊的 `not_found` 和 `error`
处理器。

## Rack 中间件

Sinatra 依靠 [Rack](http://rack.github.io/), 一个面向Ruby
web框架的最小标准接口。
Rack的一个最有趣的面向应用开发者的能力是支持“中间件”——坐落在服务器和你的应用之间，
监视 并/或 操作HTTP请求/响应以 提供多样类型的常用功能。

Sinatra 让建立Rack中间件管道异常简单， 通过顶层的 `use` 方法：

~~~~ ruby
require 'sinatra'
require 'my_custom_middleware'

use Rack::Lint
use MyCustomMiddleware

get '/hello' do
  'Hello World'
end
~~~~

`use` 的语义和在
[Rack::Builder](http://rubydoc.info/github/rack/rack/master/Rack/Builder)
DSL(在rack文件中最频繁使用)中定义的完全一样。例如，`use` 方法接受
多个/可变 参数，包括代码块：

~~~~ ruby
use Rack::Auth::Basic do |username, password|
  username == 'admin' && password == 'secret'
end
~~~~

Rack中分布有多样的标准中间件，针对日志，
调试，URL路由，认证和session处理。 Sinatra会自动使用这里面的大部分组件，
所以你一般不需要显示地 `use` 他们。

## 测试

Sinatra的测试可以使用任何基于Rack的测试程序库或者框架来编写。
[Rack::Test](http://gitrdoc.com/brynary/rack-test) 是推荐候选：

~~~~ ruby
require 'my_sinatra_app'
require 'minitest/autorun'
require 'rack/test'

class MyAppTest < Minitest::Test
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_my_default
    get '/'
    assert_equal 'Hello World!', last_response.body
  end

  def test_with_params
    get '/meet', :name => 'Frank'
    assert_equal 'Hello Frank!', last_response.body
  end

  def test_with_rack_env
    get '/', {}, 'HTTP_USER_AGENT' => 'Songbird'
    assert_equal "You're using Songbird!", last_response.body
  end
end
~~~~

请注意: 内置的 Sinatra::Test 模块和 Sinatra::TestHarness 类 在 0.9.2
版本已废弃。

## Sinatra::Base - 中间件，程序库和模块化应用

把你的应用定义在顶层，对于微型应用这会工作得很好，
但是在构建可复用的组件时候会带来客观的不利， 比如构建Rack中间件，Rails
metal，带有服务器组件的简单程序库，
或者甚至是Sinatra扩展。顶层的DSL污染了Object命名空间，
并假定了一个微型应用风格的配置 (例如, 单一的应用文件， ./public 和
./views 目录，日志，异常细节页面，等等）。 这时应该让 Sinatra::Base
走到台前了：

~~~~ ruby
require 'sinatra/base'

class MyApp < Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Hello world!'
  end
end
~~~~

Sinatra::Base子类可用的方法实际上就是通过顶层 DSL 可用的方法。
大部分顶层应用可以通过两个改变转换成Sinatra::Base组件：

-   你的文件应当引入 `sinatra/base` 而不是 `sinatra`;
    否则，所有的Sinatra的 DSL 方法将会被引进到 主命名空间。

-   把你的应用的路由，错误处理，过滤器和选项放在
    一个Sinatra::Base的子类中。

`+Sinatra::Base+` 是一张白纸。大部分的选项默认是禁用的，
包含内置的服务器。参见
[选项和配置](http://sinatra.github.com/configuration.html)
查看可用选项的具体细节和他们的行为。

### 模块化 vs. 传统的方式

与通常的认识相反，传统的方式没有任何错误。
如果它适合你的应用，你不需要转换到模块化的应用。

和模块化方式相比只有两个缺点:

-   你对每个Ruby进程只能定义一个Sinatra应用，如果你需要更多，
    切换到模块化方式。

-   传统方式使用代理方法污染了 Object 。如果你打算 把你的应用封装进一个
    library/gem，转换到模块化方式。

没有任何原因阻止你混合模块化和传统方式。

如果从一种转换到另一种，你需要注意settings中的 一些微小的不同:

    Setting             Classic                 Modular

    app_file            file loading sinatra    nil
    run                 $0 == app_file          false
    logging             true                    false
    method_override     true                    false
    inline_templates    true                    false

### 运行一个模块化应用

有两种方式运行一个模块化应用，使用 `run!`来运行:

~~~~ ruby
# my_app.rb
require 'sinatra/base'

class MyApp < Sinatra::Base
  # ... app code here ...

  # start the server if ruby file executed directly
  run! if app_file == $0
end
~~~~

运行:

    ruby my_app.rb

或者使用一个 `config.ru`，允许你使用任何Rack处理器:

~~~~ ruby
# config.ru
require './my_app'
run MyApp
~~~~

运行:

    rackup -p 4567

### 使用config.ru运行传统方式的应用

编写你的应用:

~~~~ ruby
# app.rb
require 'sinatra'

get '/' do
  'Hello world!'
end
~~~~

加入相应的 `config.ru`:

~~~~ ruby
require './app'
run Sinatra::Application
~~~~

### 什么时候用 config.ru?

以下情况你可能需要使用 `config.ru`:

-   你要使用不同的 Rack 处理器部署 (Passenger, Unicorn, Heroku, …).

-   你想使用一个或者多个 `Sinatra::Base`的子类.

-   你只想把Sinatra当作中间件使用，而不是端点。

**你并不需要切换到`config.ru`仅仅因为你切换到模块化方式，
你同样不需要切换到模块化方式， 仅仅因为要运行 `config.ru`.**

### 把Sinatra当成中间件来使用

不仅Sinatra有能力使用其他的Rack中间件，任何Sinatra
应用程序都可以反过来自身被当作中间件，被加在任何Rack端点前面。
这个端点可以是任何Sinatra应用，或者任何基于Rack的应用程序
(Rails/Ramaze/Camping/…)。

~~~~ ruby
require 'sinatra/base'

class LoginScreen < Sinatra::Base
  enable :sessions

  get('/login') { haml :login }

  post('/login') do
    if params['name'] = 'admin' and params['password'] = 'admin'
      session['user_name'] = params['name']
    else
      redirect '/login'
    end
  end
end

class MyApp < Sinatra::Base
  # 在前置过滤器前运行中间件
  use LoginScreen

  before do
    unless session['user_name']
      halt "Access denied, please <a href='/login'>login</a>."
    end
  end

  get('/') { "Hello #{session['user_name']}." }
end
~~~~

## 变量域和绑定

当前所在的变量域决定了哪些方法和变量是可用的。

### 应用/类 变量域

每个Sinatra应用相当与Sinatra::Base的一个子类。
如果你在使用顶层DSL(`require 'sinatra'`)，那么这个类就是
Sinatra::Application，或者这个类就是你显式创建的子类。
在类层面，你具有的方法类似于 \`get\` 或者 \`before\`，但是你不能访问
\`request\` 对象或者 \`session\`, 因为对于所有的请求，
只有单一的应用类。

通过 \`set\` 创建的选项是类层面的方法：

~~~~ ruby
class MyApp < Sinatra::Base
  # 嘿，我在应用变量域！
  set :foo, 42
  foo # => 42

  get '/foo' do
    # 嘿，我不再处于应用变量域了！
  end
end
~~~~

在下列情况下你将拥有应用变量域的绑定：

-   在应用类中

-   在扩展中定义的方法

-   传递给 \`helpers\` 的代码块

-   用作\`set\`值的过程/代码块

你可以访问变量域对象（就是应用类）就像这样：

-   通过传递给代码块的对象 (`configure { |c| ... }`)

-   在请求变量域中使用\`settings\`

### 请求/实例 变量域

对于每个进入的请求，一个新的应用类的实例会被创建
所有的处理器代码块在该变量域被运行。在这个变量域中， 你可以访问
\`request\` 和 \`session\` 对象，或者调用填充方法比如 \`erb\` 或者
\`haml\`。你可以在请求变量域当中通过\`settings\`辅助方法
访问应用变量域：

~~~~ ruby
class MyApp < Sinatra::Base
  # 嘿，我在应用变量域!
  get '/define_route/:name' do
    # 针对 '/define_route/:name' 的请求变量域
    @value = 42

    settings.get("/#{params['name']}") do
      # 针对 "/#{params['name']}" 的请求变量域
      @value # => nil (并不是相同的请求)
    end

    "Route defined!"
  end
end
~~~~

在以下情况将获得请求变量域：

-   get/head/post/put/delete 代码块

-   前置/后置 过滤器

-   辅助方法

-   模板/视图

### 代理变量域

代理变量域只是把方法转送到类变量域。可是，
他并非表现得100%类似于类变量域, 因为你并不能获得类的绑定:
只有显式地标记为供代理使用的方法才是可用的，
而且你不能和类变量域共享变量/状态。(解释：你有了一个不同的 \`self\`)。
你可以显式地增加方法代理，通过调用
`Sinatra::Delegator.delegate :method_name`。

在以下情况将获得代理变量域：

-   顶层的绑定，如果你做过 `require "sinatra"`

-   在扩展了 \`Sinatra::Delegator\` mixin的对象

自己在这里看一下代码: [Sinatra::Delegator
mixin](http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/base.rb#L1128)
已经
[被包含进了主命名空间](http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/main.rb#L28)。

## 命令行

Sinatra 应用可以被直接运行：

    ruby myapp.rb [-h] [-x] [-e ENVIRONMENT] [-p PORT] [-o HOST] [-s HANDLER]

选项是：

    -h # help
    -p # 设定端口 (默认是 4567)
    -o # 设定主机名 (默认是 0.0.0.0)
    -e # 设定环境 (默认是 development)
    -s # 限定 rack 服务器/处理器 (默认是 thin)
    -x # 打开互斥锁 (默认是 off)

## 必要条件

推荐在 Ruby 1.8.7, 1.9.2, JRuby 或者 Rubinius 上安装Sinatra。

下面的Ruby版本是官方支持的:

<dl>
    <dt>Ruby 1.8.6</dt>
    <dd>
        不推荐在1.8.6上安装Sinatra， 但是直到Sinatra
        1.3.0发布才会放弃对它的支持。 RDoc 和
        CoffeScript模板不被这个Ruby版本支持。
        1.8.6在它的Hash实现中包含一个内存泄漏问题，
        该问题会被1.1.1版本之前的Sinatra引发。
        当前版本使用性能下降的代价排除了这个问题。你需要把Rack降级到1.1.x，
        因为Rack \>= 1.2不再支持1.8.6。
    </dd>

    <dt>Ruby 1.8.7</dt>
    <dd>
        1.8.7 被完全支持，但是，如果没有特别原因， 我们推荐你升级到 1.9.2
        或者切换到 JRuby 或者 Rubinius.
    </dd>

    <dt>Ruby 1.9.2</dt>
    <dd>
        1.9.2 被支持而且推荐。注意 Radius 和 Markaby 模板并不和1.9兼容。不要使用
        1.9.2p0, 它被已知会产生 segmentation faults.
    </dd>

    <dt>Rubinius</dt>
    <dd>
        Rubinius 被官方支持 (Rubinius \>= 1.2.2)， 除了Textile模板。
    </dd>

    <dt>JRuby</dt>
    <dd>
        JRuby 被官方支持 (JRuby \>= 1.5.6)。 目前未知和第三方模板库有关的问题，
        但是，如果你选择了JRuby，请查看一下JRuby rack 处理器， 因为 Thin web
        服务器还没有在JRuby上获得支持。
    </dd>
</dl>

我们也会时刻关注新的Ruby版本。

下面的 Ruby 实现没有被官方支持， 但是已知可以运行 Sinatra:

-   JRuby 和 Rubinius 老版本

-   MacRuby

-   Maglev

-   IronRuby

-   Ruby 1.9.0 and 1.9.1

不被官方支持的意思是，如果在不被支持的平台上有运行错误，
我们假定不是我们的问题，而是平台的问题。

Sinatra应该会运行在任何支持上述Ruby实现的操作系统。

## 紧追前沿

如果你喜欢使用 Sinatra 的最新鲜的代码，请放心的使用 master
分支来运行你的程序，它会非常的稳定。

    cd myapp
    git clone git://github.com/sinatra/sinatra.git
    ruby -Isinatra/lib myapp.rb

我们也会不定期的发布预发布gems，所以你也可以运行

    gem install sinatra --pre

来获得最新的特性。

### 通过Bundler

如果你想使用最新的Sinatra运行你的应用，通过
[Bundler](http://gembundler.com/) 是推荐的方式。

首先，安装bundler，如果你还没有安装:

    gem install bundler

然后，在你的项目目录下，创建一个 `Gemfile`:

~~~~ ruby
source :rubygems
gem 'sinatra', :git => "git://github.com/sinatra/sinatra.git"

# 其他的依赖关系
gem 'haml'                    # 举例，如果你想用haml
gem 'activerecord', '~> 3.0'  # 也许你还需要 ActiveRecord 3.x
~~~~

请注意在这里你需要列出你的应用的所有依赖关系。 Sinatra的直接依赖关系
(Rack and Tilt) 将会， 自动被Bundler获取和添加。

现在你可以像这样运行你的应用:

    bundle exec ruby myapp.rb

### 使用自己的

创建一个本地克隆并通过 `sinatra/lib` 目录运行你的应用， 通过
`$LOAD_PATH`:

    cd myapp
    git clone git://github.com/sinatra/sinatra.git
    ruby -Isinatra/lib myapp.rb

为了在未来更新 Sinatra 源代码:

    cd myapp/sinatra
    git pull

### 全局安装

你可以自行编译 gem :

    git clone git://github.com/sinatra/sinatra.git
    cd sinatra
    rake sinatra.gemspec
    rake install

如果你以root身份安装 gems，最后一步应该是

    sudo rake install

## 更多

-   [项目主页（英文）](http://www.sinatrarb.com/) - 更多的文档，
    新闻，和其他资源的链接。

-   [贡献](http://www.sinatrarb.com/contributing) - 找到了一个bug？
    需要帮助？有了一个 patch?

-   [问题追踪](http://github.com/sinatra/sinatra/issues)

-   [Twitter](http://twitter.com/sinatra)

-   [邮件列表](http://groups.google.com/group/sinatrarb/topics)

-   [IRC: \#sinatra](irc://chat.freenode.net/#sinatra) on
    [freenode.net](http://freenode.net)

-   [Sinatra宝典](https://github.com/sinatra/sinatra-book/) Cookbook教程

-   [Sinatra使用技巧](http://recipes.sinatrarb.com/) 网友贡献的实用技巧

-   [最新版本](http://rubydoc.info/gems/sinatra)API文档；[http://rubydoc.info](http://rubydoc.info)的[当前HEAD](http://rubydoc.info/github/sinatra/sinatra)

-   [CI服务器](http://travis-ci.org/sinatra/sinatra)
# Sinatra

*Atenção: Este documento é apenas uma tradução da versão em inglês e
pode estar desatualizado.*

Sinatra é uma
[DSL](http://pt.wikipedia.org/wiki/Linguagem_de_domínio_específico) para
criar rapidamente aplicações web em Ruby com o mínimo de esforço:

``` ruby
# minhaapp.rb
require 'rubygems'
require 'sinatra'
get '/' do
  'Olá Mundo!'
end
```

Instale a gem e execute com:

``` shell
sudo gem install sinatra
ruby minhaapp.rb
```

Aceda em: [localhost:4567](http://localhost:4567)

## Rotas

No Sinatra, uma rota é um metodo HTTP associado a uma URL correspondente
padrão. Cada rota é associada a um bloco:

``` ruby
get '/' do
  .. mostrar algo ..
end

post '/' do
  .. criar algo ..
end

put '/' do
  .. atualizar algo ..
end

delete '/' do
  .. apagar algo ..
end
```

Rotas são encontradas na ordem em que são definidas. A primeira rota que
é encontrada invoca o pedido.

Padrões de rota podem incluir parâmetros nomeados, acessíveis através da
hash `params`:

``` ruby
get '/ola/:nome' do
  # corresponde a "GET /ola/foo" e "GET /ola/bar"
  # params['nome'] é 'foo' ou 'bar'
  "Olá #{params['nome']}!"
end
```

Pode também aceder a parâmetros nomeados através do bloco de parâmetros:

``` ruby
get '/ola/:nome' do |n|
  "Olá #{n}!"
end
```

Padrões de rota podem também incluir parâmetros splat (asteriscos),
acessíveis através do array `params['splat']`.

``` ruby
get '/diga/*/ao/*' do
  # corresponde a /diga/ola/ao/mundo
  params['splat'] # => ["ola", "mundo"]
end

get '/download/*.*' do
  # corresponde a /download/pasta/do/arquivo.xml
  params['splat'] # => ["pasta/do/arquivo", "xml"]
end
```

Rotas correspondem-se com expressões regulares:

``` ruby
get /\A\/ola\/([\w]+)\z/ do
  "Olá, #{params['captures'].first}!"
end
```

Ou com um bloco de parâmetro:

``` ruby
get %r{/ola/([\w]+)} do |c|
  "Olá, #{c}!"
end
```

Rotas podem incluir uma variedade de condições correspondentes, por
exemplo, o agente usuário:

``` ruby
get '/foo', :agent => /Songbird (\d\.\d)[\d\/]*?/ do
  "Você está a utilizar a versão #{params['agent'][0]} do Songbird."
end

get '/foo' do
  # Corresponde a um navegador não Songbird
end
```

## Arquivos estáticos

Arquivos estáticos são disponibilizados a partir do directório
`./public`. Você pode especificar um local diferente através da opção
`:public_folder`

``` ruby
set :public_folder, File.dirname(__FILE__) + '/estatico'
```

Note que o nome do directório público não é incluido no URL. Um arquivo
`./public/css/style.css` é disponibilizado como
`http://example.com/css/style.css`.

## Views / Templates

Templates presumem-se estar localizados sob o directório `./views`. Para
utilizar um directório de views diferente:

``` ruby
set :views, File.dirname(__FILE__) + '/modelo'
```

Uma coisa importante a ser lembrada é que você sempre tem as referências
dos templates como símbolos, mesmo se eles estiverem num sub-directório
(nesse caso utilize `:'subdir/template'`). Métodos de renderização irão
processar qualquer string passada directamente para elas.

### Haml Templates

A gem/biblioteca haml é necessária para renderizar templates HAML:

``` ruby
# É necessário requerir 'haml' na aplicação.
require 'haml'

get '/' do
  haml :index
end
```

Renderiza `./views/index.haml`.

[Opções
Haml](http://haml.info/docs/yardoc/file.HAML_REFERENCE.html#options)
podem ser definidas globalmente através das configurações do sinatra,
veja [Opções e
Configurações](http://www.sinatrarb.com/configuration.html), e substitua
em uma requisição individual.

``` ruby
set :haml, {:format => :html5 } # o formato padrão do Haml é :xhtml

get '/' do
  haml :index, :haml_options => {:format => :html4 } # substituido
end
```

### Erb Templates

``` ruby
# É necessário requerir 'erb' na aplicação.
require 'erb'

get '/' do
  erb :index
end
```

Renderiza `./views/index.erb`

### Erubis

A gem/biblioteca erubis é necessária para renderizar templates erubis:

``` ruby
# É necessário requerir 'erubis' na aplicação.
require 'erubis'

get '/' do
  erubis :index
end
```

Renderiza `./views/index.erubis`

### Builder Templates

A gem/biblioteca builder é necessária para renderizar templates builder:

``` ruby
# É necessário requerir 'builder' na aplicação.
require 'builder'

get '/' do
  content_type 'application/xml', :charset => 'utf-8'
  builder :index
end
```

Renderiza `./views/index.builder`.

### Sass Templates

A gem/biblioteca sass é necessária para renderizar templates sass:

``` ruby
# É necessário requerir 'haml' ou 'sass' na aplicação.
require 'sass'

get '/stylesheet.css' do
  content_type 'text/css', :charset => 'utf-8'
  sass :stylesheet
end
```

Renderiza `./views/stylesheet.sass`.

[Opções
Sass](http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#options)
podem ser definidas globalmente através das configurações do sinatra,
veja [Opções e
Configurações](http://www.sinatrarb.com/configuration.html), e substitua
em uma requisição individual.

``` ruby
set :sass, {:style => :compact } # o estilo padrão do Sass é :nested

get '/stylesheet.css' do
  content_type 'text/css', :charset => 'utf-8'
  sass :stylesheet, :style => :expanded # substituido
end
```

### Less Templates

A gem/biblioteca less é necessária para renderizar templates Less:

``` ruby
# É necessário requerir 'less' na aplicação.
require 'less'

get '/stylesheet.css' do
  content_type 'text/css', :charset => 'utf-8'
  less :stylesheet
end
```

Renderiza `./views/stylesheet.less`.

### Templates Inline

``` ruby
get '/' do
  haml '%div.title Olá Mundo'
end
```

Renderiza a string, em uma linha, no template.

### Acedendo a Variáveis nos Templates

Templates são avaliados dentro do mesmo contexto que os manipuladores de
rota. Variáveis de instância definidas em rotas manipuladas são
directamente acedidas por templates:

``` ruby
get '/:id' do
  @foo = Foo.find(params['id'])
  haml '%h1= @foo.nome'
end
```

Ou, especifique um hash explícito para variáveis locais:

``` ruby
get '/:id' do
  foo = Foo.find(params['id'])
  haml '%h1= foo.nome', :locals => { :foo => foo }
end
```

Isso é tipicamente utilizado quando renderizamos templates parciais
(partials) dentro de outros templates.

### Templates Inline

Templates podem ser definidos no final do arquivo fonte(.rb):

``` ruby
require 'rubygems'
require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.title Olá Mundo!!!!!
```

NOTA: Templates inline definidos no arquivo fonte são automaticamente
carregados pelo sinatra. Digite \`enable :inline\_templates\` se tem
templates inline no outro arquivo fonte.

### Templates nomeados

Templates também podem ser definidos utilizando o método top-level
`template`:

``` ruby
template :layout do
  "%html\n  =yield\n"
end

template :index do
  '%div.title Olá Mundo!'
end

get '/' do
  haml :index
end
```

Se existir um template com nome “layout”, ele será utilizado sempre que
um template for renderizado. Pode desactivar layouts usando
`:layout => false`.

``` ruby
get '/' do
  haml :index, :layout => !request.xhr?
end
```

## Helpers

Use o método de alto nível `helpers` para definir métodos auxiliares
para utilizar em manipuladores de rotas e modelos:

``` ruby
helpers do
  def bar(nome)
    "#{nome}bar"
  end
end

get '/:nome' do
  bar(params['nome'])
end
```

## Filtros

Filtros Before são avaliados antes de cada requisição dentro do contexto
da requisição e podem modificar a requisição e a reposta. Variáveis de
instância definidas nos filtros são acedidas através de rotas e
templates:

``` ruby
before do
  @nota = 'Olá!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @nota #=> 'Olá!'
  params['splat'] #=> 'bar/baz'
end
```

Filtros After são avaliados após cada requisição dentro do contexto da
requisição e também podem modificar o pedido e a resposta. Variáveis de
instância definidas nos filtros before e rotas são acedidas através dos
filtros after:

``` ruby
after do
  puts response.status
end
```

Filtros opcionalmente têm um padrão, fazendo com que sejam avaliados
somente se o caminho do pedido coincidir com esse padrão:

``` ruby
before '/protected/*' do
  autenticar!
end

after '/create/:slug' do |slug|
  session[:last_slug] = slug
end
```

## Halting

Para parar imediatamente uma requisição dentro de um filtro ou rota
utilize:

``` ruby
halt
```

Pode também especificar o status ao parar…

``` ruby
halt 410
```

Ou com um corpo de texto…

``` ruby
halt 'isto será o corpo de texto'
```

Ou também…

``` ruby
halt 401, 'vamos embora!'
```

Com cabeçalhos…

``` ruby
halt 402, {'Content-Type' => 'text/plain'}, 'revanche'
```

## Passing

Dentro de uma rota, pode passar para a próxima rota correspondente
usando `pass`:

``` ruby
get '/adivinhar/:quem' do
  pass unless params['quem'] == 'Frank'
  'Apanhaste-me!'
end

get '/adivinhar/*' do
  'Falhaste!'
end
```

O bloqueio da rota é imediatamente encerrado e o controle continua com a
próxima rota de parâmetro. Se o parâmetro da rota não for encontrado, um
404 é retornado.

## Configuração

Correndo uma vez, na inicialização, em qualquer ambiente:

``` ruby
configure do
  ...
end
```

Correndo somente quando o ambiente (`RACK_ENV` environment variável) é
definido para `:production`:

``` ruby
configure :production do
  ...
end
```

Correndo quando o ambiente é definido para `:production` ou `:test`:

``` ruby
configure :production, :test do
  ...
end
```

## Lidar com Erros

Lida-se com erros no mesmo contexto das rotas e filtros before, o que
signifca que `haml`, `erb`, etc, estão disponíveis.

### Não Encontrado

Quando um `Sinatra::NotFound` exception é levantado, ou o código de
status da reposta é 404, o manipulador `not_found` é invocado:

``` ruby
not_found do
  'Isto está longe de ser encontrado'
end
```

### Erro

O manipulador `error` é invocado sempre que uma exceção é lançada a
partir de um bloco de rota ou um filtro. O objecto da exceção pode ser
obtido a partir da variável Rack `sinatra.error`:

``` ruby
error do
  'Peço desculpa, houve um erro desagradável - ' + env['sinatra.error'].message
end
```

Erros personalizados:

``` ruby
error MeuErroPersonalizado do
  'O que aconteceu foi...' + env['sinatra.error'].message
end
```

Então, se isso acontecer:

``` ruby
get '/' do
  raise MeuErroPersonalizado, 'alguma coisa desagradável'
end
```

O resultado será:

```
O que aconteceu foi...alguma coisa desagradável
```

Alternativamente, pode definir um manipulador de erro para um código de
status:

``` ruby
error 403 do
  'Accesso negado'
end

get '/secreto' do
  403
end
```

Ou um range (alcance):

``` ruby
error 400..510 do
  'Boom'
end
```

O Sinatra define os manipuladores especiais `not_found` e `error` quando
corre no ambiente de desenvolvimento.

## Mime Types

Quando utilizamos `send_file` ou arquivos estáticos pode ter mime types
Sinatra não entendidos. Use `mime_type` para os registar por extensão de
arquivos:

``` ruby
mime_type :foo, 'text/foo'
```

Pode também utilizar isto com o helper `content_type`:

``` ruby
content_type :foo
```

## Middleware Rack

O Sinatra corre no [Rack](http://rack.github.io/), uma interface
padrão mínima para frameworks web em Ruby. Uma das capacidades mais
interessantes do Rack, para desenvolver aplicações, é o suporte de
“middleware” – componentes que residem entre o servidor e a aplicação,
monitorizando e/ou manipulando o pedido/resposta (request/response) HTTP
para providenciar varios tipos de funcionalidades comuns.

O Sinatra torna a construção de pipelines do middleware Rack fácil a um
nível superior utilizando o método `use`:

``` ruby
require 'sinatra'
require 'meu_middleware_personalizado'

use Rack::Lint
use MeuMiddlewarePersonalizado

get '/ola' do
  'Olá mundo'
end
```

A semântica de `use` é idêntica aquela definida para a DSL
[Rack::Builder](http://rubydoc.info/github/rack/rack/master/Rack/Builder)
(mais frequentemente utilizada para arquivos rackup). Por exemplo, o
método `use` aceita múltiplos argumentos/variáveis, bem como blocos:

``` ruby
use Rack::Auth::Basic do |utilizador, senha|
  utilizador == 'admin' && senha == 'secreto'
end
```

O Rack é distribuido com uma variedade de middleware padrões para logs,
debugs, rotas de URL, autenticação, e manipuladores de sessão.Sinatra
utiliza muitos desses componentes automaticamente dependendo da
configuração, por isso, tipicamente nao é necessário utilizar `use`
explicitamente.

## Testando

Testes no Sinatra podem ser escritos utilizando qualquer biblioteca ou
framework de teste baseados no Rack.
[Rack::Test](http://gitrdoc.com/brynary/rack-test) é recomendado:

``` ruby
require 'minha_aplicacao_sinatra'
require 'rack/test'

class MinhaAplicacaoTeste < Minitest::Test
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def meu_test_default
    get '/'
    assert_equal 'Ola Mundo!', last_response.body
  end

  def teste_com_parametros
    get '/atender', :name => 'Frank'
    assert_equal 'Olá Frank!', last_response.bodymeet
  end

  def test_com_ambiente_rack
    get '/', {}, 'HTTP_USER_AGENT' => 'Songbird'
    assert_equal "Você está utilizando o Songbird!", last_response.body
  end
end
```

NOTA: Os módulos de classe embutidos `Sinatra::Test` e
`Sinatra::TestHarness` são depreciados na versão 0.9.2.

## Sinatra::Base - Middleware, Bibliotecas e aplicativos modulares

Definir sua aplicação a um nível superior de trabalho funciona bem para
micro aplicativos, mas tem consideráveis incovenientes na construção de
componentes reutilizáveis como um middleware Rack, metal Rails,
bibliotecas simples como um componente de servidor, ou mesmo extensões
Sinatra. A DSL de nível superior polui o espaço do objeto e assume um
estilo de configuração de micro aplicativos (exemplo: um simples arquivo
de aplicação, directórios `./public` e `./views`, logs, página de detalhes
de excepção, etc.). É onde o Sinatra::Base entra em jogo:

``` ruby
require 'sinatra/base'

class MinhaApp < Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Olá mundo!'
  end
end
```

A classe MinhaApp é um componente Rack independente que pode utilizar
como um middleware Rack, uma aplicação Rack, ou metal Rails. Pode
utilizar ou executar esta classe com um arquivo rackup `config.ru`;
ou, controlar um componente de servidor fornecendo como biblioteca:

``` ruby
MinhaApp.run! :host => 'localhost', :port => 9090
```

Os métodos disponíveis para subclasses `Sinatra::Base` são exatamente como
aqueles disponíveis via a DSL de nível superior. Aplicações de nível
mais alto podem ser convertidas para componentes `Sinatra::Base` com duas
modificações:

-   Seu arquivo deve requerer `sinatra/base` ao invés de `sinatra`;
    outra coisa, todos os métodos DSL do Sinatra são importados para o
    espaço principal.

-   Coloque as rotas da sua aplicação, manipuladores de erro, filtros e
    opções na subclasse de um `Sinatra::Base`.

`Sinatra::Base` é um quadro branco. Muitas opções são desactivadas por
padrão, incluindo o servidor embutido. Veja [Opções e
Configurações](http://sinatra.github.com/configuration.html) para
detalhes de opções disponíveis e seus comportamentos.

SIDEBAR: A DSL de alto nível do Sinatra é implementada utilizando um simples
sistema de delegação. A classe `Sinatra::Application` – uma subclasse especial
da `Sinatra::Base` – recebe todos os `:get`, `:put`, `:post`, `:delete`,
`:before`, `:error`, `:not_found`, `:configure`, e `:set` messages enviados
para o alto nível. Dê você mesmo uma vista de olhos ao código: aqui está o
[Sinatra::Delegator
mixin](http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/base.rb#L1128)
sendo [incluido dentro de um espaço
principal](http://github.com/sinatra/sinatra/blob/ceac46f0bc129a6e994a06100aa854f606fe5992/lib/sinatra/main.rb#L28)

## Linha de Comandos

As aplicações Sinatra podem ser executadas directamente:

``` shell
ruby minhaapp.rb [-h] [-x] [-e AMBIENTE] [-p PORTA] [-o HOST] [-s SERVIDOR]
```

As opções são:

```
-h # ajuda
-p # define a porta (padrão é 4567)
-o # define o host (padrão é 0.0.0.0)
-e # define o ambiente (padrão é development)
-s # especifica o servidor/manipulador rack (padrão é thin)
-x # activa o bloqueio (padrão é desligado)
```

## A última versão

Se gostaria de utilizar o código da última versão do Sinatra, crie um
clone local e execute sua aplicação com o directório `sinatra/lib` no
`LOAD_PATH`:

``` shell
cd minhaapp
git clone git://github.com/sinatra/sinatra.git
ruby -I sinatra/lib minhaapp.rb
```

Alternativamente, pode adicionar o directório do `sinatra/lib` no
`LOAD_PATH` do seu aplicativo:

``` ruby
$LOAD_PATH.unshift File.dirname(__FILE__) + '/sinatra/lib'
require 'rubygems'
require 'sinatra'

get '/sobre' do
  "Estou correndo a versão" + Sinatra::VERSION
end
```

Para actualizar o código do Sinatra no futuro:

``` shell
cd meuprojeto/sinatra
git pull
```

## Mais

-   [Website do Projeto](http://www.sinatrarb.com/) - Documentação
    adicional, novidades e links para outros recursos.

-   [Contribuir](http://www.sinatrarb.com/contributing) - Encontrou um
    bug? Precisa de ajuda? Tem um patch?

-   [Acompanhar Questões](http://github.com/sinatra/sinatra/issues)

-   [Twitter](http://twitter.com/sinatra)

-   [Lista de Email](http://groups.google.com/group/sinatrarb/topics)

-   [IRC: \#sinatra](irc://chat.freenode.net/#sinatra) em
    [freenode.net](http://freenode.net)
# Sinatra

*Atención: Este documento es una traducción de la versión en inglés y puede estar desactualizado.*

Sinatra es un
[DSL](http://es.wikipedia.org/wiki/Lenguaje_específico_del_dominio) para
crear aplicaciones web rápidamente en Ruby con un mínimo esfuerzo:

```  ruby
# miapp.rb
require 'sinatra'

get '/' do
  'Hola mundo!'
end
```

Instalar la gema y correr la aplicación con:

```  shell
gem install sinatra
ruby miapp.rb
```

Ver en <http://localhost:4567>.

Se recomienda ejecutar `gem install thin`, porque Sinatra lo utilizará si está disponible.

## Rutas

En Sinatra, una ruta es un método HTTP junto a un patrón de un URL.
Cada ruta está asociada a un bloque:

``` ruby
get '/' do
  .. mostrar algo ..
end

post '/' do
  .. crear algo ..
end

put '/' do
  .. reemplazar algo ..
end

patch '/' do
  .. modificar algo ..
end

delete '/' do
  .. aniquilar algo ..
end

options '/' do
  .. informar algo ..
end

link '/' do
  .. afiliar a algo ..
end

unlink '/' do
  .. separar algo ..
end

```

Las rutas son comparadas en el orden en el que son definidas. La primera ruta
que coincide con la petición es escogida.

Los patrones de las rutas pueden incluir parámetros nombrados, accesibles a
través del hash `params`:

``` ruby
get '/hola/:nombre' do
  # coincide con "GET /hola/foo" y "GET /hola/bar"
  # params['nombre'] es 'foo' o 'bar'
  "Hola #{params['nombre']}!"
end
```

También puede acceder a los parámetros nombrados usando parámetros de bloque:

``` ruby
get '/hola/:nombre' do |n|
  # coincide con "GET /hola/foo" y "GET /hola/bar"
  # params['nombre'] es 'foo' o 'bar'
  # n almacena params['nombre']
  "Hola #{n}!"
end
```

Los patrones de ruta también pueden incluir parámetros splat (o wildcard),
accesibles a través del arreglo `params['splat']`:

``` ruby
get '/decir/*/al/*' do
  # coincide con /decir/hola/al/mundo
  params['splat'] # => ["hola", "mundo"]
end

get '/descargar/*.*' do
  # coincide con /descargar/path/al/archivo.xml
  params['splat'] # => ["path/al/archivo", "xml"]
end
```

O, con parámetros de bloque:

``` ruby
get '/descargar/*.*' do |path, ext|
  [path, ext] # => ["path/al/archivo", "xml"]
end
```

Rutas con Expresiones Regulares:

``` ruby
get /\A\/hola\/([\w]+)\z/ do
  "Hola, #{params['captures'].first}!"
end
```

O con un parámetro de bloque:

``` ruby
get %r{/hola/([\w]+)} do |c|
  "Hola, #{c}!"
end
```

Los patrones de ruta pueden contener parámetros opcionales:

``` ruby
get '/posts.?:formato?' do
  # coincide con "GET /posts" y además admite cualquier extensión, por
  # ejemplo, "GET /posts.json", "GET /posts.xml", etc.
end
```

A propósito, a menos que desactives la protección para el ataque *path
traversal* (ver más abajo), el path de la petición puede ser modificado
antes de que se compare con los de tus rutas.

## Condiciones

Las rutas pueden incluir una variedad de condiciones de selección, como por
ejemplo el user agent:

``` ruby
get '/foo', :agent => /Songbird (\d\.\d)[\d\/]*?/ do
  "Estás usando la versión de Songbird #{params['agent'][0]}"
end

get '/foo' do
  # Coincide con navegadores que no sean songbird
end
```

Otras condiciones disponibles son `host_name` y `provides`:

``` ruby
get '/', :host_name => /^admin\./ do
  "Área de Administración, Acceso denegado!"
end

get '/', :provides => 'html' do
  haml :index
end

get '/', :provides => ['rss', 'atom', 'xml'] do
  builder :feed
end
```

Puede definir sus propias condiciones fácilmente:

``` ruby
set(:probabilidad) { |valor| condition { rand <= valor } }

get '/gana_un_auto', :probabilidad => 0.1 do
  "Ganaste!"
end

get '/gana_un_auto' do
  "Lo siento, perdiste."
end
```

Si su condición acepta más de un argumento, puede pasarle un arreglo. Al
definir la condición, se puede utilizar el operador splat en
la lista de parámetros:

``` ruby
set(:autorizar) do |*roles|   # <- mirá el splat
  condition do
    unless sesion_iniciada? && roles.any? {|rol| usuario_actual.tiene_rol? rol }
      redirect "/iniciar_sesion/", 303
    end
  end
end

get "/mi/cuenta/", :autorizar => [:usuario, :administrador] do
  "Detalles de mi cuenta"
end

get "/solo/administradores/", :autorizar => :administrador do
  "Únicamente para administradores!"
end
```

### Valores de Retorno

El valor de retorno de un bloque de ruta que determina al menos el cuerpo de la
respuesta que se le pasa al cliente HTTP o al siguiente middleware en la pila
de Rack. Lo más común es que sea un string, como en los ejemplos anteriores.
Sin embargo, otros valores también son aceptados.

Puede devolver cualquier objeto que sea una respuesta Rack válida, un objeto
que represente el cuerpo de una respuesta Rack o un código de estado HTTP:

* Un arreglo con tres elementos: `[estado (Fixnum), cabeceras (Hash), cuerpo de
  la respuesta (responde a #each)]`
* Un arreglo con dos elementos: `[estado (Fixnum), cuerpo de la respuesta
  (responde a #each)]`
* Un objeto que responde a `#each` y que le pasa únicamente strings al bloque
  dado
* Un Fixnum representando el código de estado

De esa manera, podemos fácilmente implementar un ejemplo de streaming:

``` ruby
class Stream
  def each
    100.times { |i| yield "#{i}\n" }
  end
end

get('/') { Stream.new }
```

### Comparadores de Rutas Personalizados

Como se mostró anteriormente, Sinatra permite utilizar strings y expresiones
regulares para definir las rutas. Sin embargo, la cosa no termina ahí. Podés
definir tus propios comparadores muy fácilmente:

``` ruby
class PatronCualquieraMenos
  Match = Struct.new(:captures)

  def initialize(excepto)
    @excepto  = excepto
    @capturas = Match.new([])
  end

  def match(str)
    @capturas unless @excepto === str
  end
end

def cualquiera_menos(patron)
  PatronCualquieraMenos.new(patron)
end

get cualquiera_menos("/index") do
  # ...
end
```

Tenga en cuenta que el ejemplo anterior es un poco rebuscado. Un resultado
similar puede conseguirse más sencillamente:

``` ruby
get // do
  pass if request.path_info == "/index"
  # ...
end
```

O, usando un lookahead negativo:

``` ruby
get %r{^(?!/index$)} do
  # ...
end
```

### Archivos Estáticos

Los archivos estáticos son servidos desde el directorio público
`./public`. Puede especificar una ubicación diferente ajustando la
opción `:public_folder`:

``` ruby
set :public_folder, File.dirname(__FILE__) + '/estaticos'
```

Note que el nombre del directorio público no está incluido en la URL. Por
ejemplo, el archivo `./public/css/style.css` se accede a través de
`http://ejemplo.com/css/style.css`.

Use la configuración `:static_cache_control` para agregar el encabezado
`Cache-Control` (ver la sección de configuración para más detalles).

### Vistas / Plantillas

Cada lenguaje de plantilla se expone a través de un método de renderizado que
lleva su nombre. Estos métodos simplemente devuelven un string:

``` ruby
get '/' do
  erb :index
end
```

Renderiza `views/index.erb`.

En lugar del nombre de la plantilla podés proporcionar directamente el
contenido de la misma:

``` ruby
get '/' do
  codigo = "<%= Time.now %>"
  erb codigo
end
```

Los métodos de renderizado, aceptan además un segundo argumento, el hash de
opciones:

``` ruby
get '/' do
  erb :index, :layout => :post
end
```

Renderiza `views/index.erb` incrustado en `views/post.erb` (por
defecto, la plantilla `:index` es incrustada en `views/layout.erb` siempre y
cuando este último archivo exista).

Cualquier opción que Sinatra no entienda le será pasada al motor de renderizado
de la plantilla:

``` ruby
get '/' do
  haml :index, :format => :html5
end
```

Además, puede definir las opciones para un lenguaje de plantillas de forma
general:

``` ruby
set :haml, :format => :html5

get '/' do
  haml :index
end
```

Las opciones pasadas al método de renderizado tienen precedencia sobre las
definidas mediante `set`.

Opciones disponibles:

<dl>

  <dt>locals</dt>
  <dd>
    Lista de variables locales pasadas al documento. Resultan muy útiles cuando
    se combinan con parciales.
    Ejemplo: <tt>erb "<%= foo %>", :locals => {:foo => "bar"}</tt>
  </dd>

  <dt>default_encoding</dt>
  <dd>
    Encoding utilizado cuando el de un string es dudoso. Por defecto toma el
    valor de <tt>settings.default_encoding</tt>.
  </dd>

  <dt>views</dt>
  <dd>
    Directorio desde donde se cargan las vistas. Por defecto toma el valor de
    <tt>settings.views</tt>.
  </dd>

  <dt>layout</dt>
  <dd>
    Si es <tt>true</tt> o <tt>false</tt> indica que se debe usar, o no, un layout,
    respectivamente. También puede ser un símbolo que especifique qué plantilla
    usar. Ejemplo: <tt>erb :index, :layout => !request.xhr?</tt>
  </dd>

  <dt>content_type</dt>
  <dd>
    Content-Type que produce la plantilla. El valor por defecto depende de cada
    lenguaje de plantillas.
  </dd>

  <dt>scope</dt>
  <dd>
    Ámbito en el que se renderiza la plantilla. Por defecto utiliza la instancia
    de la aplicación. Tené en cuenta que si cambiás esta opción las variables de
    instancia y los helpers van a dejar de estar disponibles.
  </dd>

  <dt>layout_engine</dt>
  <dd>
    Motor de renderizado de plantillas que usa para el layout. Resulta
    conveniente para lenguajes que no soportan layouts. Por defecto toma el valor
    del motor usado para renderizar la plantilla.
    Ejemplo: <tt>set :rdoc, :layout_engine => :erb</tt>
  </dd>

  <dd>
    Se asume que las plantillas están ubicadas directamente bajo el directorio
    <tt>./views</tt>. Para usar un directorio de vistas diferente:
    <tt>set :views, settings.root + '/plantillas'</tt>
  </dd>

  <dd>
    Es importante acordarse que siempre tenés que referenciar a las plantillas con
    símbolos, incluso cuando se encuentran en un subdirectorio (en este caso
    tenés que usar: `:'subdir/plantilla'` o `'subdir/plantilla'.to_sym`). Tenés que
    usar un símbolo porque los métodos de renderización van a renderizar
    directamente cualquier string que se les pase como argumento.
  </dd>
</dl>

### Lenguajes de Plantillas Disponibles

Algunos lenguajes tienen varias implementaciones. Para especificar que
implementación usar (y para ser thread-safe), deberías requerirla antes de
usarla:

``` ruby
require 'rdiscount' # o require 'bluecloth'
get('/') { markdown :index }
```

### Plantillas Haml

<table>
  <tr>
    <td>Dependencias</td>
    <td><a href="http://haml.info/" title="haml">haml</a></td>
  </tr>
  <tr>
    <td>Expresiones de Archivo</td>
    <td><tt>.haml</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>haml :index, :format => :html5</tt></td>
  </tr>
</table>

### Plantillas Erb

<table>
  <tr>
    <td>Dependencias</td>
    <td>
      <a href="http://www.kuwata-lab.com/erubis/" title="erubis">erubis</a>
      o erb (incluida en Ruby)
    </td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.erb</tt>, <tt>.rhtml</tt> o <tt>.erubis</tt> (solamente con Erubis)</td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>erb :index</tt></td>
  </tr>
</table>

### Plantillas Builder

<table>
  <tr>
    <td>Dependencias</td>
    <td>
      <a href="https://github.com/jimweirich/builder" title="builder">builder</a>
    </td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.builder</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>builder { |xml| xml.em "hola" }</tt></td>
  </tr>
</table>

Además, acepta un bloque con la definición de la plantilla (ver ejemplo).

### Plantillas Nokogiri

<table>
  <tr>
    <td>Dependencias</td>
    <td><a href="http://nokogiri.org/" title="nokogiri">nokogiri</a></td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.nokogiri</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>nokogiri { |xml| xml.em "hola" }</tt></td>
  </tr>
</table>

Además, acepta un bloque con la definición de la plantilla (ver ejemplo).

### Plantillas Sass

<table>
  <tr>
    <td>Dependencias</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.sass</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>sass :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>

### Plantillas SCSS

<table>
  <tr>
    <td>Dependencias</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.scss</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>scss :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>

### Plantillas Less

<table>
  <tr>
    <td>Dependencias</td>
    <td><a href="http://www.lesscss.org/" title="less">less</a></td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.less</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>less :stylesheet</tt></td>
  </tr>
</table>

### Plantillas Liquid

<table>
  <tr>
    <td>Dependencias</td>
    <td><a href="http://www.liquidmarkup.org/" title="liquid">liquid</a></td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.liquid</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>liquid :index, :locals => { :clave => 'valor' }</tt></td>
  </tr>
</table>

Como no va a poder llamar a métodos de Ruby (excepto por `yield`) desde una
plantilla Liquid, casi siempre va a querer pasarle locales.

### Plantillas Markdown

<table>
  <tr>
    <td>Dependencias</td>
    <td>
      <a href="https://github.com/rtomayko/rdiscount" title="RDiscount">RDiscount</a>,
      <a href="https://github.com/vmg/redcarpet" title="RedCarpet">RedCarpet</a>,
      <a href="http://deveiate.org/projects/BlueCloth" title="BlueCloth">BlueCloth</a>,
      <a href="http://kramdown.gettalong.org/" title="kramdown">kramdown</a> o
      <a href="https://github.com/bhollis/maruku" title="maruku">maruku</a>
    </td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.markdown</tt>, <tt>.mkd</tt> y <tt>.md</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>markdown :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

No es posible llamar métodos desde markdown, ni pasarle locales. Por lo tanto,
generalmente va a usarlo en combinación con otro motor de renderizado:

``` ruby
erb :resumen, :locals => { :texto => markdown(:introduccion) }
```

Tenga en cuenta que también podés llamar al método `markdown` desde otras
plantillas:

``` ruby
%h1 Hola Desde Haml!
%p= markdown(:saludos)
```

Como no puede utilizar Ruby desde Markdown, no puede usar layouts escritos en
Markdown. De todos modos, es posible usar un motor de renderizado para el
layout distinto al de la plantilla pasando la opción `:layout_engine`.

### Plantillas Textile

<table>
  <tr>
    <td>Dependencias</td>
    <td><a href="http://redcloth.org/" title="RedCloth">RedCloth</a></td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.textile</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>textile :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

No es posible llamar métodos desde textile, ni pasarle locales. Por lo tanto,
generalmente vas a usarlo en combinación con otro motor de renderizado:

``` ruby
erb :resumen, :locals => { :texto => textile(:introduccion) }
```

Tené en cuenta que también podés llamar al método `textile` desde otras
plantillas:

``` ruby
%h1 Hola Desde Haml!
%p= textile(:saludos)
```

Como no podés utilizar Ruby desde Textile, no podés usar layouts escritos en
Textile. De todos modos, es posible usar un motor de renderizado para el
layout distinto al de la plantilla pasando la opción `:layout_engine`.

### Plantillas RDoc

<table>
  <tr>
    <td>Dependencias</td>
    <td><a href="http://rdoc.sourceforge.net/" title="RDoc">RDoc</a></td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.rdoc</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>rdoc :README, :layout_engine => :erb</tt></td>
  </tr>
</table>

No es posible llamar métodos desde rdoc, ni pasarle locales. Por lo tanto,
generalmente vas a usarlo en combinación con otro motor de renderizado:

``` ruby
erb :resumen, :locals => { :texto => rdoc(:introduccion) }
```

Tené en cuenta que también podés llamar al método `rdoc` desde otras
plantillas:

``` ruby
%h1 Hola Desde Haml!
%p= rdoc(:saludos)
```

Como no podés utilizar Ruby desde RDoc, no podés usar layouts escritos en RDoc.
De todos modos, es posible usar un motor de renderizado para el layout distinto
al de la plantilla pasando la opción `:layout_engine`.

### Plantillas Radius

<table>
  <tr>
    <td>Dependencias</td>
    <td><a href="https://github.com/jlong/radius" title="Radius">Radius</a></td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.radius</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>radius :index, :locals => { :clave => 'valor' }</tt></td>
  </tr>
</table>

Desde que no se puede utilizar métodos de Ruby (excepto por `yield`) de una
plantilla Radius, casi siempre se necesita pasar locales.

### Plantillas Markaby

<table>
  <tr>
    <td>Dependencias</td>
    <td><a href="http://markaby.github.com/" title="Markaby">Markaby</a></td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.mab</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>markaby { h1 "Bienvenido!" }</tt></td>
  </tr>
</table>

Además, acepta un bloque con la definición de la plantilla (ver ejemplo).

### Plantillas RABL

<table>
  <tr>
    <td>Dependencias</td>
    <td><a href="https://github.com/nesquena/rabl" title="Rabl">Rabl</a></td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.rabl</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>rabl :index</tt></td>
  </tr>
</table>

### Plantillas Slim

<table>
  <tr>
    <td>Dependencias</td>
    <td><a href="http://slim-lang.com/" title="Slim Lang">Slim Lang</a></td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.slim</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>slim :index</tt></td>
  </tr>
</table>

### Plantillas Creole

<table>
  <tr>
    <td>Dependencias</td>
    <td><a href="https://github.com/minad/creole" title="Creole">Creole</a></td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.creole</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>creole :wiki, :layout_engine => :erb</tt></td>
  </tr>
</table>

No es posible llamar métodos desde creole, ni pasarle locales. Por lo tanto,
generalmente va a usarlo en combinación con otro motor de renderizado:

``` ruby
erb :resumen, :locals => { :texto => cerole(:introduccion) }
```

Debe tomar en cuenta que también puede llamar al método `creole` desde otras
plantillas:

``` ruby
%h1 Hola Desde Haml!
%p= creole(:saludos)
```

Como no podés utilizar Ruby desde Creole, no podés usar layouts escritos en
Creole. De todos modos, es posible usar un motor de renderizado para el layout
distinto al de la plantilla pasando la opción `:layout_engine`.

### Plantillas CoffeeScript

<table>
  <tr>
    <td>Dependencias</td>
    <td>
      <a href="https://github.com/josh/ruby-coffee-script" title="Ruby CoffeeScript">
        CoffeeScript
      </a> y un
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        mecanismo para ejecutar javascript
      </a>
    </td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.coffee</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>coffee :index</tt></td>
  </tr>
</table>

### Plantillas Stylus

<table>
  <tr>
    <td>Dependencias</td>
    <td>
      <a href="https://github.com/lucasmazza/ruby-stylus" title="Ruby Stylus">
        Stylus
      </a> y un
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        mecanismo para ejecutar javascript
      </a>
    </td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.styl</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>stylus :index</tt></td>
  </tr>
</table>

### Plantillas Yajl

<table>
  <tr>
    <td>Dependencias</td>
    <td><a href="https://github.com/brianmario/yajl-ruby" title="yajl-ruby">yajl-ruby</a></td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.yajl</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td>
      <tt>
        yajl :index,
             :locals => { :key => 'qux' },
             :callback => 'present',
             :variable => 'resource'
      </tt>
    </td>
  </tr>
</table>

El contenido de la plantilla se evalúa como código Ruby, y la variable `json` es convertida a JSON mediante `#to_json`.

``` ruby
json = { :foo => 'bar' }
json[:baz] = key
```

Las opciones `:callback` y `:variable` se pueden utilizar para decorar el objeto renderizado:

``` ruby
var resource = {"foo":"bar","baz":"qux"}; present(resource);
```

### Plantillas WLang

<table>
  <tr>
    <td>Dependencias</td>
    <td><a href="https://github.com/blambeau/wlang/" title="wlang">wlang</a></td>
  </tr>
  <tr>
    <td>Extensiones de Archivo</td>
    <td><tt>.wlang</tt></td>
  </tr>
  <tr>
    <td>Ejemplo</td>
    <td><tt>wlang :index, :locals => { :clave => 'valor' }</tt></td>
  </tr>
</table>

Como no vas a poder llamar a métodos de Ruby (excepto por `yield`) desde una
plantilla WLang, casi siempre vas a querer pasarle locales.

### Plantillas Embebidas

``` ruby
get '/' do
  haml '%div.titulo Hola Mundo'
end
```

Renderiza el template embebido en el string.

### Accediendo a Variables en Plantillas

Las plantillas son evaluadas dentro del mismo contexto que los manejadores de
ruta. Las variables de instancia asignadas en los manejadores de ruta son
accesibles directamente por las plantillas:

``` ruby
get '/:id' do
  @foo = Foo.find(params['id'])
  haml '%h1= @foo.nombre'
end
```

O es posible especificar un Hash de variables locales explícitamente:

``` ruby
get '/:id' do
  foo = Foo.find(params['id'])
  haml '%h1= bar.nombre', :locals => { :bar => foo }
end
```

Esto es usado típicamente cuando se renderizan plantillas como parciales desde
adentro de otras plantillas.

### Plantillas Inline

Las plantillas pueden ser definidas al final del archivo fuente:

``` ruby
require 'rubygems'
require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.titulo Hola mundo!!!!!
```

NOTA: únicamente las plantillas inline definidas en el archivo fuente que
requiere Sinatra son cargadas automáticamente. Llamá `enable
:inline_templates` explícitamente si tenés plantillas inline en otros
archivos fuente.

### Plantillas Nombradas

Las plantillas también pueden ser definidas usando el método top-level
`template`:

``` ruby
template :layout do
  "%html\n  =yield\n"
end

template :index do
  '%div.titulo Hola Mundo!'
end

get '/' do
  haml :index
end
```

Si existe una plantilla con el nombre "layout", va a ser usada cada vez que
una plantilla es renderizada. Podés desactivar los layouts individualmente
pasando `:layout => false` o globalmente con
`set :haml, :layout => false`:

``` ruby
get '/' do
  haml :index, :layout => !request.xhr?
end
```

### Asociando Extensiones de Archivo

Para asociar una extensión de archivo con un motor de renderizado, usá
`Tilt.register`. Por ejemplo, si querés usar la extensión `tt` para
las plantillas Textile, podés hacer lo siguiente:

``` ruby
Tilt.register :tt, Tilt[:textile]
```

### Agregando Tu Propio Motor de Renderizado

Primero, registrá tu motor con Tilt, y después, creá tu método de renderizado:

``` ruby
Tilt.register :mipg, MiMotorParaPlantillaGenial

helpers do
  def mypg(*args) render(:mypg, *args) end
end

get '/' do
  mypg :index
end
```

Renderiza `./views/index.mypg`. Mirá https://github.com/rtomayko/tilt
para aprender más de Tilt.

## Filtros

Los filtros `before` son evaluados antes de cada petición dentro del mismo
contexto que las rutas. Pueden modificar la petición y la respuesta. Las
variables de instancia asignadas en los filtros son accesibles por las rutas y
las plantillas:

``` ruby
before do
  @nota = 'Hey!'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @nota #=> 'Hey!'
  params['splat'] #=> 'bar/baz'
end
```

Los filtros `after` son evaluados después de cada petición dentro del mismo
contexto y también pueden modificar la petición y la respuesta. Las variables
de instancia asignadas en los filtros `before` y en las rutas son accesibles por
los filtros `after`:

``` ruby
after do
  puts response.status
end
```

Nota: A menos que uses el método `body` en lugar de simplemente devolver un
string desde una ruta, el cuerpo de la respuesta no va a estar disponible en
un filtro after, debido a que todavía no se ha generado.

Los filtros aceptan un patrón opcional, que cuando está presente causa que los
mismos sean evaluados únicamente si el path de la petición coincide con ese
patrón:

``` ruby
before '/protegido/*' do
  autenticar!
end

after '/crear/:slug' do |slug|
  session[:ultimo_slug] = slug
end
```

Al igual que las rutas, los filtros también pueden aceptar condiciones:

``` ruby
before :agent => /Songbird/ do
  # ...
end

after '/blog/*', :host_name => 'ejemplo.com' do
  # ...
end
```

## Ayudantes

Usá el método top-level *helpers* para definir métodos ayudantes que
pueden ser utilizados dentro de los manejadores de rutas y las plantillas:

``` ruby
helpers do
  def bar(nombre)
    "#{nombre}bar"
  end
end

get '/:nombre' do
  bar(params['nombre'])
end
```

Por cuestiones organizativas, puede resultar conveniente organizar los métodos
ayudantes en distintos módulos:

``` ruby
module FooUtils
  def foo(nombre) "#{nombre}foo" end
end

module BarUtils
  def bar(nombre) "#{nombre}bar" end
end

helpers FooUtils, BarUtils
```

El efecto de utilizar *helpers* de esta manera es el mismo que resulta de
incluir los módulos en la clase de la aplicación.

### Usando Sesiones

Una sesión es usada para mantener el estado a través de distintas peticiones.
Cuando están activadas, proporciona un hash de sesión para cada sesión de usuario:

``` ruby
enable :sessions

get '/' do
  "valor = " << session[:valor].inspect
end

get '/:valor' do
  session[:valor] = params['valor']
end
```

Tené en cuenta que `enable :sessions` guarda todos los datos en una
cookie, lo cual no es siempre deseable (guardar muchos datos va a incrementar
el tráfico, por citar un ejemplo). Podés usar cualquier middleware Rack para
manejar sesiones, de la misma manera que usarías cualquier otro middleware,
pero con la salvedad de que *no* tenés que llamar a `enable :sessions`:

``` ruby
use Rack::Session::Pool, :expire_after => 2592000

get '/' do
  "valor = " << session[:valor].inspect
end

get '/:valor' do
  session[:valor] = params['valor']
end
```

Para incrementar la seguridad, los datos de la sesión almacenados en
la cookie son firmados con un secreto de sesión. Este secreto, es
generado aleatoriamente por Sinatra. De cualquier manera, hay que
tener en cuenta que cada vez que inicies la aplicación se va a generar
uno nuevo. Así, si querés que todas las instancias de tu aplicación
compartan un único secreto, tenés que definirlo vos:

``` ruby
set :session_secret, 'super secreto'
```

Si necesitás una configuración más específica, `sessions` acepta un
Hash con opciones:

``` ruby
set :sessions, :domain => 'foo.com'
```

### Interrupción

Para detener inmediatamente una petición dentro de un filtro o una ruta usá:

``` ruby
halt
```

También podés especificar el estado:

``` ruby
halt 410
```

O el cuerpo:

``` ruby
halt 'esto va a ser el cuerpo'
```

O los dos:

``` ruby
halt 401, 'salí de acá!'
```

Con cabeceras:

``` ruby
halt 402, { 'Content-Type' => 'text/plain' }, 'venganza'
```

Obviamente, es posible utilizar `halt` con una plantilla:

``` ruby
halt erb(:error)
```

### Paso

Una ruta puede pasarle el procesamiento a la siguiente ruta que coincida con
la petición usando `pass`:

``` ruby
get '/adivina/:quien' do
  pass unless params['quien'] == 'Franco'
  'Adivinaste!'
end

get '/adivina/*' do
  'Erraste!'
end
```

Se sale inmediatamente del bloque de la ruta y se le pasa el control a la
siguiente ruta que coincida. Si no coincide ninguna ruta, se devuelve 404.

### Ejecutando Otra Ruta

Cuando querés obtener el resultado de la llamada a una ruta, `pass` no te va a
servir. Para lograr esto, podés usar `call`:

``` ruby
get '/foo' do
  status, headers, body = call env.merge("PATH_INFO" => '/bar')
  [status, headers, body.map(&:upcase)]
end

get '/bar' do
  "bar"
end
```

Notá que en el ejemplo anterior, es conveniente mover `"bar"` a un
helper, y llamarlo desde `/foo` y `/bar`. Así, vas a simplificar
las pruebas y a mejorar el rendimiento.

Si querés que la petición se envíe a la misma instancia de la aplicación en
lugar de otra, usá `call!` en lugar de `call`.

En la especificación de Rack podés encontrar más información sobre
`call`.

### Asignando el Código de Estado, los Encabezados y el Cuerpo de una Respuesta

Es posible, y se recomienda, asignar el código de estado y el cuerpo de una
respuesta con el valor de retorno de una ruta. De cualquier manera, en varios
escenarios, puede que sea conveniente asignar el cuerpo en un punto arbitrario
del flujo de ejecución con el método `body`. A partir de ahí, podés usar ese
mismo método para acceder al cuerpo de la respuesta:

``` ruby
get '/foo' do
  body "bar"
end

after do
  puts body
end
```

También es posible pasarle un bloque a `body`, que será ejecutado por el Rack
handler (podés usar esto para implementar streaming, mirá "Valores de retorno").

De manera similar, también podés asignar el código de estado y encabezados:

``` ruby
get '/foo' do
  status 418
  headers \
    "Allow"   => "BREW, POST, GET, PROPFIND, WHEN",
    "Refresh" => "Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt"
  body "I'm a tea pot!"
end
```

También, al igual que `body`, tanto `status` como `headers` pueden utilizarse
para obtener sus valores cuando no se les pasa argumentos.

### Streaming De Respuestas

A veces vas a querer empezar a enviar la respuesta a pesar de que todavía no
terminaste de generar su cuerpo. También es posible que, en algunos casos,
quieras seguir enviando información hasta que el cliente cierre la conexión.
Cuando esto ocurra, el helper `stream` te va a ser de gran ayuda:

``` ruby
get '/' do
  stream do |out|
    out << "Esto va a ser legen -\n"
    sleep 0.5
    out << " (esperalo) \n"
    sleep 1
    out << "- dario!\n"
  end
end
```

Podés implementar APIs de streaming,
[Server-Sent Events](http://dev.w3.org/html5/eventsource/) y puede ser usado
como base para [WebSockets](http://es.wikipedia.org/wiki/WebSockets). También
puede ser usado para incrementar el throughput si solo una parte del contenido
depende de un recurso lento.

Hay que tener en cuenta que el comportamiento del streaming, especialmente el
número de peticiones concurrentes, depende del servidor web utilizado para
alojar la aplicación. Puede que algunos servidores, como es el caso de
WEBRick, no soporten streaming directamente, así el cuerpo de la respuesta será
enviado completamente de una vez cuando el bloque pasado a `stream` finalice su
ejecución. Si estás usando Shotgun, el streaming no va a funcionar.

Cuando se pasa `keep_open` como parámetro, no se va a enviar el mensaje
`close` al objeto de stream. Queda en vos cerrarlo en el punto de ejecución
que quieras. Nuevamente, hay que tener en cuenta que este comportamiento es
posible solo en servidores que soporten eventos, como Thin o Rainbows. El
resto de los servidores van a cerrar el stream de todos modos:

``` ruby
set :server, :thin
conexiones = []

get '/' do
  # mantenemos abierto el stream
  stream(:keep_open) { |salida| conexiones << salida }
end

post '/' do
  # escribimos a todos los streams abiertos
  conexiones.each { |salida| salida << params['mensaje'] << "\n" }
  "mensaje enviado"
end
```

### Log (Registro)

En el ámbito de la petición, el helper `logger` (registrador) expone
una instancia de `Logger`:

``` ruby
get '/' do
  logger.info "cargando datos"
  # ...
end
```

Este logger tiene en cuenta la configuración de logueo de tu Rack
handler. Si el logueo está desactivado, este método va a devolver un
objeto que se comporta como un logger pero que en realidad no hace
nada. Así, no vas a tener que preocuparte por esta situación.

Tené en cuenta que el logueo está habilitado por defecto únicamente
para `Sinatra::Application`. Si heredaste de
`Sinatra::Base`, probablemente quieras habilitarlo manualmente:

``` ruby
class MiApp < Sinatra::Base
  configure :production, :development do
    enable :logging
  end
end
```

Para evitar que se inicialice cualquier middleware de logging, configurá
`logging` a `nil`. Tené en cuenta que, cuando hagas esto, `logger` va a
devolver `nil`. Un caso común es cuando querés usar tu propio logger. Sinatra
va a usar lo que encuentre en `env['rack.logger']`.

### Tipos Mime

Cuando usás `send_file` o archivos estáticos tal vez tengas tipos mime
que Sinatra no entiende. Usá `mime_type` para registrarlos a través de la
extensión de archivo:

``` ruby
configure do
  mime_type :foo, 'text/foo'
end
```

También lo podés usar con el ayudante `content_type`:

``` ruby
get '/' do
  content_type :foo
  "foo foo foo"
end
```

### Generando URLs

Para generar URLs deberías usar el método `url`. Por ejemplo, en Haml:

``` ruby
%a{:href => url('/foo')} foo
```

Tiene en cuenta proxies inversos y encaminadores de Rack, si están presentes.

Este método también puede invocarse mediante su alias `to` (mirá un ejemplo
a continuación).

### Redirección del Navegador

Podés redireccionar al navegador con el método `redirect`:

``` ruby
get '/foo' do
  redirect to('/bar')
end
```

Cualquier parámetro adicional se utiliza de la misma manera que los argumentos
pasados a `halt`:

``` ruby
redirect to('/bar'), 303
redirect 'http://google.com', 'te confundiste de lugar, compañero'
```

También podés redireccionar fácilmente de vuelta hacia la página desde donde
vino el usuario con `redirect back`:

``` ruby
get '/foo' do
  "<a href='/bar'>hacer algo</a>"
end

get '/bar' do
  hacer_algo
  redirect back
end
```

Para pasar argumentos con una redirección, podés agregarlos a la cadena de
búsqueda:

``` ruby
redirect to('/bar?suma=42')
```

O usar una sesión:

``` ruby
enable :sessions

get '/foo' do
  session[:secreto] = 'foo'
  redirect to('/bar')
end

get '/bar' do
  session[:secreto]
end
```

### Cache Control

Asignar tus encabezados correctamente es el cimiento para realizar un cacheo
HTTP correcto.

Podés asignar el encabezado Cache-Control fácilmente:

``` ruby
get '/' do
  cache_control :public
  "cachealo!"
end
```

Pro tip: configurar el cacheo en un filtro `before`:

``` ruby
before do
  cache_control :public, :must_revalidate, :max_age => 60
end
```

Si estás usando el helper `expires` para definir el encabezado correspondiente,
`Cache-Control` se va a definir automáticamente:

``` ruby
before do
  expires 500, :public, :must_revalidate
end
```

Para usar cachés adecuadamente, deberías considerar usar `etag` o
`last_modified`. Es recomendable que llames a estos asistentes *antes* de hacer
cualquier trabajo pesado, ya que van a enviar la respuesta inmediatamente si
el cliente ya tiene la versión actual en su caché:

``` ruby
get '/articulo/:id' do
  @articulo = Articulo.find params['id']
  last_modified @articulo.updated_at
  etag @articulo.sha1
  erb :articulo
end
```

También es posible usar una
[weak ETag](http://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation):

``` ruby
etag @articulo.sha1, :weak
```

Estos helpers no van a cachear nada por vos, sino que van a facilitar la
información necesaria para poder hacerlo. Si estás buscando soluciones rápidas
de cacheo con proxys reversos, mirá
[rack-cache](https://github.com/rtomayko/rack-cache):

``` ruby
require "rack/cache"
require "sinatra"

use Rack::Cache

get '/' do
  cache_control :public, :max_age => 36000
  sleep 5
  "hola"
end
```

Usá la configuración `:static_cache_control` para agregar el encabezado
`Cache-Control` a archivos estáticos (ver la sección de configuración
para más detalles).

De acuerdo con la RFC 2616 tu aplicación debería comportarse diferente si a las
cabeceras If-Match o If-None-Match se le asigna el valor `*` cuando el
recurso solicitado ya existe. Sinatra asume para peticiones seguras (como get)
y potentes (como put) que el recurso existe, mientras que para el resto
(como post) asume que no. Podés cambiar este comportamiento con la opción
`:new_resource`:

``` ruby
get '/crear' do
  etag '', :new_resource => true
  Articulo.create
  erb :nuevo_articulo
end
```

Si querés seguir usando una weak ETag, indicalo con la opción `:kind`:

``` ruby
etag '', :new_resource => true, :kind => :weak
```

### Enviando Archivos

Para enviar archivos, podés usar el método `send_file`:

``` ruby
get '/' do
  send_file 'foo.png'
end
```

Además acepta un par de opciones:

``` ruby
send_file 'foo.png', :type => :jpg
```

Estas opciones son:

[filename]
  nombre del archivo devuelto, por defecto es el nombre real del archivo.

[last_modified]
  valor para el encabezado Last-Modified, por defecto toma el mtime del archivo.

[type]
  el content type que se va a utilizar, si no está presente se intenta adivinar
  a partir de la extensión del archivo.

[disposition]
  se utiliza para el encabezado Content-Disposition, y puede tomar alguno de los
  siguientes valores: `nil` (por defecto), `:attachment` e
  `:inline`

[length]
  encabezado Content-Length, por defecto toma el tamaño del archivo.

[status]
  código de estado devuelto. Resulta útil al enviar un archivo estático como una
  página de error.

Si el Rack handler lo soporta, se intentará no transmitir directamente desde el
proceso de Ruby. Si usás este método, Sinatra se va a encargar automáticamente de las
peticiones de rango.

### Accediendo al objeto de la petición

El objeto de la petición entrante puede ser accedido desde el nivel de la
petición (filtros, rutas y manejadores de errores) a través del método
`request`:

``` ruby
# app corriendo en http://ejemplo.com/ejemplo
get '/foo' do
  t = %w[text/css text/html application/javascript]
  request.accept              # ['text/html', '*/*']
  request.accept? 'text/xml'  # true
  request.preferred_type(t)   # 'text/html'
  request.body                # cuerpo de la petición enviado por el cliente (ver más abajo)
  request.scheme              # "http"
  request.script_name         # "/ejemplo"
  request.path_info           # "/foo"
  request.port                # 80
  request.request_method      # "GET"
  request.query_string        # ""
  request.content_length      # longitud de request.body
  request.media_type          # tipo de medio de request.body
  request.host                # "ejemplo.com"
  request.get?                # true (hay métodos análogos para los otros verbos)
  request.form_data?          # false
  request["UNA_CABECERA"]     # valor de la cabecera UNA_CABECERA
  request.referrer            # la referencia del cliente o '/'
  request.user_agent          # user agent (usado por la condición :agent)
  request.cookies             # hash de las cookies del navegador
  request.xhr?                # es una petición ajax?
  request.url                 # "http://ejemplo.com/ejemplo/foo"
  request.path                # "/ejemplo/foo"
  request.ip                  # dirección IP del cliente
  request.secure?             # false (sería true sobre ssl)
  request.forwarded?          # true (si se está corriendo atrás de un proxy reverso)
  requuest.env                # hash de entorno directamente entregado por Rack
end
```

Algunas opciones, como `script_name` o `path_info` pueden
también ser escritas:

``` ruby
before { request.path_info = "/" }

get "/" do
  "todas las peticiones llegan acá"
end
```

El objeto `request.body` es una instancia de IO o StringIO:

``` ruby
post "/api" do
  request.body.rewind  # en caso de que alguien ya lo haya leído
  datos = JSON.parse request.body.read
  "Hola #{datos['nombre']}!"
end
```

### Archivos Adjuntos

Podés usar el helper `attachment` para indicarle al navegador que
almacene la respuesta en el disco en lugar de mostrarla en pantalla:

``` ruby
get '/' do
  attachment
  "guardalo!"
end
```

También podés pasarle un nombre de archivo:

``` ruby
get '/' do
  attachment "info.txt"
  "guardalo!"
end
```

### Fecha y Hora

Sinatra pone a tu disposición el helper `time_for`, que genera un objeto `Time`
a partir del valor que recibe como argumento. Este valor puede ser un
`String`, pero también es capaz de convertir objetos `DateTime`, `Date` y de
otras clases similares:

``` ruby
get '/' do
  pass if Time.now > time_for('Dec 23, 2012')
  "todavía hay tiempo"
end
```

Este método es usado internamente por métodos como `expires` y `last_modified`,
entre otros. Por lo tanto, es posible extender el comportamiento de estos
métodos sobreescribiendo `time_for` en tu aplicación:

``` ruby
helpers do
  def time_for(value)
    case value
    when :ayer then Time.now - 24*60*60
    when :mañana then Time.now + 24*60*60
    else super
    end
  end
end

get '/' do
  last_modified :ayer
  expires :mañana
  "hola"
end
```

### Buscando los Archivos de las Plantillas

El helper `find_template` se utiliza para encontrar los archivos de las
plantillas que se van a renderizar:

``` ruby
find_template settings.views, 'foo', Tilt[:haml] do |archivo|
  puts "podría ser #{archivo}"
end
```

Si bien esto no es muy útil, lo interesante es que podés sobreescribir este
método, y así enganchar tu propio mecanismo de búsqueda. Por ejemplo, para
poder utilizar más de un directorio de vistas:

``` ruby
set :views, ['vistas', 'plantillas']

helpers do
  def find_template(views, name, engine, &block)
    Array(views).each { |v| super(v, name, engine, &block) }
  end
end
```

Otro ejemplo consiste en usar directorios diferentes para los distintos motores
de renderizado:

``` ruby
set :views, :sass => 'vistas/sass', :haml => 'plantillas', :defecto => 'vistas'

helpers do
  def find_template(views, name, engine, &block)
    _, folder = views.detect { |k,v| engine == Tilt[k] }
    folder ||= views[:defecto]
    super(folder, name, engine, &block)
  end
end
```

¡Es muy fácil convertir estos ejemplos en una extensión y compartirla!

Notá que `find_template` no verifica si un archivo existe realmente, sino
que llama al bloque que recibe para cada path posible. Esto no representa un
problema de rendimiento debido a que `render` va a usar `break` ni bien
encuentre un archivo que exista. Además, las ubicaciones de las plantillas (y
su contenido) se cachean cuando no estás en el modo de desarrollo. Es bueno
tener en cuenta lo anterior si escribís un método extraño.

## Configuración

Ejecutar una vez, en el inicio, en cualquier entorno:

``` ruby
configure do
  # asignando una opción
  set :opcion, 'valor'

  # asignando varias opciones
  set :a => 1, :b => 2

  # atajo para `set :opcion, true`
  enable :opcion

  # atajo para `set :opcion, false`
  disable :opcion

  # también podés tener configuraciones dinámicas usando bloques
  set(:css_dir) { File.join(views, 'css') }
end
```

Ejecutar únicamente cuando el entorno (la variable de entorno RACK_ENV) es
`:production`:

``` ruby
configure :production do
  ...
end
```

Ejecutar cuando el entorno es `:production` o `:test`:

``` ruby
configure :production, :test do
  ...
end
```

Podés acceder a estas opciones utilizando el método `settings`:

``` ruby
configure do
  set :foo, 'bar'
end

get '/' do
  settings.foo? # => true
  settings.foo  # => 'bar'
  ...
end
```

### Configurando la Protección de Ataques

Sinatra usa [Rack::Protection](https://github.com/rkh/rack-protection#readme)
para defender a tu aplicación de los ataques más comunes. Si por algún motivo,
querés desactivar esta funcionalidad, podés hacerlo como se indica a
continuación (ten en cuenta que tu aplicación va a quedar expuesta a un
montón de vulnerabilidades bien conocidas):

``` ruby
disable :protection
```

También es posible desactivar una única capa de defensa:

``` ruby
set :protection, :except => :path_traversal
```

O varias:

``` ruby
set :protection, :except => [:path_traversal, :session_hijacking]
```

### Configuraciones Disponibles

<dl>
  <dt>absolute_redirects</dt>
  <dd>
    Si está deshabilitada, Sinatra va a permitir
    redirecciones relativas, sin embargo, como consecuencia
    de esto, va a dejar de cumplir con el RFC 2616 (HTTP
    1.1), que solamente permite redirecciones absolutas.

    Activalo si tu apliación está corriendo atrás de un proxy
    reverso que no se ha configurado adecuadamente. Notá que
    el helper <tt>url</tt> va a seguir produciendo URLs absolutas, a
    menos que le pasés <tt>false</tt> como segundo parámetro.

    Deshabilitada por defecto.
  </dd>

  <dt>add_charset</dt>
  <dd>
    Tipos mime a los que el helper <tt>content_type</tt> les
    añade automáticamente el charset.

    En general, no deberías asignar directamente esta opción,
    sino añadirle los charsets que quieras:
    <tt>settings.add_charset &lt;&lt; "application/foobar"</tt>
  </dd>

  <dt>app_file</dt>
  <dd>
    Path del archivo principal de la aplicación, se utiliza
    para detectar la raíz del proyecto, el directorio de las
    vistas y el público, así como las plantillas inline.
  </dd>

  <dt>bind</dt>
  <dd>
    Dirección IP que utilizará el servidor integrado (por
    defecto: 0.0.0.0).
  </dd>

  <dt>default_encoding</dt>
  <dd>
    Encoding utilizado cuando el mismo se desconoce (por
    defecto <tt>"utf-8"</tt>).
  </dd>

  <dt>dump_errors</dt>
  <dd>
    Mostrar errores en el log.
  </dd>

  <dt>environment</dt>
  <dd>
    Entorno actual, por defecto toma el valor de
    <tt>ENV['RACK_ENV']</tt>, o <tt>"development"</tt> si no
    está disponible.
  </dd>

  <dt>logging</dt>
  <dd>
    Define si se utiliza el logger.
  </dd>

  <dt>lock</dt>
  <dd>
    Coloca un lock alrededor de cada petición, procesando
    solamente una por proceso.

    Habilitá esta opción si tu aplicación no es thread-safe.
    Se encuentra deshabilitada por defecto.
  </dd>

  <dt>method_override</dt>
  <dd>
    Utiliza el parámetro <tt>_method</tt> para permtir
    formularios put/delete en navegadores que no los
    soportan.
  </dd>

  <dt>port</dt>
  <dd>
    Puerto en el que escuchará el servidor integrado.
  </dd>

  <dt>prefixed_redirects</dt>
  <dd>
    Define si inserta <tt>request.script_name</tt> en las
    redirecciones cuando no se proporciona un path absoluto.
    De esta manera, cuando está habilitada,
    <tt>redirect '/foo'</tt> se comporta de la misma manera
    que <tt>redirect to('/foo')</tt>. Se encuentra
    deshabilitada por defecto.
  </dd>

  <dt>protection</dt>
  <dd>
    Define si deben activarse las protecciones para los
    ataques web más comunes. Para más detalles mirá la
    sección sobre la configuración de protección de ataques
    más arriba.
  </dd>

  <dt>public_dir</dt>
  <dd>
    Alias para <tt>public_folder</tt>, que se encuentra a
    continuación.
  </dd>

  <dt>public_folder</dt>
  <dd>
    Lugar del directorio desde donde se sirven los archivos
    públicos. Solo se utiliza cuando se sirven archivos
    estáticos (ver la opción <tt>static</tt>). Si no
    está presente, se infiere del valor de la opción
    <tt>app_file</tt>.
  </dd>

  <dt>reload_templates</dt>
  <dd>
    Define si se recargan las plantillas entre peticiones.

    Se encuentra activado en el entorno de desarrollo.
  </dd>

  <dt>root</dt>
  <dd>
    Lugar del directorio raíz del proyecto. Si no está
    presente, se infiere del valor de la opción
    <tt>app_file</tt>.
  </dd>

  <dt>raise_errors</dt>
  <dd>
    Elevar excepciones (detiene la aplicación). Se
    encuentra activada por defecto cuando el valor de
    <tt>environment</tt>  es <tt>"test"</tt>. En caso
    contrario estará desactivada.
  </dd>

  <dt>run</dt>
  <dd>
    Cuando está habilitada, Sinatra se va a encargar de
    iniciar el servidor web, no la habilites cuando estés
    usando rackup o algún otro medio.
  </dd>

  <dt>running</dt>
  <dd>
    Indica si el servidor integrado está ejecutándose, ¡no
    cambiés esta configuración!.
  </dd>

  <dt>server</dt>
  <dd>
    Servidor, o lista de servidores, para usar como servidor
    integrado. Por defecto: <tt>['thin', 'mongrel', 'webrick']</tt>,
    el orden establece la prioridad.
  </dd>

  <dt>sessions</dt>
  <dd>
    Habilita el soporte de sesiones basadas en cookies a
    través de <tt>Rack::Session::Cookie</tt>. Ver la
    sección 'Usando Sesiones' para más información.
  </dd>

  <dt>show_exceptions</dt>
  <dd>
    Muestra un stack trace en el navegador cuando ocurre una
    excepción. Se encuentra activada por defecto cuando el
    valor de <tt>environment</tt> es <tt>"development"</tt>.
    En caso contrario estará desactivada.
  </dd>

  <dt>static</dt>
  <dd>
    Define si Sinatra debe encargarse de servir archivos
    estáticos.

    Deshabilitala cuando uses un servidor capaz de
    hacerlo por sí solo, porque mejorará el
    rendimiento. Se encuentra habilitada por
    defecto en el estilo clásico y desactivado en el
    el modular.
  </dd>

  <dt>static_cache_control</dt>
  <dd>
    Cuando Sinatra está sirviendo archivos estáticos, y
    esta opción está habilitada, les va a agregar encabezados
    <tt>Cache-Control</tt> a las respuestas. Para esto
    utiliza el helper <tt>cache_control</tt>. Se encuentra
    deshabilitada por defecto. Notar que es necesario
    utilizar un array cuando se asignan múltiples valores:
    <tt>set :static_cache_control, [:public, :max_age => 300]</tt>.
  </dd>

  <dt>views</dt>
  <dd>
    Path del directorio de las vistas. Si no está presente,
    se infiere del valor de la opción <tt>app_file</tt>.
  </dd>
</dl>

## Entornos

Existen tres entornos (`environments`) predefinidos: `development`,
`production` y `test`. El entorno por defecto es
`development` y tiene algunas particularidades:

* Se recargan las plantillas entre una petición y la siguiente, a diferencia
de `production` y `test`, donde se cachean.
* Se instalan manejadores de errores `not_found` y `error`
especiales que muestran un stack trace en el navegador cuando son disparados.

Para utilizar alguno de los otros entornos puede asignarse el valor
correspondiente a la variable de entorno `RACK_ENV`, o bien utilizar la opción
`-e` al ejecutar la aplicación:

``` shell
ruby mi_app.rb -e <ENTORNO>
```

Los métodos `development?`, `test?` y `production?` te permiten conocer el
entorno actual.

## Manejo de Errores

Los manejadores de errores se ejecutan dentro del mismo contexto que las rutas
y los filtros `before`, lo que significa que podés usar, por ejemplo,
`haml`, `erb`, `halt`, etc.

### No encontrado <em>(Not Found)</em>

Cuando se eleva una excepción `Sinatra::NotFound`, o el código de
estado de la respuesta es 404, el manejador `not_found` es invocado:

``` ruby
not_found do
  'No existo'
end
```

### Error

El manejador `error` es invocado cada vez que una excepción es elevada
desde un bloque de ruta o un filtro. El objeto de la excepción se puede
obtener de la variable Rack `sinatra.error`:

``` ruby
error do
  'Disculpá, ocurrió un error horrible - ' + env['sinatra.error'].message
end
```

Errores personalizados:

``` ruby
error MiErrorPersonalizado do
  'Lo que pasó fue...' + env['sinatra.error'].message
end
```

Entonces, si pasa esto:

``` ruby
get '/' do
  raise MiErrorPersonalizado, 'algo malo'
end
```

Obtenés esto:

  Lo que pasó fue... algo malo

También, podés instalar un manejador de errores para un código de estado:

``` ruby
error 403 do
  'Acceso prohibido'
end

get '/secreto' do
  403
end
```

O un rango:

``` ruby
error 400..510 do
  'Boom'
end
```

Sinatra instala manejadores `not_found` y `error` especiales
cuando se ejecuta dentro del entorno de desarrollo "development".

## Rack Middleware

Sinatra corre sobre [Rack](http://rack.github.io/), una interfaz minimalista
que es un estándar para frameworks webs escritos en Ruby. Una de las
características más interesantes de Rack para los desarrolladores de aplicaciones
es el soporte de "middleware" -- componentes que se ubican entre el servidor y
tu aplicación, supervisando y/o manipulando la petición/respuesta HTTP para
proporcionar varios tipos de funcionalidades comunes.

Sinatra hace muy sencillo construir tuberías de Rack middleware a través del
método top-level `use`:

``` ruby
require 'sinatra'
require 'mi_middleware_personalizado'

use Rack::Lint
use MiMiddlewarePersonalizado

get '/hola' do
  'Hola Mundo'
end
```

La semántica de `use` es idéntica a la definida para el DSL
Rack::Builder[http://rubydoc.info/github/rack/rack/master/Rack/Builder] (más
frecuentemente usado en archivos rackup). Por ejemplo, el método `use`
acepta argumentos múltiples/variables así como bloques:

``` ruby
use Rack::Auth::Basic do |nombre_de_usuario, password|
  nombre_de_usuario == 'admin' && password == 'secreto'
end
```

Rack es distribuido con una variedad de middleware estándar para logging,
debugging, enrutamiento URL, autenticación y manejo de sesiones. Sinatra
usa muchos de estos componentes automáticamente de acuerdo a su configuración
para que usualmente no tengas que usarlas (con `use`) explícitamente.

Podés encontrar middleware útil en
[rack](https://github.com/rack/rack/tree/master/lib/rack),
[rack-contrib](https://github.com/rack/rack-contrib#readme),
o en la [Rack wiki](https://github.com/rack/rack/wiki/List-of-Middleware).

## Pruebas

Las pruebas para las aplicaciones Sinatra pueden ser escritas utilizando
cualquier framework o librería de pruebas basada en Rack. Se recomienda usar
[Rack::Test](http://rdoc.info/github/brynary/rack-test/master/frames):

``` ruby
require 'mi_app_sinatra'
require 'minitest/autorun'
require 'rack/test'

class MiAppTest < Minitest::Test
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_mi_defecto
    get '/'
    assert_equal 'Hola Mundo!', last_response.body
  end

  def test_con_parametros
    get '/saludar', :name => 'Franco'
    assert_equal 'Hola Frank!', last_response.body
  end

  def test_con_entorno_rack
    get '/', {}, 'HTTP_USER_AGENT' => 'Songbird'
    assert_equal "Estás usando Songbird!", last_response.body
  end
end
```

## Sinatra::Base - Middleware, Librerías, y Aplicaciones Modulares

Definir tu aplicación en el nivel superior funciona bien para micro-aplicaciones
pero trae inconvenientes considerables a la hora de construir componentes
reutilizables como Rack middleware, Rails metal, librerías simples con un
componente de servidor o incluso extensiones de Sinatra. El DSL de alto nivel
asume una configuración apropiada para micro-aplicaciones (por ejemplo, un
único archivo de aplicación, los directorios `./public` y
`./views`, logging, página con detalles de excepción, etc.). Ahí es
donde `Sinatra::Base` entra en el juego:

``` ruby
require 'sinatra/base'

class MiApp < Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Hola Mundo!'
  end
end
```

Las subclases de `Sinatra::Base` tienen disponibles exactamente los
mismos métodos que los provistos por el DSL de top-level. La mayoría de las
aplicaciones top-level se pueden convertir en componentes
`Sinatra::Base` con dos modificaciones:

* Tu archivo debe requerir `sinatra/base` en lugar de `sinatra`; de otra
  manera, todos los métodos del DSL de sinatra son importados dentro del
  espacio de nombres principal.
* Poné las rutas, manejadores de errores, filtros y opciones de tu aplicación
  en una subclase de `Sinatra::Base`.

`Sinatra::Base` es una pizarra en blanco. La mayoría de las opciones están
desactivadas por defecto, incluyendo el servidor incorporado. Mirá
[Opciones y Configuraciones](http://sinatra.github.com/configuration.html)
para detalles sobre las opciones disponibles y su comportamiento.

### Estilo Modular vs. Clásico

Contrariamente a la creencia popular, no hay nada de malo con el estilo clásico.
Si se ajusta a tu aplicación, no es necesario que la cambies a una modular.

La desventaja de usar el estilo clásico en lugar del modular consiste en que
solamente podés tener una aplicación Sinatra por proceso Ruby. Si tenés
planificado usar más, cambiá al estilo modular. Al mismo tiempo, ten en
cuenta que no hay ninguna razón por la cuál no puedas mezclar los estilos
clásico y modular.

A continuación se detallan las diferencias (sútiles) entre las configuraciones
de ambos estilos:

<table>
  <tr>
    <td>Configuración</td>
    <td>Clásica</td>
    <td>Modular</td>
  </tr>

  <tr>
    <td>app_file</td>
    <td>archivo que carga sinatra</td>
    <td>archivo con la subclase de Sinatra::Base</td>
  </tr>

  <tr>
    <td>run</td>
    <td>$0 == app_file</td>
    <td>false</td>
  </tr>

  <tr>
    <td>logging</td>
    <td>true</td>
    <td>false</td>
  </tr>

  <tr>
    <td>method_override</td>
    <td>true</td>
    <td>false</td>
  </tr>

  <tr>
    <td>inline_templates</td>
    <td>true</td>
    <td>false</td>
  </tr>

  <tr>
    <td>static</td>
    <td>true</td>
    <td>false</td>
  </tr>
</table>

### Sirviendo una Aplicación Modular

Las dos opciones más comunes para iniciar una aplicación modular son, iniciarla
activamente con `run!`:

``` ruby
# mi_app.rb
require 'sinatra/base'

class MiApp < Sinatra::Base
  # ... código de la app  ...

  # iniciar el servidor si el archivo fue ejecutado directamente
  run! if app_file == $0
end
```

Iniciar con:

``` shell
ruby mi_app.rb
```

O, con un archivo `config.ru`, que permite usar cualquier handler Rack:

``` ruby
# config.ru
require './mi_app'
run MiApp
```

Después ejecutar:

``` shell
rackup -p 4567
```

### Usando una Aplicación Clásica con un Archivo config.ru

Escribí el archivo de tu aplicación:

``` ruby
# app.rb
require 'sinatra'

get '/' do
  'Hola mundo!'
end
```

Y el `config.ru` correspondiente:

``` ruby
require './app'
run Sinatra::Application
```

### ¿Cuándo usar config.ru?

Indicadores de que probablemente querés usar `config.ru`:

* Querés realizar el deploy con un handler Rack distinto (Passenger, Unicorn,
  Heroku, ...).
* Querés usar más de una subclase de `Sinatra::Base`.
* Querés usar Sinatra únicamente para middleware, pero no como un endpoint.

<b>No hay necesidad de utilizar un archivo `config.ru` exclusivamente
porque tenés una aplicación modular, y no necesitás una aplicación modular para
iniciarla con `config.ru`.</b>

### Utilizando Sinatra como Middleware

Sinatra no solo es capaz de usar otro Rack middleware, sino que a su vez,
cualquier aplicación Sinatra puede ser agregada delante de un endpoint Rack
como middleware. Este endpoint puede ser otra aplicación Sinatra, o cualquier
aplicación basada en Rack (Rails/Ramaze/Camping/...):

``` ruby
require 'sinatra/base'

class PantallaDeLogin < Sinatra::Base
  enable :sessions

  get('/login') { haml :login }

  post('/login') do
    if params['nombre'] == 'admin' && params['password'] == 'admin'
      session['nombre_de_usuario'] = params['nombre']
    else
      redirect '/login'
    end
  end
end

class MiApp < Sinatra::Base
  # el middleware se ejecutará antes que los filtros
  use PantallaDeLogin

  before do
    unless session['nombre_de_usuario']
      halt "Acceso denegado, por favor <a href='/login'>iniciá sesión</a>."
    end
  end

  get('/') { "Hola #{session['nombre_de_usuario']}." }
end
```

### Creación Dinámica de Aplicaciones

Puede que en algunas ocasiones quieras crear nuevas aplicaciones en
tiempo de ejecución sin tener que asignarlas a una constante. Para
esto tenés `Sinatra.new`:

``` ruby
require 'sinatra/base'
mi_app = Sinatra.new { get('/') { "hola" } }
mi_app.run!
```

Acepta como argumento opcional una aplicación desde la que se
heredará:

``` ruby
# config.ru
require 'sinatra/base'

controller = Sinatra.new do
  enable :logging
  helpers MisHelpers
end

map('/a') do
  run Sinatra.new(controller) { get('/') { 'a' } }
end

map('/b') do
  run Sinatra.new(controller) { get('/') { 'b' } }
end
```

Construir aplicaciones de esta forma resulta especialmente útil para
testear extensiones Sinatra o para usar Sinatra en tus librerías.

Por otro lado, hace extremadamente sencillo usar Sinatra como
middleware:

``` ruby
require 'sinatra/base'

use Sinatra do
  get('/') { ... }
end

run ProyectoRails::Application
```

## Ámbitos y Ligaduras

El ámbito en el que te encontrás determina que métodos y variables están
disponibles.

### Ámbito de Aplicación/Clase

Cada aplicación Sinatra es una subclase de `Sinatra::Base`. Si estás
usando el DSL de top-level (`require 'sinatra'`), entonces esta clase es
`Sinatra::Application`, de otra manera es la subclase que creaste
explícitamente. Al nivel de la clase tenés métodos como `get` o `before`, pero
no podés acceder a los objetos `request` o `session`, ya que hay una única
clase de la aplicación para todas las peticiones.

Las opciones creadas utilizando `set` son métodos al nivel de la clase:

``` ruby
class MiApp < Sinatra::Base
  # Ey, estoy en el ámbito de la aplicación!
  set :foo, 42
  foo # => 42

  get '/foo' do
    # Hey, ya no estoy en el ámbito de la aplicación!
  end
end
```

Tenés la ligadura al ámbito de la aplicación dentro de:

* El cuerpo de la clase de tu aplicación
* Métodos definidos por extensiones
* El bloque pasado a `helpers`
* Procs/bloques usados como el valor para `set`

Este ámbito puede alcanzarse de las siguientes maneras:

* A través del objeto pasado a los bloques de configuración (`configure { |c| ...}`)
* Llamando a `settings` desde dentro del ámbito de la petición

### Ámbito de Petición/Instancia

Para cada petición entrante, una nueva instancia de la clase de tu aplicación
es creada y todos los bloques de rutas son ejecutados en ese ámbito. Desde este
ámbito podés acceder a los objetos `request` y `session` o llamar a los métodos
de renderización como `erb` o `haml`. Podés acceder al ámbito de la aplicación
desde el ámbito de la petición utilizando `settings`:

``` ruby
class MiApp < Sinatra::Base
  # Ey, estoy en el ámbito de la aplicación!
  get '/definir_ruta/:nombre' do
    # Ámbito de petición para '/definir_ruta/:nombre'
    @valor = 42

    settings.get("/#{params['nombre']}") do
      # Ámbito de petición para "/#{params['nombre']}"
      @valor # => nil (no es la misma petición)
    end

    "Ruta definida!"
  end
end
```

Tenés la ligadura al ámbito de la petición dentro de:

* bloques pasados a get/head/post/put/delete/options
* filtros before/after
* métodos ayudantes
* plantillas/vistas

### Ámbito de Delegación

El ámbito de delegación solo reenvía métodos al ámbito de clase. De cualquier
manera, no se comporta 100% como el ámbito de clase porque no tenés la ligadura
de la clase: únicamente métodos marcados explícitamente para delegación están
disponibles y no compartís variables/estado con el ámbito de clase (léase:
tenés un `self` diferente). Podés agregar delegaciones de método llamando a
`Sinatra::Delegator.delegate :nombre_del_metodo`.

Tenés la ligadura al ámbito de delegación dentro de:

* La ligadura del top-level, si hiciste `require "sinatra"`
* Un objeto extendido con el mixin `Sinatra::Delegator`

Hechale un vistazo al código: acá está el
[Sinatra::Delegator mixin](https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/base.rb#L1609-1633)
que [extiende el objeto main](https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/main.rb#L28-30).

## Línea de Comandos

Las aplicaciones Sinatra pueden ser ejecutadas directamente:

``` shell
ruby miapp.rb [-h] [-x] [-e ENTORNO] [-p PUERTO] [-o HOST] [-s MANEJADOR]
```

Las opciones son:

```
-h # ayuda
-p # asigna el puerto (4567 es usado por defecto)
-o # asigna el host (0.0.0.0 es usado por defecto)
-e # asigna el entorno (development es usado por defecto)
-s # especifica el servidor/manejador rack (thin es usado por defecto)
-x # activa el mutex lock (está desactivado por defecto)
```

## Versiones de Ruby Soportadas

Las siguientes versiones de Ruby son soportadas oficialmente:

<dl>
  <dt>Ruby 1.8.7</dt>
  <dd>
    1.8.7 es soportado completamente. Sin embargo, si no hay nada que te lo
    prohiba, te recomendamos que uses 1.9.2 o cambies a JRuby o Rubinius. No se
    dejará de dar soporte a 1.8.7 hasta Sinatra 2.0 y Ruby 2.0, aunque si se
    libera la versión 1.8.8 de Ruby las cosas podrían llegar a cambiar. Sin
    embargo, que eso ocurra es muy poco probable, e incluso el caso de que lo
    haga, puede que se siga dando soporte a 1.8.7. <b>Hemos dejado de soportar
    Ruby 1.8.6.</b> Si querés ejecutar Sinatra sobre 1.8.6, podés utilizar la
    versión 1.2, pero ten en cuenta que una vez que Sinatra 1.4.0 sea liberado,
    ya no se corregirán errores por más que se reciban reportes de los mismos.
  </dd>

  <dt>Ruby 1.9.2</dt>
  <dd>
    1.9.2 es soportado y recomendado. No uses 1.9.2p0, porque se producen fallos
    de segmentación cuando se ejecuta Sinatra. El soporte se mantendrá al menos
    hasta que se libere la versión 1.9.4/2.0 de Ruby. El soporte para la última
    versión de la serie 1.9 se mantendrá mientras lo haga el equipo principal de Ruby.
  </dd>

  <dt>Ruby 1.9.3</dt>
  <dd>
    1.9.3 es soportado y recomendado. Ten en cuenta que el cambio a 1.9.3 desde
    una versión anterior va a invalidar todas las sesiones.
  </dd>

  <dt>Rubinius</dt>
  <dd>
    Rubinius es soportado oficialmente (Rubinius >= 1.2.4). Todo funciona
    correctamente, incluyendo los lenguajes de plantillas. La próxima versión,
    2.0, también es soportada, incluyendo el modo 1.9.
  </dd>

  <dt>JRuby</dt>
  <dd>
    JRuby es soportado oficialmente (JRuby >= 1.6.7). No se conocen problemas
    con librerías de plantillas de terceras partes. Sin embargo, si elegís usar
    JRuby, deberías examinar sus Rack handlers porque el servidor web Thin no es
    soportado completamente. El soporte de JRuby para extensiones C se encuentra
    en una etapa experimental, sin embargo, de momento, solamente RDiscount,
    Redcarpet, RedCloth y Yajl, así como Thin y Mongrel se ven afectadas.
  </dd>
</dl>

Siempre le prestamos atención a las nuevas versiones de Ruby.

Las siguientes implementaciones de Ruby no se encuentran soportadas
oficialmente. De cualquier manera, pueden ejecutar Sinatra:

* Versiones anteriores de JRuby y Rubinius
* Ruby Enterprise Edition
* MacRuby, Maglev e IronRuby
* Ruby 1.9.0 y 1.9.1 (pero no te recomendamos que los uses)

No ser soportada oficialmente, significa que si las cosas se rompen
ahí y no en una plataforma soportada, asumimos que no es nuestro problema sino
el suyo.

Nuestro servidor CI también se ejecuta sobre ruby-head (que será la próxima
versión 2.1.0) y la rama 1.9.4. Como están en movimiento constante, no podemos
garantizar nada. De todas formas, podés contar con que tanto 1.9.4-p0 como
2.1.0-p0 sea soportadas.

Sinatra debería funcionar en cualquier sistema operativo soportado por la
implementación de Ruby elegida.

En este momento, no vas a poder ejecutar Sinatra en Cardinal, SmallRuby,
BlueRuby o cualquier versión de Ruby anterior a 1.8.7.

## A la Vanguardia

Si querés usar el código de Sinatra más reciente, sentite libre de ejecutar
tu aplicación sobre la rama master, en general es bastante estable.

También liberamos prereleases de vez en cuando, así, podés hacer:

``` shell
gem install sinatra --pre
```

Para obtener algunas de las últimas características.

### Con Bundler

Esta es la manera recomendada para ejecutar tu aplicación sobre la última
versión de Sinatra usando [Bundler](http://gembundler.com/).

Primero, instalá Bundler si no lo hiciste todavía:

``` shell
gem install bundler
```

Después, en el directorio de tu proyecto, creá un archivo `Gemfile`:

``` ruby
source :rubygems
gem 'sinatra', :git => "git://github.com/sinatra/sinatra.git"

# otras dependencias
gem 'haml'                    # por ejemplo, si usás haml
gem 'activerecord', '~> 3.0'  # quizás también necesités ActiveRecord 3.x
```

Tené en cuenta que tenés que listar todas las dependencias directas de tu
aplicación. No es necesario listar las dependencias de Sinatra (Rack y Tilt)
porque Bundler las agrega directamente.

Ahora podés arrancar tu aplicación así:

``` shell
bundle exec ruby miapp.rb
```

### Con Git

Cloná el repositorio localmente y ejecutá tu aplicación, asegurándote que el
directorio `sinatra/lib` esté en el `$LOAD_PATH`:

``` shell
cd miapp
git clone git://github.com/sinatra/sinatra.git
ruby -Isinatra/lib miapp.rb
```

Para actualizar el código fuente de Sinatra en el futuro:

``` shell
cd miapp/sinatra
git pull
```

### Instalación Global

Podés construir la gem vos mismo:

``` shell
git clone git://github.com/sinatra/sinatra.git
cd sinatra
rake sinatra.gemspec
rake install
```

Si instalás tus gems como root, el último paso debería ser

``` shell
sudo rake install
```

## Versionado

Sinatra utiliza el [Versionado Semántico](http://semver.org/),
siguiendo las especificaciones SemVer y SemVerTag.

## Lecturas Recomendadas

* [Sito web del proyecto](http://www.sinatrarb.com/) - Documentación
  adicional, noticias, y enlaces a otros recursos.
* [Contribuyendo](http://www.sinatrarb.com/contributing) - ¿Encontraste un
  error?. ¿Necesitás ayuda?. ¿Tenés un parche?.
* [Seguimiento de problemas](http://github.com/sinatra/sinatra/issues)
* [Twitter](http://twitter.com/sinatra)
* [Lista de Correo](http://groups.google.com/group/sinatrarb/topics)
* [IRC: #sinatra](irc://chat.freenode.net/#sinatra) en http://freenode.net
* [Sinatra Book](https://github.com/sinatra/sinatra-book/) Tutorial (en inglés).
* [Sinatra Recipes](http://recipes.sinatrarb.com/) Recetas contribuidas
  por la comunidad (en inglés).
* Documentación de la API para la
  [última versión liberada](http://rubydoc.info/gems/sinatra) o para la
  [rama de desarrollo actual](http://rubydoc.info/github/sinatra/sinatra)
  en http://rubydoc.info/
* [Servidor de CI](http://travis-ci.org/sinatra/sinatra)
# Sinatra
*Attention : Ce document correspond à la traduction de la version anglaise et
il n'est peut être plus à jour.*

Sinatra est un [DSL](http://fr.wikipedia.org/wiki/Langage_dédié) pour
créer rapidement et facilement des applications web en Ruby :

``` ruby
# mon_application.rb
require 'sinatra'

get '/' do
  'Bonjour le monde !'
end
```

Installez la gem Sinatra :

``` shell
gem install sinatra
```

Puis lancez votre programme :

``` shell
ruby mon_application.rb
```

Le résultat est visible sur : http://localhost:4567

Il est recommandé d'exécuter également `gem install thin`, pour que
Sinatra utilise le server Thin quand il est disponible.

## Table des matières

* [Sinatra](#sinatra)
    * [Table des matières](#table-des-matières)
    * [Routes](#routes)
    * [Conditions](#conditions)
    * [Valeurs de retour](#valeurs-de-retour)
    * [Masques de route spécifiques](#masques-de-route-spécifiques)
    * [Fichiers statiques](#fichiers-statiques)
    * [Vues / Templates](#vues--templates)
        * [Templates littéraux](#templates-littéraux)
        * [Langages de template disponibles](#langages-de-template-disponibles)
            * [Templates Haml](#templates-haml)
            * [Templates Erb](#templates-erb)
            * [Templates Builder](#templates-builder)
            * [Templates Nokogiri](#templates-nokogiri)
            * [Templates Sass](#templates-sass)
            * [Templates SCSS](#templates-scss)
            * [Templates Less](#templates-less)
            * [Templates Liquid](#templates-liquid)
            * [Templates Markdown](#templates-markdown)
            * [Templates Textile](#templates-textile)
            * [Templates RDoc](#templates-rdoc)
            * [Templates Radius](#templates-radius)
            * [Templates Markaby](#templates-markaby)
            * [Templates RABL](#templates-rabl)
            * [Templates Slim](#templates-slim)
            * [Templates Creole](#templates-creole)
            * [Templates CoffeeScript](#templates-coffeescript)
            * [Templates Stylus](#templates-stylus)
            * [Templates Yajl](#templates-yajl)
            * [Templates WLang](#templates-wlang)
        * [Accéder aux variables dans un Template](#accéder-aux-variables-dans-un-template)
        * [Templates avec `yield` et layouts imbriqués](#templates-avec-yield-et-layouts-imbriqués)
        * [Templates dans le fichier source](#templates-dans-le-fichier-source)
        * [Templates nommés](#templates-nommés)
        * [Associer des extensions de fichier](#associer-des-extensions-de-fichier)
        * [Ajouter son propre moteur de rendu](#ajouter-son-propre-moteur-de-rendu)
    * [Filtres](#filtres)
    * [Helpers](#helpers)
        * [Utiliser les sessions](#utiliser-les-sessions)
        * [Halt](#halt)
        * [Passer](#passer)
        * [Déclencher une autre route](#déclencher-une-autre-route)
        * [Définir le corps, le code retour et les entêtes](#définir-le-corps-le-code-retour-et-les-entêtes)
        * [Faire du streaming](#faire-du-streaming)
        * [Journalisation (Logging)](#journalisation-logging)
        * [Types Mime](#types-mime)
        * [Former des URLs](#former-des-urls)
        * [Redirection du navigateur](#redirection-du-navigateur)
        * [Contrôle du cache](#contrôle-du-cache)
        * [Envoyer des fichiers](#envoyer-des-fichiers)
        * [Accéder à l'objet requête](#accéder-à-lobjet-requête)
        * [Fichiers joints](#fichiers-joints)
        * [Gérer Date et Time](#gérer-date-et-time)
        * [Chercher les fichiers de templates](#chercher-les-fichiers-de-templates)
    * [Configuration](#configuration)
        * [Se protéger des attaques](#se-protéger-des-attaques)
        * [Paramètres disponibles](#paramètres-disponibles)
    * [Environements](#environements)
    * [Gérer les erreurs](#gérer-les-erreurs)
        * [NotFound](#notfound)
        * [Error](#error)
    * [Les Middlewares Rack](#les-middlewares-rack)
    * [Tester](#tester)
    * [Sinatra::Base - Les Middlewares, Bibliothèques, et Applications Modulaires](#sinatrabase---les-middlewares-bibliothèques-et-applications-modulaires)
        * [Style modulaire vs. style classique](#style-modulaire-vs-style-classique)
        * [Servir une application modulaire](#servir-une-application-modulaire)
        * [Utiliser une application de style classique avec un fichier config.ru](#utiliser-une-application-de-style-classique-avec-un-fichier-configru)
        * [Quand utiliser un fichier config.ru ?](#quand-utiliser-un-fichier-configru-)
        * [Utiliser Sinatra comme Middleware](#utiliser-sinatra-comme-middleware)
        * [Création dynamique d'applications](#création-dynamique-dapplications)
    * [Contextes et Binding](#contextes-et-binding)
        * [Contexte de l'application/classe](#contexte-de-lapplicationclasse)
        * [Contexte de la requête/instance](#contexte-de-la-requêteinstance)
        * [Le contexte de délégation](#le-contexte-de-délégation)
    * [Ligne de commande](#ligne-de-commande)
    * [Configuration nécessaire](#configuration-nécessaire)
    * [Essuyer les plâtres](#essuyer-les-plâtres)
        * [Installer avec Bundler](#installer-avec-bundler)
        * [Faire un clone local](#faire-un-clone-local)
        * [Installer globalement](#installer-globalement)
    * [Versions](#versions)
    * [Mais encore](#mais-encore)

## Routes

Dans Sinatra, une route est une méthode HTTP couplée à un masque (pattern)
URL. Chaque route est associée à un bloc :

``` ruby
get '/' do
  .. montrer quelque chose ..
end

post '/' do
  .. créer quelque chose ..
end

put '/' do
  .. remplacer quelque chose ..
end

patch '/' do
  .. changer quelque chose ..
end

delete '/' do
  .. effacer quelque chose ..
end

options '/' do
  .. paramétrer quelque chose ..
end

link '/' do
  .. relier quelque chose ..
end

unlink '/' do
  .. séparer quelque chose ..
end
```

Les routes sont évaluées  dans l'ordre où elles ont été définies. La première
route qui correspond à la requête est appelée.

Les masques peuvent inclure des paramètres nommés, accessibles par
l'intermédiaire du hash `params` :

``` ruby
get '/bonjour/:nom' do
  # répond aux requêtes "GET /bonjour/foo" et "GET /bonjour/bar"
  # params['nom'] est 'foo' ou 'bar'
  "Bonjour #{params['nom']} !"
end
```

Vous pouvez aussi accéder aux paramètres nommés directement grâce aux
paramètres du bloc comme ceci :

``` ruby
get '/bonjour/:nom' do |n|
  # répond aux requêtes "GET /bonjour/foo" et "GET /bonjour/bar"
  # params['nom'] est 'foo' ou 'bar'
  # n contient params['nom']
  "Bonjour #{n} !"
end
```

Une route peut contenir un splat (caractère joker), accessible par
l'intermédiaire du tableau `params['splat']` :

``` ruby
get '/dire/*/a/*' do
  # répond à /dire/bonjour/a/monde
  params['splat'] # => ["bonjour", "monde"]
end

get '/telecharger/*.*' do
  # répond à /telecharger/chemin/vers/fichier.xml
  params['splat'] # => ["chemin/vers/fichier", "xml"]
end
```

Ou par l'intermédiaire des paramètres du bloc :

``` ruby
get '/telecharger/*.*' do |chemin, ext|
  [chemin, ext] # => ["path/to/file", "xml"]
end
```

Une route peut aussi être définie par une expression régulière :

``` ruby
get /\A\/bonjour\/([\w]+)\z/ do
  "Bonjour, #{params['captures'].first} !"
end
```

Là encore on peut utiliser les paramètres de bloc :

``` ruby
get %r{/bonjour/([\w]+)} do |c|
  "Bonjour, #{c} !"
end
```

Les routes peuvent aussi comporter des paramètres optionnels :

``` ruby
get '/posts.?:format?' do
  # répond à "GET /posts" et aussi à "GET /posts.json", "GET /posts.xml" etc...
end
```

Ainsi que des paramètres d'URL :

``` ruby
get '/posts' do
  # répond à "GET /posts?titre=foo&auteur=bar"
  titre = params['titre']
  auteur = params['auteur']
  # utilise les variables titre et auteur, ces paramètres d'URL sont optionnels pour la route /posts
end
```

A ce propos, à moins d'avoir désactivé la protection contre les attaques par
"path transversal" (voir plus loin), l'URL demandée peut avoir été modifiée
avant d'être comparée à vos routes.

## Conditions

Les routes peuvent définir toutes sortes de conditions, comme par exemple le
"user agent" :

``` ruby
get '/foo', :agent => /Songbird (\d\.\d)[\d\/]*?/ do
  "Vous utilisez Songbird version #{params['agent'][0]}"
end

get '/foo' do
  # Correspond à tous les autres navigateurs
end
```

Les autres conditions disponibles sont `host_name` et `provides` :

``` ruby
get '/', :host_name => /^admin\./ do
  "Zone Administrateur, Accès refusé !"
end

get '/', :provides => 'html' do
  haml :index
end

get '/', :provides => ['rss', 'atom', 'xml'] do
  builder :feed
end
```

Vous pouvez facilement définir vos propres conditions :

``` ruby
set(:probability) { |value| condition { rand <= value } }

get '/gagner_une_voiture', :probability => 0.1 do
  "Vous avez gagné !"
end

get '/gagner_une_voiture' do
  "Désolé, vous avez perdu."
end
```

Utilisez un splat (caractère joker) dans le cas d'une condition qui prend
plusieurs valeurs :

``` ruby
set(:auth) do |*roles|   # <- ici on utilise un splat
  condition do
    unless logged_in? && roles.any? {|role| current_user.in_role? role }
      redirect "/login/", 303
    end
  end
end

get "/mon/compte/", :auth => [:user, :admin] do
  "Informations sur votre compte"
end

get "/reserve/aux/admins/", :auth => :admin do
  "Seuls les administrateurs sont acceptés ici !"
end
```

## Valeurs de retour

La valeur renvoyée par le bloc correspondant à une route constitue le corps de
la réponse qui sera transmise au client HTTP ou du moins au prochain middleware
dans la pile Rack. Le plus souvent, il s'agit d'une chaîne de caractères,
comme dans les exemples précédents. Cependant, d'autres valeurs sont
acceptées.

Vous pouvez renvoyer n'importe quel objet qu'il s'agisse d'une réponse Rack
valide, d'un corps de réponse Rack ou d'un code statut HTTP :

* Un tableau de 3 éléments : `[code statut (Fixnum), entêtes (Hash), corps
  de la réponse (répondant à #each)]`
* Un tableau de 2 élements : `[code statut (Fixnum), corps de la réponse
  (répondant à #each)]`
* Un objet qui répond à `#each` et qui ne transmet que des chaînes de
  caractères au bloc fourni
* Un Fixnum représentant le code statut

Avec cela, on peut facilement implémenter un streaming par exemple :

``` ruby
class Stream
  def each
    100.times { |i| yield "#{i}\n" }
  end
end

get('/') { Stream.new }
```

Vous pouvez aussi utiliser le helper `stream` (présenté un peu plus loin) pour
éviter la surcharge et intégrer le traitement relatif au streaming dans le bloc
de code de la route.

## Masques de route spécifiques

Comme cela a été vu auparavant, Sinatra offre la possibilité d'utiliser des
masques sous forme de chaines de caractères ou des expressions régulières
pour définir les routes. Mais il est possible de faire bien plus. Vous pouvez
facilement définir vos propres masques :

``` ruby
class MasqueToutSauf
  Masque = Struct.new(:captures)

  def initialize(except)
    @except   = except
    @captures = Masque.new([])
  end

  def match(str)
    @caputres unless @except === str
  end
end

def tout_sauf(masque)
  MasqueToutSauf.new(masque)
end

get tout_sauf("/index") do
  # ...
end
```

Notez que l'exemple ci-dessus est bien trop compliqué et que le même résultat
peut être obtenu avec :

``` ruby
get // do
  pass if request.path_info == "/index"
  # ...
end
```

Ou bien en utilisant la forme négative :

``` ruby
get %r{^(?!/index$)} do
  # ...
end
```

## Fichiers statiques

Les fichiers du dossier `./public` sont servis de façon statique. Vous
avez la possibilité d'utiliser un autre répertoire en définissant le paramètre
`:public_folder` :

``` ruby
set :public_folder, File.dirname(__FILE__) + '/statique'
```

Notez que le nom du dossier public n'apparait pas dans l'URL. Le fichier
`./public/css/style.css` sera appelé via l'URL :
`http://exemple.com/css/style.css`.

Utilisez le paramètre `:static_cache_control` pour ajouter l'information
d'en-tête <tt>Cache-Control</tt> (voir plus loin).

## Vues / Templates

Chaqie langage de template est disponible via sa propre méthode de rendu,
lesquelles renvoient tout simplement une chaîne de caractères.

``` ruby
get '/' do
  erb :index
end
```

Ceci effectue le rendu de la vue `views/index.erb`.

Plutôt que d'utiliser le nom d'un template, vous pouvez directement passer
le contenu du template :

``` ruby
get '/' do
  code = "<%= Time.now %>"
  erb code
end
```

Les méthodes de templates acceptent un second paramètre, un hash d'options :

``` ruby
get '/' do
  erb :index, :layout => :post
end
```

Ceci effectuera le rendu de la vue `views/index.erb` en l'intégrant
au *layout* `views/post.erb` (les vues Erb sont intégrées par défaut
au *layout* `views/layout.erb` quand ce fichier existe).

Toute option que Sinatra ne comprend pas sera passée au moteur de rendu :

``` ruby
get '/' do
  haml :index, :format => :html5
end
```

Vous pouvez également définir des options par langage de template de façon
générale :

``` ruby
set :haml, :format => html5

get '/' do
  haml :index
end
```

Les options passées à la méthode de rendu prennent le pas sur les options
définies au moyen de `set`.

Options disponibles :

<dl>
  <dt>locals</dt>
  <dd>
    Liste de variables locales passées au document. Pratique pour les vues
    partielles.
    Exemple : <tt>erb "<%= foo %>", :locals => {:foo => "bar"}</tt>.
  </dd>

  <dt>default_encoding</dt>
  <dd>
    Encodage de caractères à utiliser en cas d'incertitude. Par défaut, c'est
    <tt>settings.default_encoding</tt>.
  </dd>

  <dt>views</dt>
  <dd>
    Dossier de vues dans lequel chercher les templates. Par défaut
    <tt>settings.views</tt>.
  </dd>

  <dt>layout</dt>
  <dd>
    S'il faut ou non utiliser un layout (<tt>true</tt> ou <tt>false</tt>).
    Indique le template à utiliser lorsque c'est un symbole. Exemple :
    <tt>erb :index, :layout => !request.xhr?</tt>.
  </dd>

  <dt>content_type</dt>
  <dd>
    Content-Type que le template produit, dépend par défaut du langage de
    template.
  </dd>

  <dt>scope</dt>
  <dd>
    Contexte sous lequel effectuer le rendu du template. Par défaut il s'agit
    de l'instance de l'application. Si vous changez cela, les variables
    d'instance et les méthodes utilitaires ne seront pas disponibles.
  </dd>

  <dt>layout_engine</dt>
  <dd>
    Moteur de rendu à utiliser pour le layout. Utile pour les langages ne
    supportant pas les layouts. Il s'agit par défaut du moteur utilisé pour
    le rendu du template. Exemple : <tt>set :rdoc, :layout_engine => :erb</tt>
  </dd>

  <dt>layout_options</dt>
  <dd>
    Options spécifiques destinées au moteur de rendu. Exemple : <tt>set :rdoc,
    :layout_options => { :views => 'views/layouts' }</tt>
  </dd>
</dl>

Les templates sont supposés se trouver directement dans le dossier
`./views`. Pour utiliser un dossier de vues différent :

``` ruby
set :views, settings.root + '/templates'
```

Il est important de se souvenir que les templates sont toujours référencés
sous forme de symboles, même lorsqu'ils sont dans un sous-répertoire (dans
ce cas, utilisez `:'sous_repertoire/template'`). Il faut utiliser
un symbole car les méthodes de rendu évaluent le contenu des chaînes de
caractères au lieu de les considérer comme un chemin vers un fichier.

### Templates littéraux

``` ruby
get '/' do
  haml '%div.title Bonjour le monde'
end
```

Générera le code du template spécifié dans la chaîne de caractères.

### Langages de template disponibles

Certains langages ont plusieurs implémentations. Pour préciser l'implémentation
à utiliser (et garantir l'aspect thread-safe), vous devez simplement l'avoir
chargée au préalable :

``` ruby
require 'rdiscount' # ou require 'bluecloth'
get('/') { markdown :index }
```

#### Templates Haml

<table>
  <tr>
    <td>Dépendances</td>
    <td><a href="http://haml.info/" title="haml">haml</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.haml</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>haml :index, :format => :html5</tt></td>
  </tr>
</table>

#### Templates Erb

<table>
  <tr>
    <td>Dépendances</td>
    <td>
      <a href="http://www.kuwata-lab.com/erubis/" title="erubis">erubis</a>
      ou erb (inclus avec Ruby)
    </td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.erb</tt>, <tt>.rhtml</tt> ou <tt>.erubis</tt> (Erubis seulement)</td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>erb :index</tt></td>
  </tr>
</table>

#### Templates Builder

<table>
  <tr>
    <td>Dépendances</td>
    <td>
      <a href="https://github.com/jimweirich/builder" title="builder">builder</a>
    </td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.builder</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>builder { |xml| xml.em "salut" }</tt></td>
  </tr>
</table>

Ce moteur accepte également un bloc pour des templates en ligne (voir
exemple).

#### Templates Nokogiri

<table>
  <tr>
    <td>Dépendances</td>
    <td><a href="http://nokogiri.org/" title="nokogiri">nokogiri</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.nokogiri</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>nokogiri { |xml| xml.em "salut" }</tt>
    </td>
  </tr>
</table>

Ce moteur accepte également un bloc pour des templates en ligne (voir
exemple).

#### Templates Sass

<table>
  <tr>
    <td>Dépendances</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.sass</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>sass :stylesheet, :style => :expanded</tt></td>
  </tr>
</table>

#### Templates SCSS

<table>
  <tr>
    <td>Dépendances</td>
    <td><a href="http://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.scss</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>scss :stylesheet, :style => :expanded</tt></p>
    </td>
  </tr>
</table>

#### Templates Less

<table>
  <tr>
    <td>Dépendances</td>
    <td><a href="http://www.lesscss.org/" title="less">less</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.less</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>less :stylesheet</tt>
    </td>
  </tr>
</table>

#### Templates Liquid

<table>
  <tr>
    <td>Dépendances</td>
    <td><a href="http://www.liquidmarkup.org/" title="liquid">liquid</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.liquid</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>liquid :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

Comme vous ne pouvez appeler de méthodes Ruby (autres que `yield`)
dans un template Liquid, vous aurez sûrement à lui passer des variables
locales.

#### Templates Markdown

<table>
  <tr>
    <td><p>Dépendances</p></td>
    <td>
      Au choix :
      <a href="https://github.com/rtomayko/rdiscount" title="RDiscount">RDiscount</a>,
      <a href="https://github.com/vmg/redcarpet" title="RedCarpet">RedCarpet</a>,
      <a href="http://deveiate.org/projects/BlueCloth" title="BlueCloth">BlueCloth</a>,
      <a href="http://kramdown.gettalong.org/" title="kramdown">kramdown</a>,
      <a href="https://github.com/bhollis/maruku" title="maruku">maruku</a>
    </td>
  </tr>

  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.markdown</tt>, <tt>.mkd</tt> et <tt>.md</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>markdown :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

Il n’est pas possible d’appeler des méthodes depuis markdown, ni de
lui passer des variables locales. Par conséquent, il sera souvent utilisé
en combinaison avec un autre moteur de rendu :

``` ruby
erb :overview, :locals => { :text => markdown(:introduction) }
```

Notez que vous pouvez également appeler la méthode `markdown` au
sein d’autres templates :

``` ruby
%h1 Hello From Haml !
%p= markdown(:greetings)
```

Comme vous ne pouvez pas appeler de Ruby au sein de Markdown, vous ne
pouvez pas utiliser de layouts écrits en Markdown. Toutefois, il
est possible d’utiliser un moteur de rendu différent pour le template et
pour le layout en utilisant l’option `:layout_engine`.

#### Templates Textile

<table>
  <tr>
    <td>Dépendances</td>
    <td><a href="http://redcloth.org/" title="RedCloth">RedCloth</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.textile</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>textile :index, :layout_engine => :erb</tt></td>
  </tr>
</table>

Il n’est pas possible d’appeler des méthodes depuis textile, ni de lui
passer des variables locales. Par conséquent, il sera souvent utilisé en
combinaison avec un autre moteur de rendu :

``` ruby
erb :overview, :locals => { :text => textile(:introduction) }
```

Notez que vous pouvez également appeler la méthode `textile` au
sein d’autres templates :

``` ruby
%h1 Hello From Haml !
%p= textile(:greetings)
```

Comme vous ne pouvez pas appeler de Ruby au sein de Textile, vous ne pouvez
pas utiliser de layouts écrits en Textile. Toutefois, il est
possible d’utiliser un moteur de rendu différent pour le template et
pour le layout en utilisant l’option `:layout_engine`.

#### Templates RDoc

<table>
  <tr>
    <td>Dépendances</td>
    <td><a href="http://rdoc.sourceforge.net/" title="RDoc">RDoc</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.rdoc</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>rdoc :README, :layout_engine => :erb</tt></td>
  </tr>
</table>

Il n’est pas possible d’appeler des méthodes depuis rdoc, ni de lui
passer des variables locales. Par conséquent, il sera souvent utilisé en
combinaison avec un autre moteur de rendu :

``` ruby
erb :overview, :locals => { :text => rdoc(:introduction) }
```

Notez que vous pouvez également appeler la méthode `rdoc` au sein
d’autres templates :

``` ruby
%h1 Hello From Haml !
%p= rdoc(:greetings)
```

Comme vous ne pouvez pas appeler de Ruby au sein de RDoc, vous ne pouvez
pas utiliser de layouts écrits en RDoc. Toutefois, il est
possible d’utiliser un moteur de rendu différent pour le template et
pour le layout en utilisant l’option `:layout_engine`.

#### Templates Radius
<table>
  <tr>
    <td>Dépendances</td>
    <td><a href="https://github.com/jlong/radius" title="Radius">Radius</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.radius</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>radius :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

Comme vous ne pouvez pas appeler de méthodes Ruby depuis un template
Radius, vous aurez sûrement à lui passer des variables locales.

#### Templates Markaby

<table>
  <tr>
    <td>Dépendances</td>
    <td><a href="http://markaby.github.com/" title="Markaby">Markaby</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.mab</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>markaby { h1 "Bienvenue !" }</tt></td>
  </tr>
</table>

Ce moteur accepte également un bloc pour des templates en ligne (voir
exemple).

#### Templates RABL

<table>
  <tr>
    <td>Dépendances</td>
    <td><a href="https://github.com/nesquena/rabl" title="Rabl">Rabl</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.rabl</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>rabl :index</tt></td>
  </tr>
</table>

#### Templates Slim

<table>
  <tr>
    <td>Dépendances</td>
    <td><a href="http://slim-lang.com/" title="Slim Lang">Slim Lang</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.slim</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>slim :index</tt></td>
  </tr>
</table>

#### Templates Creole

<table>
  <tr>
    <td>Dépendances</td>
    <td><a href="https://github.com/minad/creole" title="Creole">Creole</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.creole</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>creole :wiki, :layout_engine => :erb</tt></td>
  </tr>
</table>

Il n'est pas possible d'appeler des méthodes depuis creole, ni de lui
passer des variables locales. Par conséquent, il sera souvent utilisé en
combinaison avec un autre moteur de rendu :

``` ruby
erb :overview, :locals => { :text => markdown(:introduction) }
```

Notez que vous pouvez également appeler la méthode `creole` au sein d'autres
templates :

``` ruby
%h1 Hello From Haml !
%p= creole(:greetings)
```

Comme vous ne pouvez pas appeler de Ruby au sein de Creole, vous ne pouvez
pas utiliser de layouts écrits en Creole. Toutefois, il est possible
d'utiliser un moteur de rendu différent pour le template et pour le layout
en utilisant l'option `:layout_engine`.

#### Templates CoffeeScript

<table>
  <tr>
    <td>Dépendances</td>
    <td>
      <a href="https://github.com/josh/ruby-coffee-script" title="Ruby CoffeeScript">
        CoffeeScript
      </a>
      et un
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        moyen d'exécuter javascript
      </a>
    </td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.coffee</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>coffee :index</tt></td>
  </tr>
</table>

#### Templates Stylus

<table>
  <tr>
    <td>Dépendances</td>
    <td>
      <a href="https://github.com/lucasmazza/ruby-stylus" title="Ruby Stylus">
        Stylus
      </a>
      et un
      <a href="https://github.com/sstephenson/execjs/blob/master/README.md#readme" title="ExecJS">
        moyen d'exécuter javascript
      </a>
    </td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.styl</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>stylus :index</tt></td>
  </tr>
</table>

Avant de pouvoir utiliser des templates Stylus, vous devez auparavant charger
`stylus` et `stylus/tilt` :

``` ruby
require 'sinatra'
require 'stylus'
require 'stylus/tilt'

get '/' do
  stylus :exemple
end
```

#### Templates Yajl

<table>
  <tr>
    <td>Dépendances</td>
    <td>
      <a href="https://github.com/brianmario/yajl-ruby" title="yajl-ruby">yajl-ruby</a>
    </td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.yajl</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>yajl :index, :locals => { :key => 'qux' }, :callback => 'present', :variable => 'resource'</tt></p>
    </td>
  </tr>
</table>

Le source du template est évalué en tant que chaine Ruby, puis la
variable json obtenue est convertie avec #to_json.

``` ruby
json = { :foo => 'bar' }
json[:baz] = key
```

Les options `:callback` et `:variable` peuvent être utilisées pour décorer
l’objet retourné.

``` ruby
var resource = {"foo":"bar","baz":"qux"}; present(resource);</pre>
```

#### Templates WLang

<table>
  <tr>
    <td>Dépendances</td>
    <td><a href="https://github.com/blambeau/wlang/" title="wlang">wlang</a></td>
  </tr>
  <tr>
    <td>Extensions de fichier</td>
    <td><tt>.wlang</tt></td>
  </tr>
  <tr>
    <td>Exemple</td>
    <td><tt>wlang :index, :locals => { :key => 'value' }</tt></td>
  </tr>
</table>

L’appel de code ruby au sein des templates n’est pas idiomatique en wlang.
L’écriture de templates sans logique est encouragé, via le passage de variables
locales. Il est néanmoins possible d’écrire un layout en wlang et d’y utiliser
`yield`.

### Accéder aux variables dans un Template

Un template est évalué dans le même contexte que l'endroit d'où il a été
appelé (gestionnaire de route). Les variables d'instance déclarées dans le
gestionnaire de route sont directement accessibles dans le template :

``` ruby
get '/:id' do
  @foo = Foo.find(params['id'])
  haml '%h1= @foo.nom'
end
```

Alternativement, on peut passer un hash contenant des variables locales :

``` ruby
get '/:id' do
  foo = Foo.find(params['id'])
  haml '%h1= foo.nom', :locals => { :foo => foo }
end
```

Ceci est généralement utilisé lorsque l'on veut utiliser un template comme
partiel (depuis un autre template) et qu'il est donc nécessaire d'adapter les
noms de variables.


### Templates avec `yield` et layouts imbriqués

En général, un layout est un simple template qui appelle `yield`. Ce genre de
template peut s'utiliser via l'option `:template`  comme décrit précédemment ou
peut être rendu depuis un bloc :

``` ruby
erb :post, :layout => false do
  erb :index
end
```

Ce code est à globalement équivalent à `erb :index, :layout => :post`.

Le fait de passer des blocs aux méthodes de rendu est particulièrement utile
pour gérer des templates imbriqués :

``` ruby
erb :main_layout, :layout => false do
  erb :admin_layout do
    erb :user
  end
end
```

Ce qui peut aussi être fait avec un peu moins de code :

``` ruby
erb :admin_layout, :layout => :main_layout do
  erb :user
end
```

Actuellement, les méthodes de rendu qui acceptent un bloc sont : `erb`, `haml`,
`liquid`, `slim ` et `wlang`. La méthode générale `render` accepte elle aussi
un bloc.


### Templates dans le fichier source

Des templates peuvent être définis dans le fichier source comme ceci :

``` ruby
require 'sinatra'

get '/' do
  haml :index
end

__END__

@@ layout
%html
  = yield

@@ index
%div.title Bonjour le monde !
```

NOTE : Les templates du fichier source qui contient `require 'sinatra'`
sont automatiquement chargés. Si vous avez des templates dans d'autres
fichiers source, il faut explicitement les déclarer avec
`enable :inline_templates`.


### Templates nommés

Les templates peuvent aussi être définis grâce à la méthode de haut niveau `template` :

``` ruby
template :layout do
  "%html\n  =yield\n"
end

template :index do
  '%div.title Bonjour le monde !'
end

get '/' do
  haml :index
end
```

Si un template nommé "layout" existe, il sera utilisé à chaque fois qu'un
template sera affiché. Vous pouvez désactivez les layouts au cas par cas en
passant `:layout => false` ou bien les désactiver par défaut au moyen
de `set :haml, :layout => false` :

``` ruby
get '/' do
  haml :index, :layout => !request.xhr?
end
```

### Associer des extensions de fichier

Pour associer une extension de fichier avec un moteur de rendu, utilisez
`Tilt.register`. Par exemple, si vous désirez utiliser l'extension
de fichier `tt` pour les templates Textile, vous pouvez faire comme suit :

``` ruby
Tilt.register :tt, Tilt[:textile]
```

### Ajouter son propre moteur de rendu

En premier lieu, déclarez votre moteur de rendu avec Tilt, ensuite créez
votre méthode de rendu :

``` ruby
Tilt.register :monmoteur, MonMerveilleurMoteurDeRendu

helpers do
  def monmoteur(*args) render(:monmoteur, *args) end
end

get '/' do
  monmoteur :index
end
```

Utilisera `./views/index.monmoteur`. Voir [le dépôt Github](https://github.com/rtomayko/tilt) pour en savoir plus sur Tilt.

## Filtres

Les filtres before sont exécutés avant chaque requête, dans le même contexte
que les routes, et permettent de modifier la requête et sa réponse. Les
variables d'instance déclarées dans les filtres sont accessibles au niveau
des routes et des templates :

``` ruby
before do
  @note = 'Coucou !'
  request.path_info = '/foo/bar/baz'
end

get '/foo/*' do
  @note #=> 'Coucou !'
  params['splat'] #=> 'bar/baz'
end
```

Les filtres after sont exécutés après chaque requête à l'intérieur du même
contexte et permettent de modifier la requête et sa réponse. Les variables
d'instance déclarées dans les filtres before ou les routes sont accessibles
au niveau des filtres after :

``` ruby
after do
  puts response.status
end
```

Note : Le corps de la réponse n'est pas disponible au niveau du filtre after
car il ne sera généré que plus tard (sauf dans le cas où vous utilisez la
méthode `body` au lieu de simplement renvoyer une chaine depuis vos routes).

Les filtres peuvent être associés à un masque, ce qui permet de limiter leur
exécution aux cas où la requête correspond à ce masque :

``` ruby
before '/secret/*' do
  authentification!
end

after '/faire/:travail' do |travail|
  session['dernier_travail'] = travail
end
```

Tout comme les routes, les filtres acceptent également des conditions :

``` ruby
before :agent => /Songbird/ do
  # ...
end

after '/blog/*', :host_name => 'example.com' do
  # ...
end
```

## Helpers

Utilisez la méthode de haut niveau `helpers` pour définir des routines
qui seront accessibles dans vos gestionnaires de route et dans vos templates :

``` ruby
helpers do
  def bar(nom)
    "#{nom}bar"
  end
end

get '/:nom' do
  bar(params['nom'])
end
```

Vous pouvez aussi définir les méthodes helper dans un module séparé :

``` ruby
module FooUtils
  def foo(nom) "#{nom}foo" end
end

module BarUtils
  def bar(nom) "#{nom}bar" end
end

helpers FooUtils, BarUtils
```

Cela a le même résultat que d'inclure les modules dans la classe de
l'application.

### Utiliser les sessions

Une session est utilisée pour conserver un état entre les requêtes. Une fois
activées, vous avez un hash de session par session utilisateur :

``` ruby
enable :sessions

get '/' do
  "valeur = " << session['valeur'].inspect
end

get '/:value' do
  session['valeur'] = params['valeur']
end
```

Notez que `enable :sessions` enregistre en fait toutes les données dans
un cookie. Ce n'est pas toujours ce que vous voulez (enregistrer beaucoup de
données va augmenter le traffic par exemple). Vous pouvez utiliser n'importe
quel middleware Rack de session afin d'éviter cela. N'utilisez **pas**
`enable :sessions` dans ce cas mais chargez le middleware de votre
choix comme vous le feriez pour n'importe quel autre middleware :

``` ruby
use Rack::Session::Pool, :expire_after => 2592000

get '/' do
  "valeur = " << session['valeur'].inspect
end

get '/:value' do
  session['valeur'] = params['valeur']
end
```

Pour renforcer la sécurité, les données de session dans le cookie sont signées
avec une clé secrète de session. Une clé secrète est générée pour vous au
hasard par Sinatra. Toutefois, comme cette clé change à chaque démarrage de
votre application, vous pouvez définir cette clé vous-même afin que toutes
les instances de votre application la partage :

``` ruby
set :session_secret, 'super secret'
```

Si vous souhaitez avoir plus de contrôle, vous pouvez également enregistrer un
hash avec des options lors de la configuration de `sessions` :

``` ruby
set :sessions, :domain => 'foo.com'
```

Pour que les différents sous-domaines de foo.com puisse partager une session,
vous devez préfixer le domaine par *.* :

``` ruby
set :sessions, :domain => '.foo.com'
```


### Halt

Pour arrêter immédiatement la requête dans un filtre ou un gestionnaire de
route :

``` ruby
halt
```

Vous pouvez aussi passer le code retour ...

``` ruby
halt 410
```

Ou le texte ...

``` ruby
halt 'Ceci est le texte'
```

Ou les deux ...

``` ruby
halt 401, 'Partez !'
```

Ainsi que les entêtes ...

``` ruby
halt 402, {'Content-Type' => 'text/plain'}, 'revanche'
```

Bien sûr il est possible de combiner un template avec `halt` :

``` ruby
halt erb(:erreur)
```

### Passer

Une route peut passer le relais aux autres routes qui correspondent également
avec `pass` :

``` ruby
get '/devine/:qui' do
  pass unless params['qui'] == 'Frank'
  "Tu m'as eu !"
end

get '/devine/*' do
  'Manqué !'
end
```

On sort donc immédiatement de ce gestionnaire et on continue à chercher,
dans les masques suivants, le prochain qui correspond à la requête.
Si aucun des masques suivants ne correspond, un code 404 est retourné.

### Déclencher une autre route

Parfois, `pass` n'est pas ce que vous recherchez, au lieu de cela vous
souhaitez obtenir le résultat d'une autre route. Pour cela, utilisez
simplement `call` :

``` ruby
get '/foo' do
  status, headers, body = call env.merge("PATH_INFO" => '/bar')
  [status, headers, body.map(&:upcase)]
end

get '/bar' do
  "bar"
end
```

Notez que dans l'exemple ci-dessus, vous faciliterez les tests et améliorerez
la performance en déplaçant simplement `"bar"` dans un helper
utilisé à la fois par `/foo` et `/bar`.

Si vous souhiatez que la requête soit envoyée à la même instance de
l'application plutôt qu'à une copie, utilisez `call!` au lieu de
`call`.

Lisez la spécification Rack si vous souhaitez en savoir plus sur
`call`.

### Définir le corps, le code retour et les entêtes

Il est possible et recommandé de définir le code retour et le corps de la
réponse au moyen de la valeur de retour d'un bloc définissant une route.
Quoiqu'il en soit, dans certains cas vous pourriez avoir besoin de définir
le coprs de la réponse à un moment arbitraire de l'exécution. Vous pouvez le
faire au moyen de la méthode `body`. Si vous faites ainsi, vous pouvez alors
utiliser cette même méthode pour accéder au corps de la réponse :

``` ruby
get '/foo' do
  body "bar"
end

after do
  puts body
end
```

Il est également possible de passer un bloc à `body`, qui sera exécuté par le
gestionnaire Rack (ceci peut être utilisé pour implémenter un streaming,
voir "Valeurs de retour").

Pareillement au corps de la réponse, vous pouvez également définir le code
retour et les entêtes :

``` ruby
get '/foo' do
  status 418
  headers \
    "Allow"   => "BREW, POST, GET, PROPFIND, WHEN",
    "Refresh" => "Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt"
  body "Je suis une théière !"
end
```

Comme `body` `headers` et `status` peuvent être utilisés sans arguments
pour accéder à leurs valeurs.

### Faire du streaming

Il y a des cas où vous voulez commencer à renvoyer des données pendant que
vous êtes en train de générer le reste de la réponse. Dans les cas les plus
extrèmes, vous souhaitez continuer à envoyer des données tant que le client
n'abandonne pas la connection. Vous pouvez alors utiliser le helper `stream`
pour éviter de créer votre propre système :

``` ruby
get '/' do
  stream do |out|
    out << "Ca va être hallu -\n"
    sleep 0.5
    out << " (attends la suite) \n"
    sleep 1
    out << "- cinant !\n"
  end
end
```

Cela permet d'implémenter des API de streaming ou de
[Server Sent Events](http://dev.w3.org/html5/eventsource/) et peut servir de
base pour des [WebSockets](http://en.wikipedia.org/wiki/WebSocket). Vous
pouvez aussi l'employer pour augmenter le débit quand une partie du contenu
provient d'une resource lente.

Le fonctionnement du streaming, notamment le nombre de requêtes simultanées,
dépend énormément du serveur web utilisé. Certains ne prennent pas du tout en
charge le streaming (WEBRick par exemple). Lorsque le serveur ne gère pas le
streaming, la partie body de la réponse sera envoyée au client en une seule
fois, après que l'exécution du bloc passé au helper `stream` sera terminée. Le
streaming ne fonctionne pas du tout avec Shotgun.

En utilisant le helper stream avec le paramètre `keep_open`, il n'appelera
pas la méthode `close` du flux, vous laissant la possibilité de le fermer à
tout moment au cours de l'exécution. Ceci ne fonctionne qu'avec les serveurs
evented (ie non threadés) tels que Thin et Rainbows. Les autres serveurs
fermeront malgré tout le flux :

``` ruby
# interrogation prolongée

set :server, :thin
connexions = []

get '/souscrire' do
  # abonne un client aux évènements du serveur
  stream(:keep_open) do |out|
    connexions << out
    # purge les connexions abandonnées
    connexions.reject!(&:closed?)
  end
end

post '/message' do
  connexions.each do |out|
    # prévient le client qu'un nouveau message est arrivé
    out << params['message'] << "\n"

    # indique au client de se connecter à nouveau
    out.close
  end

  # compte-rendu
  "message reçu"
end
```

### Journalisation (Logging)

Dans le contexte de la requête, la méthode utilitaire `logger` expose une
instance de `Logger` :

``` ruby
get '/' do
  logger.info "chargement des données"
  # ...
end
```

Ce logger va automatiquement prendre en compte les paramètres de
configuration pour la journalisation de votre gestionnaire Rack. Si la
journalisation est désactivée, cette méthode renverra un objet factice et
vous n'avez pas à vous en inquiéter dans vos routes en le filtrant.

Notez que la journalisation est seulement activée par défaut pour
`Sinatra::Application`, donc si vous héritez de `>Sinatra::Base`,
vous aurez à l'activer vous-même :

``` ruby
class MonApp < Sinatra::Base
  configure :production, :development do
    enable :logging
  end
end
```

Si vous souhaitez utiliser votre propre logger, vous devez définir le paramètre
`logging` à `nil` pour être certain qu'aucun middleware de logging ne sera
installé (notez toutefois que `logger` renverra alors `nil`). Dans ce cas,
Sinatra utilisera ce qui sera présent dans `env['rack.logger']`.

### Types Mime

Quand vous utilisez `send_file` ou des fichiers statiques, vous
pouvez rencontrer des types mime que Sinatra ne connaît pas. Utilisez
`mime_type` pour les déclarer par extension de fichier :

``` ruby
configure do
  mime_type :foo, 'text/foo'
end
```

Vous pouvez également les utiliser avec la méthode `content_type` :

``` ruby
get '/' do
  content_type :foo
  "foo foo foo"
end
```

### Former des URLs

Pour former des URLs, vous devriez utiliser la méthode `url`, par exemple en
Haml :

``` ruby
%a{:href => url('/foo')} foo
```

Cela prend en compte les proxy inverse et les routeurs Rack, s'ils existent.

Cette méthode est également disponible sous l'alias `to` (voir ci-dessous
pour un exemple).

### Redirection du navigateur

Vous pouvez déclencher une redirection du navigateur avec la méthode
`redirect` :

``` ruby
get '/foo' do
  redirect to('/bar')
end
```

Tout paramètre additionnel est géré comme des arguments pour la méthode
`halt` :

``` ruby
redirect to('/bar'), 303
redirect 'http://google.com', 'mauvais endroit mon pote'
```

Vous pouvez aussi rediriger vers la page dont l'utilisateur venait au moyen de
`redirect back` :

``` ruby
get '/foo' do
  "<a href='/bar'>faire quelque chose</a>"
end

get '/bar' do
  faire_quelque_chose
  redirect back
end
```

Pour passer des arguments à une redirection, ajoutez-les soit à la requête :

``` ruby
redirect to('/bar?sum=42')
```

Ou bien utilisez une session :

``` ruby
enable :sessions

get '/foo' do
  session['secret'] = 'foo'
  redirect to('/bar')
end

get '/bar' do
  session['secret']
end
```

### Contrôle du cache

Définir correctement vos entêtes à la base pour un bon cache HTTP.

Vous pouvez facilement définir l'entête Cache-Control de la manière suivante :

``` ruby
get '/' do
  cache_control :public
  "met le en cache !"
end
```

Conseil de pro : définir le cache dans un filtre before :

``` ruby
before do
  cache_control :public, :must_revalidate, :max_age => 60
end
```

Si vous utilisez la méthode `expires` pour définir l'entête correspondant,
`Cache-Control` sera alors défini automatiquement :

``` ruby
before do
  expires 500, :public, :must_revalidate
end
```

Pour utiliser correctement les caches, vous devriez utiliser `etag` ou
`last_modified`. Il est recommandé d'utiliser ces méthodes *avant* de faire
d'importantes modifications, car elles vont immédiatement déclencher la réponse
si le client a déjà la version courante dans son cache :

``` ruby
get '/article/:id' do
  @article = Article.find params['id']
  last_modified @article.updated_at
  etag @article.sha1
  erb :article
end
```

Il est également possible d'utiliser un
[weak ETag](http://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation) :

``` ruby
etag @article.sha1, :weak
```

Ces méthodes ne sont pas chargées de mettre des données en cache, mais elles
fournissent les informations nécessaires pour votre cache. Si vous êtes à la
recherche de solutions rapides pour un reverse-proxy de cache, essayez
[rack-cache](https://github.com/rtomayko/rack-cache) :

``` ruby
require "rack/cache"
require "sinatra"

use Rack::Cache

get '/' do
  cache_control :public, :max_age => 36000
  sleep 5
  "hello"
end
```

Utilisez le paramètre `:static_cache_control` pour ajouter l'information
d'en-tête `Cache-Control` (voir plus loin).

D'après la RFC 2616, votre application devrait se comporter différement lorsque
l'en-tête If-Match ou If-None-Match est défini à `*` en tenant compte du
fait que la resource demandée existe déjà ou pas. Sinatra considère que les
requêtes portant sur des resources sûres (tel que get) ou idempotentes (tel que
put) existent déjà et pour les autres resources (par exemple dans le cas
de requêtes post) qu'il s'agit de nouvelles resources. Vous pouvez modifier ce
comportement en passant une option `:new_resource` :

``` ruby
get '/create' do
  etag '', :new_resource => true
  Article.create
  erb :new_article
end
```

Si vous souhaitez utilisez un ETag faible, utilisez l'option <tt>:kind</tt> :

``` ruby
etag '', :new_resource => true, :kind => :weak
```

### Envoyer des fichiers

Pour envoyer des fichiers, vous pouvez utiliser la méthode `send_file` :

``` ruby
get '/' do
  send_file 'foo.png'
end
```

Quelques options sont également acceptées :

``` ruby
send_file 'foo.png', :type => :jpg
```

Les options sont :

<dl>
  <dt>filename</dt>
  <dd>
    le nom du fichier dans la réponse, par défaut le nom du fichier envoyé.
  </dd>

  <dt>last_modified</dt>
  <dd>
    valeur pour l’entête Last-Modified, par défaut la date de modification du
    fichier
  </dd>

  <dt>type</dt>
  <dd>
    type de contenu à utiliser, deviné à partir de l’extension de fichier si
    absent
  </dd>

  <dt>disposition</dt>
  <dd>
    utilisé pour Content-Disposition, les valuers possibles étant : <tt>nil</tt>
    (par défaut), <tt>:attachment</tt> et <tt>:inline</tt>
  </dd>

  <dt>length</dt>
  <dd>entête Content-Length, par défaut la taille du fichier</dd>

  <dt>status</dt>
  <dd>
    code état à renvoyer. Utile quand un fichier statique sert de page d’erreur.
  </dd>
</dl>

Si le gestionnaire Rack le supporte, d'autres moyens que le streaming via le
processus Ruby seront utilisés. Si vous utilisez cette méthode, Sinatra gérera
automatiquement les requêtes de type range.

### Accéder à l'objet requête

L'objet correspondant à la requête envoyée peut être récupéré dans le contexte
de la requête (filtres, routes, gestionnaires d'erreur) au moyen de la méthode
`request` :

``` ruby
# application tournant à l'adresse http://exemple.com/exemple
get '/foo' do
  t = %w[text/css text/html application/javascript]
  request.accept              # ['text/html', '*/*']
  request.accept? 'text/xml'  # true
  request.preferred_type(t)   # 'text/html'
  request.body                # corps de la requête envoyée par le client
                              # (voir ci-dessous)
  request.scheme              # "http"
  request.script_name         # "/exemple"
  request.path_info           # "/foo"
  request.port                # 80
  request.request_method      # "GET"
  request.query_string        # ""
  request.content_length      # taille de request.body
  request.media_type          # type de média pour request.body
  request.host                # "exemple.com"
  request.get?                # true (méthodes similaires pour les autres
                              # verbes HTTP)
  request.form_data?          # false
  request["UN_ENTETE"]        # valeur de l'entête UN_ENTETE
  request.referrer            # référant du client ou '/'
  request.user_agent          # user agent (utilisé par la condition :agent)
  request.cookies             # tableau contenant les cookies du navigateur
  request.xhr?                # requête AJAX ?
  request.url                 # "http://exemple.com/exemple/foo"
  request.path                # "/exemple/foo"
  request.ip                  # adresse IP du client
  request.secure?             # false
  request.forwarded?          # vrai (si on est derrière un proxy inverse)
  request.env                 # tableau brut de l'environnement fourni par Rack
end
```

Certaines options, telles que `script_name` ou `path_info`
peuvent également être modifiées :

``` ruby
before { request.path_info = "/" }

get "/" do
  "toutes les requêtes arrivent ici"
end
```

`request.body` est un objet IO ou StringIO :

``` ruby
post "/api" do
  request.body.rewind  # au cas où il a déjà été lu
  donnees = JSON.parse request.body.read
  "Bonjour #{donnees['nom']} !"
end
```

### Fichiers joints

Vous pouvez utiliser la méthode `attachment` pour indiquer au navigateur que
la réponse devrait être stockée sur le disque plutôt qu'affichée :


``` ruby
get '/' do
  attachment
  "enregistre-le !"
end
```

Vous pouvez également lui passer un nom de fichier :

``` ruby
get '/' do
  attachment "info.txt"
  "enregistre-le !"
end
```

### Gérer Date et Time

Sinatra fourni un helper `time_for` pour convertir une valeur donnée en
objet `Time`. Il peut aussi faire la conversion à partir d'objets `DateTime`,
`Date` ou de classes similaires :

``` ruby
get '/' do
  pass if Time.now > time_for('Dec 23, 2012')
  "encore temps"
end
```

Cette méthode est utilisée en interne par `expires`, `last_modified` et
consorts. Par conséquent, vous pouvez très facilement étendre le
fonctionnement de ces méthodes en surchargeant le helper `time_for` dans
votre application :

``` ruby
helpers do
  def time_for(value)
    case value
    when :yesterday then Time.now - 24*60*60
    when :tomorrow  then Time.now + 24*60*60
    else super
    end
  end
end

get '/' do
  last_modified :yesterday
  expires :tomorrow
  "salut"
end
```

### Chercher les fichiers de templates

La méthode `find_template` est utilisée pour trouver les fichiers de
templates à générer :

``` ruby
find_template settings.views, 'foo', Tilt[:haml] do |file|
  puts "pourrait être #{file}"
end
```

Ce n'est pas très utilise. En revanche, il est utile de pouvoir surcharger
cette méthode afin de définir son propre mécanisme de recherche. Par exemple,
vous pouvez utiliser plus d'un répertoire de vues :

``` ruby
set :views, ['views', 'templates']

helpers do
  def find_template(views, name, engine, &block)
    Array(views).each { |v| super(v, name, engine, &block) }
  end
end
```

Un autre exemple est d'utiliser des répertoires différents pour des moteurs
de rendu différents :

``` ruby
set :views, :sass => 'views/sass', :haml => 'templates', :default => 'views'

helpers do
  def find_template(views, name, engine, &block)
    _, folder = views.detect { |k,v| engine == Tilt[k] }
    folder ||= views[:default]
    super(folder, name, engine, &block)
  end
end
```

Vous pouvez également écrire cela dans une extension et la partager avec
d'autres !

Notez que `find_template` ne vérifie pas que le fichier existe mais
va plutôt exécuter le bloc pour tous les chemins possibles. Cela n'induit pas
un problème de performance dans le sens où `render` va utiliser `break` dès
qu'un fichier est trouvé. De plus, l'emplacement des templates (et leur
contenu) est mis en cache si vous n'êtes pas en mode développement. Vous
devriez garder cela en tête si vous écrivez une méthode vraiment dingue.

## Configuration

Lancé une seule fois au démarrage de tous les environnements :

``` ruby
configure do
  # définir un paramètre
  set :option, 'value'

  # définir plusieurs paramètre
  set :a => 1, :b => 2

  # identique à "set :option, true"
  enable :option

  # identique à "set :option, false""
  disable :option

  # vous pouvez également avoir des paramètres dynamiques avec des blocs
  set(:css_dir) { File.join(views, 'css') }
end
```

Lancé si l'environnement (variable d'environnement RACK_ENV) est défini comme
`:production` :

``` ruby
  configure :production do
    ...
  end
```

Lancé si l'environnement est `:production` ou `:test` :

``` ruby
  configure :production, :test do
    ...
  end
```

Vous pouvez accéder à ces paramètres via `settings` :

``` ruby
configure do
  set :foo, 'bar'
end

get '/' do
  settings.foo? # => true
  settings.foo  # => 'bar'
  ...
end
```

### Se protéger des attaques

Sinatra utilise [Rack::Protection](https://github.com/rkh/rack-protection#readme)
pour protéger votre application contre les principales attaques opportunistes.
Vous pouvez très simplement désactiver cette fonctionnalité (ce qui exposera
votre application à beaucoup de vulnerabilités courantes) :

``` ruby
disable :protection
```

Pour désactiver seulement un type de protection, vous pouvez définir `protection`
avec un hash d'options :

``` ruby
set :protection, :except => :path_traversal
```

Vous pouvez également lui passer un tableau pour désactiver plusieurs types de
protection :

``` ruby
set :protection, :except => [:path_traversal, :session_hijacking]
```

Par défaut, il faut que `:sessions` soit activé pour que Sinatra mette en place
un système de protection au niveau de la session. Dans le cas où vous gérez
vous même les sessions, vous devez utiliser l'option `:session` pour que cela
soit le cas :

``` ruby
use Rack::Session::Pool
set :protection, :session => true
```

### Paramètres disponibles

<dl>
  <dt>absolute_redirects</dt>
  <dd>Si désactivé, Sinatra permettra les redirections relatives. Toutefois,
  Sinatra ne sera plus conforme à la RFC 2616 (HTTP 1.1), qui n’autorise
  que les redirections absolues.</p>

  Activez si votre application tourne derrière un proxy inverse qui n’a
  pas été correctement configuré. Notez que la méthode <tt>url</tt>
  continuera de produire des URLs absolues, sauf si vous lui passez
  <tt>false</tt> comme second argument.</p>

  <p>Désactivé par défaut.</p></dd>

  <dt>add_charset</dt>
  <dd><p>types mime pour lesquels la méthode <tt>content_type</tt> va
  automatiquement ajouter l’information du <tt>charset</tt>.</p>

  <p>Vous devriez lui ajouter des valeurs plutôt que de l’écraser :</p>

  <pre>settings.add_charset >> "application/foobar"</pre></dd>

  <dt>app_file</dt>
  <dd><p>chemin pour le fichier de l’application principale, utilisé pour
  détecter la racine du projet, les dossiers public et vues, et les
  templates en ligne.</p></dd>

  <dt>bind</dt>
  <dd>adresse IP sur laquelle se brancher (par défaut : 0.0.0.0). Utiliser
  seulement pour le serveur intégré.</dd>

  <dt>default_encoding</dt>
  <dd>encodage à utiliser si inconnu (par défaut <tt>"utf-8"</tt>)</dd>

  <dt>dump_errors</dt>
  <dd>afficher les erreurs dans le <tt>log</tt>.
  </dd>

  <dt>environment</dt>
  <dd>environnement courant, par défaut <tt>ENV['RACK_ENV']</tt>, ou
  <tt>"development"</tt> si absent.</dd>

  <dt>logging</dt>
  <dd>utiliser le <tt>logger</tt>.</dd>

  <dt>lock</dt>
  <dd><p>Place un <tt>lock</tt> autour de chaque requête, n’exécutant donc
  qu’une seule requête par processus Ruby.</p>

  <p>Activé si votre application n’est pas <tt>thread-safe</tt>. Désactivé
  par défaut.</p></dd>

  <dt>method_override</dt>
  <dd>utilise la magie de <tt>_method</tt> afin de permettre des formulaires
  put/delete dans des navigateurs qui ne le permettent pas.

  </dd>
  <dt>port</dt>
  <dd>port à écouter. Utiliser seulement pour le serveur intégré.</dd>

  <dt>prefixed_redirects</dt>
  <dd>si oui ou non <tt>request.script_name</tt> doit être inséré dans les
  redirections si un chemin non absolu est utilisé. Ainsi, <tt>redirect
  '/foo'</tt> se comportera comme <tt>redirect to('/foo')</tt>. Désactivé
  par défaut.</dd>

  <dt>protection</dt>
  <dd>défini s’il faut activer ou non la protection contre les attaques web.
  Voir la section protection précédente.</dd>

  <dt>public_dir</dt>
  <dd>alias pour <tt>public_folder</tt>. Voir ci-dessous.</dd>

  <dt>public_folder</dt>
  <dd>chemin pour le dossier à partir duquel les fichiers publics sont servis.
  Utilisé seulement si les fichiers statiques doivent être servis (voir le
  paramètre <tt>static</tt>). Si non défini, il découle du paramètre
  <tt>app_file</tt>.</dd>

  <dt>reload_templates</dt>
  <dd>si oui ou non les templates doivent être rechargés entre les requêtes.
  Activé en mode développement.</dd>

  <dt>root</dt>
  <dd>chemin pour le dossier racine du projet. Si non défini, il découle du
  paramètre <tt>app_file</tt>.</dd>

  <dt>raise_errors</dt>
  <dd>soulever les erreurs (ce qui arrêtera l’application). Désactivé par
  défaut sauf lorsque <tt>environment</tt> est défini à
  <tt>"test"</tt>.</dd>

  <dt>run</dt>
  <dd>si activé, Sinatra s’occupera de démarrer le serveur, ne pas activer si
  vous utiliser rackup ou autres.</dd>

  <dt>running</dt>
  <dd>est-ce que le serveur intégré est en marche ? ne changez pas ce
  paramètre !</dd>

  <dt>server</dt>
  <dd>serveur ou liste de serveurs à utiliser pour le serveur intégré. Par
  défaut [‘thin’, ‘mongrel’, ‘webrick’], l’ordre indiquant la
  priorité.</dd>

  <dt>sessions</dt>
  <dd>active le support des sessions basées sur les cookies, en utilisant
  <tt>Rack::Session::Cookie</tt>. Reportez-vous à la section ‘Utiliser les
  sessions’ pour plus d’informations.</dd>

  <dt>show_exceptions</dt>
  <dd>affiche la trace de l’erreur dans le navigateur lorsqu’une exception se
  produit. Désactivé par défaut sauf lorsque <tt>environment</tt> est
  défini à <tt>"development"</tt>.</dd>

  <dt>static</dt>
  <dd>Si oui ou non Sinatra doit s’occuper de servir les fichiers statiques.
  Désactivez si vous utilisez un serveur capable de le gérer lui même. Le
  désactiver augmentera la performance. Activé par défaut pour le style
  classique, désactivé pour le style modulaire.</dd>

  <dt>static_cache_control</dt>
  <dd>A définir quand Sinatra rend des fichiers statiques pour ajouter les
  en-têtes <tt>Cache-Control</tt>. Utilise le helper <tt>cache_control</tt>.
  Désactivé par défaut. Utiliser un array explicite pour définir des
  plusieurs valeurs : <tt>set :static_cache_control, [:public, :max_age =>
  300]</tt></dd>

  <dt>threaded</dt>
  <dd>à définir à <tt>true</tt> pour indiquer à Thin d’utiliser
  <tt>EventMachine.defer</tt> pour traiter la requête.</dd>

  <dt>views</dt>
  <dd>chemin pour le dossier des vues. Si non défini, il découle du paramètre
  <tt>app_file</tt>.</dd>

  <dt>x_cascade</dt>
  <dd>
    Indique s'il faut ou non définir le header X-Cascade lorsqu'aucune route
    ne correspond. Défini à <tt>true</tt> par défaut.
  </dd>
</dl>

## Environements

Il existe trois environnements prédéfinis : `"development"`,
`"production"` et `"test"`. Les environements peuvent être
sélectionné via la variable d'environnement `RACK_ENV`. Sa valeur par défaut
est `"development"`. Dans ce mode, tous les templates sont rechargés à
chaque requête. Des handlers spécifiques pour `not_found` et
`error` sont installés pour vous permettre d'avoir une pile de trace
dans votre navigateur. En mode `"production"` et `"test"` les
templates sont mis en cache par défaut.

Pour exécuter votre application dans un environnement différent, définissez la
variable d'environnement `RACK_ENV` :

``` shell
RACK_ENV=production ruby my_app.rb
```

Vous pouvez utiliser une des méthodes `development?`, `test?` et `production?`
pour déterminer quel est l'environnement en cours :

``` ruby
get '/' do
  if settings.development?
    "développement !"
  else
    "pas en développement !"
  end
end
```

## Gérer les erreurs

Les gestionnaires d'erreur s'exécutent dans le même contexte que les routes ou
les filtres, ce qui veut dire que vous avez accès (entre autres) aux bons
vieux `haml`, `erb`, `halt`, etc.

### NotFound

Quand une exception <tt>Sinatra::NotFound</tt> est soulevée, ou que le code
retour est 404, le gestionnaire <tt>not_found</tt> est invoqué :

``` ruby
not_found do
  'Pas moyen de trouver ce que vous cherchez'
end
```

### Error

Le gestionnaire `error` est invoqué à chaque fois qu'une exception est
soulevée dans une route ou un filtre. L'objet exception est accessible via la
variable Rack `sinatra.error` :

``` ruby
error do
  'Désolé mais une méchante erreur est survenue - ' + env['sinatra.error'].message
end
```

Erreur sur mesure :

``` ruby
error MonErreurSurMesure do
  'Donc il est arrivé ceci...' + env['sinatra.error'].message
end
```

Donc si ceci arrive :

``` ruby
get '/' do
  raise MonErreurSurMesure, 'quelque chose de mal'
end
```

Vous obtenez ça :

  Donc il est arrivé ceci... quelque chose de mal

Alternativement, vous pouvez avoir un gestionnaire d'erreur associé à un code
particulier :

``` ruby
error 403 do
  'Accès interdit'
end

get '/secret' do
  403
end
```

Ou un intervalle :

``` ruby
error 400..510 do
  'Boom'
end
```

Sinatra installe pour vous quelques gestionnaires `not_found` et
`error` génériques lorsque vous êtes en environnement
`development`.

## Les Middlewares Rack

Sinatra tourne avec [Rack](http://rack.github.io/), une interface standard
et minimale pour les web frameworks Ruby. Un des points forts de Rack est le
support de ce que l'on appelle des "middlewares" -- composant qui vient se
situer entre le serveur et votre application, et dont le but est de
visualiser/manipuler la requête/réponse HTTP, et d'offrir diverses
fonctionnalités classiques.

Sinatra permet de construire facilement des middlewares Rack via la méthode de
haut niveau `use` :

``` ruby
require 'sinatra'
require 'mon_middleware_perso'

use Rack::Lint
use MonMiddlewarePerso

get '/bonjour' do
  'Bonjour le monde'
end
```

La sémantique de `use` est identique à celle définie dans le DSL de
[Rack::Builder](http://rubydoc.info/github/rack/rack/master/Rack/Builder)
(le plus souvent utilisé dans un fichier rackup). Par exemple, la méthode
`use` accepte divers arguments ainsi que des blocs :

``` ruby
use Rack::Auth::Basic do |login, password|
  login == 'admin' && password == 'secret'
end
```

Rack est distribué avec de nombreux middlewares standards pour loguer, débuguer,
faire du routage URL, de l'authentification ou gérer des sessions. Sinatra gère
plusieurs de ces composants automatiquement via son système de configuration, ce
qui vous dispense de faire un `use` en ce qui les concerne.

Vous trouverez d'autres middlewares intéressants sur
[rack](https://github.com/rack/rack/tree/master/lib/rack),
[rack-contrib](https://github.com/rack/rack-contrib#readm),
ou en consultant le [wiki de Rack](https://github.com/rack/rack/wiki/List-of-Middleware).

## Tester

Les tests pour Sinatra peuvent être écrit avec n'importe quelle bibliothèque
basée sur Rack. [Rack::Test](http://gitrdoc.com/brynary/rack-test) est
recommandé :

``` ruby
require 'mon_application_sinatra'
require 'minitest/autorun'
require 'rack/test'

class MonTest < Minitest::Test
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_ma_racine
    get '/'
    assert_equal 'Bonjour le monde !', last_response.body
  end

  def test_avec_des_parametres
    get '/rencontrer', :name => 'Frank'
    assert_equal 'Salut Frank !', last_response.body
  end

  def test_avec_rack_env
    get '/', {}, 'HTTP_USER_AGENT' => 'Songbird'
    assert_equal "Vous utilisez Songbird !", last_response.body
  end
end
```

## Sinatra::Base - Les Middlewares, Bibliothèques, et Applications Modulaires

Définir votre application au niveau supérieur fonctionne bien dans le cas des
micro-applications mais présente pas mal d'inconvénients pour créer des
composants réutilisables sous forme de middlewares Rack, de Rails metal, de
simples librairies avec un composant serveur ou même d'extensions Sinatra. Le
niveau supérieur suppose une configuration dans le style des micro-applications
(une application d'un seul fichier, des répertoires `./public` et
`./views`, des logs, une page d'erreur, etc...). C'est là que
`Sinatra::Base` prend tout son intérêt :

``` ruby
require 'sinatra/base'

class MonApplication < Sinatra::Base
  set :sessions, true
  set :foo, 'bar'

  get '/' do
    'Bonjour le monde !'
  end
end
```

Les méthodes de la classe `Sinatra::Base` sont parfaitement identiques à
celles disponibles via le DSL de haut niveau. Il suffit de deux modifications
pour transformer la plupart des applications de haut niveau en un composant
`Sinatra::Base` :

* Votre fichier doit charger `sinatra/base` au lieu de `sinatra`, sinon toutes
  les méthodes du DSL Sinatra seront importées dans l'espace de nom principal.
* Les gestionnaires de routes, la gestion d'erreur, les filtres et les options
  doivent être placés dans une classe héritant de `Sinatra::Base`.

`Sinatra::Base` est une page blanche. La plupart des options sont
désactivées par défaut, y compris le serveur intégré. Reportez-vous à
[Options et Configuration](http://sinatra.github.com/configuration.html)
pour plus d'informations sur les options et leur fonctionnement. Si vous
souhaitez un comportement plus proche de celui obtenu lorsque vous définissez
votre application au niveau supérieur (aussi connu sous le nom de style
Classique), vous pouvez créer une classe héritant de `Sinatra::Application`.

``` ruby
require 'sinatra/base'

class MyApp < Sinatra::Application
  get '/' do
    'Bonjour le monde !'
  end
end
```

### Style modulaire vs. style classique

Contrairement aux idées reçues, il n'y a rien de mal à utiliser le style
classique. Si c'est ce qui convient pour votre application, vous n'avez pas
aucune raison de passer à une application modulaire.

Le principal inconvénient du style classique sur le style modulaire est que vous
ne pouvez avoir qu'une application Ruby par processus Ruby. Si vous pensez en
utiliser plus, passez au style modulaire. Et rien ne vous empêche de mixer style
classique et style modulaire.

Si vous passez d'un style à l'autre, souvenez-vous des quelques différences
mineures en ce qui concerne les paramètres par défaut :

<table>
  <tr>
    <th>Paramètre</th>
    <th>Classique</th>
    <th>Modulaire</th>
    <th>Modulaire</th>
  </tr>

  <tr>
    <td>app_file</td>
    <td>fichier chargeant sinatra</td>
    <td>fichier héritant de Sinatra::Base</td>
    <td>fichier héritant de Sinatra::Application</td>
  </tr>

  <tr>
    <td>run</td>
    <td>$0 == app_file</td>
    <td>false</td>
    <td>false</td>
  </tr>

  <tr>
    <td>logging</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>method_override</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>inline_templates</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>static</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>
</table>

### Servir une application modulaire

Il y a deux façons de faire pour démarrer une application modulaire, démarrez
avec `run!` :

``` ruby
# my_app.rb
require 'sinatra/base'

class MyApp < Sinatra::Base
  # ... code de l'application ici ...

  # démarre le serveur si ce fichier est directement exécuté
  run! if app_file == $0
end
```

Démarrez ensuite avec :

``` shell
ruby my_app.rb
```

Ou alors avec un fichier `config.ru`, qui permet d'utiliser n'importe
quel gestionnaire Rack :

``` ruby
# config.ru
require './my_app'
run MyApp
```

Exécutez :

``` shell
rackup -p 4567
```

### Utiliser une application de style classique avec un fichier config.ru

Ecrivez votre application :

``` ruby
# app.rb
require 'sinatra'

get '/' do
  'Bonjour le monde !'
end
```

Et un fichier `config.ru` correspondant :

``` ruby
require './app'
run Sinatra::Application
```

### Quand utiliser un fichier config.ru ?

Quelques cas où vous devriez utiliser un fichier `config.ru` :

* Vous souhaitez déployer avec un autre gestionnaire Rack (Passenger, Unicorn,
  Heroku, ...).
* Vous souhaitez utiliser plus d'une sous-classe de `Sinatra::Base`.
* Vous voulez utiliser Sinatra comme un middleware, non en tant que
  endpoint.

**Il n'est pas nécessaire de passer par un fichier `config.ru` pour la
seule raison que vous êtes passé au style modulaire, et vous n'avez pas besoin
de passer au style modulaire pour utiliser un fichier `config.ru`.**

### Utiliser Sinatra comme Middleware

Non seulement Sinatra peut utiliser d'autres middlewares Rack, il peut
également être à son tour utilisé au-dessus de n'importe quel endpoint Rack
en tant que middleware. Ce endpoint peut très bien être une autre
application Sinatra, ou n'importe quelle application basée sur Rack
(Rails/Ramaze/Camping/...) :

``` ruby
require 'sinatra/base'

class EcranDeConnexion < Sinatra::Base
  enable :sessions

  get('/connexion') { haml :connexion }

  post('/connexion') do
    if params['nom'] = 'admin' && params['motdepasse'] = 'admin'
      session['nom_utilisateur'] = params['nom']
    else
      redirect '/connexion'
    end
  end
end

class MonApp < Sinatra::Base
  # le middleware sera appelé avant les filtres
  use EcranDeConnexion

  before do
    unless session['nom_utilisateur']
      halt "Accès refusé, merci de vous <a href='/connexion'>connecter</a>."
    end
  end

  get('/') { "Bonjour #{session['nom_utilisateur']}." }
end
```

### Création dynamique d'applications

Il se peut que vous ayez besoin de créer une nouvelle application à l'exécution
sans avoir à les assigner à une constante, vous pouvez le faire grâce à
`Sinatra.new` :

``` ruby
require 'sinatra/base'
mon_app = Sinatra.new { get('/') { "salut" } }
mon_app.run!
```

L'application dont elle hérite peut être passé en argument optionnel :

``` ruby
# config.ru
require 'sinatra/base'

controleur = Sinatra.new do
  enable :logging
  helpers MyHelpers
end

map('/a') do
  run Sinatra.new(controleur) { get('/') { 'a' } }
end

map('/b') do
  run Sinatra.new(controleur) { get('/') { 'b' } }
end
```

C'est notamment utile pour tester des extensions à Sinatra ou bien pour
utiliser Sinatra dans votre propre bibliothèque.

Cela permet également d'utiliser très facilement Sinatra comme middleware :

``` ruby
require 'sinatra/base'

use Sinatra do
  get('/') { ... }
end

run RailsProject::Application
```

## Contextes et Binding

Le contexte dans lequel vous êtes détermine les méthodes et variables
disponibles.

### Contexte de l'application/classe

Une application Sinatra correspond à une sous-classe de `Sinatra::Base`. Il
s'agit de `Sinatra::Application` si vous utilisez le DSL de haut niveau
(`require 'sinatra'`). Sinon c'est la sous-classe que vous avez définie. Dans
le contexte de cette classe, vous avez accès aux méthodes telles que `get` ou
`before`, mais pas aux objets `request` ou `session` étant donné que toutes
les requêtes sont traitées par une seule classe d'application.

Les options définies au moyen de `set` deviennent des méthodes de classe :

``` ruby
class MonApp < Sinatra::Base
  # Eh, je suis dans le contexte de l'application !
  set :foo, 42
  foo # => 42

  get '/foo' do
    # Eh, je ne suis plus dans le contexte de l'application !
  end
end
```

Vous avez le binding du contexte de l'application dans :

* Le corps de la classe d'application
* Les méthodes définies par les extensions
* Le bloc passé à `helpers`
* Les procs/blocs utilisés comme argument pour `set`
* Le bloc passé à `Sinatra.new`

Vous pouvez atteindre ce contexte (donc la classe) de la façon suivante :

* Via l'objet passé dans les blocs `configure` (`configure { |c| ... }`)
* En utilisant `settings` dans le contexte de la requête

### Contexte de la requête/instance

Pour chaque requête traitée, une nouvelle instance de votre classe
d'application est créée et tous vos gestionnaires sont exécutés dans ce
contexte. Depuis celui-ci, vous pouvez accéder aux objets `request` et
`session` ou faire appel aux fonctions de rendu telles que `erb` ou `haml`.
Vous pouvez accéder au contexte de l'application depuis le contexte de la
requête au moyen de `settings` :

``` ruby
class MonApp < Sinatra::Base
  # Eh, je suis dans le contexte de l'application !
  get '/ajouter_route/:nom' do
    # Contexte de la requête pour '/ajouter_route/:nom'
    @value = 42

    settings.get("/#{params['nom']}") do
      # Contexte de la requête pour "/#{params['nom']}"
      @value # => nil (on est pas au sein de la même requête)
    end

    "Route ajoutée !"
  end
end
```

Vous avez le binding du contexte de la requête dans :

* les blocs get, head, post, put, delete, options, patch, link et unlink
* les filtres before et after
* les méthodes utilitaires (définies au moyen de `helpers`)
* les vues et templates

### Le contexte de délégation

Le contexte de délégation se contente de transmettre les appels de méthodes au
contexte de classe. Toutefois, il ne se comporte pas à 100% comme le contexte
de classe car vous n'avez pas le binding de la classe : seules les méthodes
spécifiquement déclarées pour délégation sont disponibles et il n'est pas
possible de partager des variables/états avec le contexte de classe
(comprenez : `self` n'est pas le même). Vous pouvez ajouter des délégation de
méthodes en appelant `Sinatra::Delegator.delegate :method_name`.

Vous avez le binding du contexte de délégation dans :

* Le binding de haut niveau, si vous avez utilisé `require "sinatra"`
* Un objet qui inclut le module `Sinatra::Delegator`

Pour vous faire une idée, vous pouvez jeter un coup d'oeil au
[mixin Sinatra::Delegator](https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/base.rb#L1609-1633)
qui [étend l'objet principal](https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/main.rb#L28-30).

## Ligne de commande

Les applications Sinatra peuvent être lancées directement :

``` shell
ruby mon_application.rb [-h] [-x] [-e ENVIRONNEMENT] [-p PORT] [-o HOTE] [-s SERVEUR]
```

Avec les options :

```
-h # aide
-p # déclare le port (4567 par défaut)
-o # déclare l'hôte (0.0.0.0 par défaut)
-e # déclare l'environnement (development par défaut)
-s # déclare le serveur/gestionnaire à utiliser (thin par défaut)
-x # active le mutex lock (off par défaut)
```

## Configuration nécessaire

Les versions suivantes de Ruby sont officiellement supportées :

<dl>
  <dt>Ruby 1.8.7</dt>
  <dd>
    1.8.7 est complètement supporté, toutefois si rien ne vous en empêche,
    nous vous recommandons de faire une mise à jour ou bien de passer à JRuby
    ou Rubinius. Le support de Ruby 1.8.7 ne sera pas supprimé avant la sortie
    de Sinatra 2.0. Ruby 1.8.6 n’est plus supporté.
  </dd>

  <dt>Ruby 1.9.2</dt>
  <dd>
    1.9.2 est totalement supporté. N’utilisez pas 1.9.2p0 car il provoque des
    erreurs de segmentation à l’exécution de Sinatra. Son support continuera
    au minimum jusqu’à la sortie de Sinatra 1.5.
  </dd>

  <dt>Ruby 1.9.3</dt>
  <dd>
    1.9.3 est totalement supporté et recommandé. Nous vous rappelons que passer
    à 1.9.3 depuis une version précédente annulera toutes les sessions. 1.9.3
    sera supporté jusqu'à la sortie de Sinatra 2.0.
  </dd>

  <dt>Ruby 2.0.0</dt>
  <dd>
    2.0.0 est totalement supporté et recommandé. L'abandon de son support
    officiel n'est pas à l'ordre du jour.
  </dd>

  <dt>Rubinius</dt>
  <dd>
    Rubinius est officiellement supporté (Rubinius >= 2.x). Un <tt>gem install
    puma</tt> est recommandé.
  </dd>

  <dt>JRuby</dt>
  <dd>
    La dernière version stable de JRuby est officiellement supportée. Il est
    déconseillé d'utiliser des extensions C avec JRuby. Un <tt>gem install
    trinidad</tt> est recommandé.
  </dd>
</dl>

Nous gardons également un oeil sur les versions Ruby à venir.

Les implémentations Ruby suivantes ne sont pas officiellement supportées mais
sont malgré tout connues pour permettre de faire fonctionner Sinatra :

* Versions plus anciennes de JRuby et Rubinius
* Ruby Enterprise Edition
* MacRuby, Maglev, IronRuby
* Ruby 1.9.0 et 1.9.1 (mais nous déconseillons leur utilisation)

Le fait de ne pas être officiellement supporté signifie que si quelque chose
ne fonctionne pas sur cette plateforme uniquement alors c'est un problème de la
plateforme et pas un bug de Sinatra.

Nous lançons également notre intégration continue (CI) avec ruby-head (la
future 2.1.0), mais nous ne pouvont rien garantir étant donné les évolutions
continuelles. La version 2.1.0 devrait être totalement supportée.

Sinatra devrait fonctionner sur n'importe quel système d'exploitation
supporté par l'implémentation Ruby choisie.

Si vous utilisez MacRuby, vous devriez `gem install control_tower`.

Il n'est pas possible d'utiliser Sinatra sur Cardinal, SmallRuby, BlueRuby ou
toute version de Ruby antérieure à 1.8.7 à l'heure actuelle.

## Essuyer les plâtres

Si vous souhaitez tester la toute dernière version de Sinatra, n'hésitez pas
à faire tourner votre application sur la branche master, celle-ci devrait être
stable.

Pour cela, la méthode la plus simple est d'installer une gem de prerelease que
nous publions de temps en temps :

``` shell
gem install sinatra --pre
```
Ce qui permet de bénéficier des toutes dernières fonctionnalités.

### Installer avec Bundler

Il est cependant conseillé de passer par [Bundler](http://gembundler.com/) pour
faire tourner votre application avec la dernière version de Sinatra.

Pour commencer, installez bundler si nécessaire :

``` shell
gem install bundler
```

Ensuite, créez un fichier `Gemfile` dans le dossier de votre projet :

``` ruby
source 'https://rubygems.org'
gem 'sinatra', :github => "sinatra/sinatra"

# autres dépendances
gem 'haml'                    # si par exemple vous utilisez haml
gem 'activerecord', '~> 3.0'  # au cas où vous auriez besoin de ActiveRecord 3.x
```

Notez que vous devez lister toutes les dépendances de votre application dans
ce fichier `Gemfile`. Les dépendances directes de Sinatra (Rack et Tilt) seront
automatiquement téléchargées et ajoutées par Bundler.

Vous pouvez alors lancer votre application de la façon suivante :

``` shell
bundle exec ruby myapp.rb
```

### Faire un clone local

Si vous ne souhaitez pas employer Bundler, vous pouvez cloner Sinatra en local
dans votre projet et démarrez votre application avec le dossier `sinatra/lib`
dans le `$LOAD_PATH` :

``` shell
cd myapp
git clone git://github.com/sinatra/sinatra.git
ruby -I sinatra/lib myapp.rb
```

Et de temps en temps, vous devrez récupérer la dernière version du code source
de Sinatra :

``` shell
cd myapp/sinatra
git pull
```

### Installer globalement

Une dernière méthode consiste à construire la gem vous-même :

``` shell
git clone git://github.com/sinatra/sinatra.git
cd sinatra
rake sinatra.gemspec
rake install
```

Si vous installez les gems en tant que root, vous devez encore faire un :

``` shell
sudo rake install
```

## Versions

Sinatra se conforme aux [versions sémantiques](http://semver.org/), aussi bien
SemVer que SemVerTag.

## Mais encore

* [Site internet](http://www.sinatrarb.com/) - Plus de documentation,
  de news, et des liens vers d'autres ressources.
* [Contribuer](http://www.sinatrarb.com/contributing) - Vous avez trouvé un
  bug ? Besoin d'aide ? Vous avez un patch ?
* [Suivi des problèmes](http://github.com/sinatra/sinatra/issues)
* [Twitter](http://twitter.com/sinatra)
* [Mailing List](http://groups.google.com/group/sinatrarb/topics)
* IRC : [#sinatra](irc://chat.freenode.net/#sinatra) sur http://freenode.net
* [Sinatra Book](https://github.com/sinatra/sinatra-book/) Tutoriels et recettes
* [Sinatra Recipes](http://recipes.sinatrarb.com/) trucs et astuces rédigés par
  la communauté
* Documentation API de la [dernière version](http://rubydoc.info/gems/sinatra)
  ou du [HEAD courant](http://rubydoc.info/github/sinatra/sinatra) sur
  http://rubydoc.info
* [CI server](http://travis-ci.org/sinatra/sinatra)
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.= polyglot

* http://github.com/cjheath/polyglot

== DESCRIPTION:

Author:	    Clifford Heath, 2007

The Polyglot library allows a Ruby module to register a loader
for the file type associated with a filename extension, and it
augments 'require' to find and load matching files.

This supports the creation of DSLs having a syntax that is most
appropriate to their purpose, instead of abusing the Ruby syntax.

Files are sought using the normal Ruby search path.

== EXAMPLE:

In file rubyglot.rb, define and register a file type handler:

    require 'polyglot'

    class RubyglotLoader
      def self.load(filename, options = nil, &block)
	File.open(filename) {|file|
	  # Load the contents of file as Ruby code:
	  # Implement your parser here instead!
	  Kernel.eval(file.read)
	}
      end
    end

    Polyglot.register("rgl", RubyglotLoader)

In file test.rb:

    require 'rubyglot'	# Create my file type handler
    require 'hello'	# Can add extra options or even a block here
    puts "Ready to go"
    Hello.new

In file hello.rgl (this simple example uses Ruby code):

    puts "Initializing"
    class Hello
      def initialize()
	puts "Hello, world\n"
      end
    end

Run:

    $ ruby test.rb
    Initializing
    Ready to go
    Hello, world
    $

== INSTALL:

sudo gem install polyglot

== LICENSE:

(The MIT License)

Copyright (c) 2007 Clifford Heath

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.[gem]: https://rubygems.org/gems/virtus
[travis]: https://travis-ci.org/solnic/virtus
[gemnasium]: https://gemnasium.com/solnic/virtus
[codeclimate]: https://codeclimate.com/github/solnic/virtus
[coveralls]: https://coveralls.io/r/solnic/virtus
[inchpages]: http://inch-ci.org/github/solnic/virtus/

Virtus
======

# Ruby Object Mapper

[![Gem Version](https://badge.fury.io/rb/virtus.svg)][gem]
[![Build Status](https://travis-ci.org/solnic/virtus.svg?branch=master)][travis]
[![Dependency Status](https://gemnasium.com/solnic/virtus.png)][gemnasium]
[![Code Climate](https://codeclimate.com/github/solnic/virtus/badges/gpa.svg)][codeclimate]
[![Test Coverage](https://codeclimate.com/github/solnic/virtus/badges/coverage.svg)][codeclimate]
[![Inline docs](http://inch-ci.org/github/solnic/virtus.svg?branch=master)][inchpages]

Virtus allows you to define attributes on classes, modules or class instances with
optional information about types, reader/writer method visibility and coercion
behavior. It supports a lot of coercions and advanced mapping of embedded objects
and collections.

You can use it in many different contexts like:

* Input parameter sanitization and coercion in web applications
* Mapping JSON to domain objects
* Encapsulating data-access in Value Objects
* Domain model prototyping

And probably more.

Installation
------------

``` terminal
$ gem install virtus
```

or in your **Gemfile**

``` ruby
gem 'virtus'
```

Examples
--------

### Using Virtus with Classes

You can create classes extended with Virtus and define attributes:

``` ruby
class User
  include Virtus.model

  attribute :name, String
  attribute :age, Integer
  attribute :birthday, DateTime
end

user = User.new(:name => 'Piotr', :age => 31)
user.attributes # => { :name => "Piotr", :age => 31 }

user.name # => "Piotr"

user.age = '31' # => 31
user.age.class # => Fixnum

user.birthday = 'November 18th, 1983' # => #<DateTime: 1983-11-18T00:00:00+00:00 (4891313/2,0/1,2299161)>

# mass-assignment
user.attributes = { :name => 'Jane', :age => 21 }
user.name # => "Jane"
user.age  # => 21
```

### Cherry-picking extensions

``` ruby
# include attribute DSL + constructor + mass-assignment
class User
  include Virtus.model

  attribute :name, String
end

user = User.new(:name => 'Piotr')
user.attributes = { :name => 'John' }
user.attributes
# => {:name => 'John'}

# include attribute DSL + constructor
class User
  include Virtus.model(:mass_assignment => false)

  attribute :name, String
end

User.new(:name => 'Piotr')

# include just the attribute DSL
class User
  include Virtus.model(:constructor => false, :mass_assignment => false)

  attribute :name, String
end

user = User.new
user.name = 'Piotr'
```

### Using Virtus with Modules

You can create modules extended with Virtus and define attributes for later
inclusion in your classes:

```ruby
module Name
  include Virtus.module

  attribute :name, String
end

module Age
  include Virtus.module(:coerce => false)

  attribute :age, Integer
end

class User
  include Name, Age
end

user = User.new(:name => 'John', :age => 30)
```

### Dynamically Extending Instances

It's also possible to dynamically extend an object with Virtus:

```ruby
class User
  # nothing here
end

user = User.new
user.extend(Virtus.model)
user.attribute :name, String
user.name = 'John'
user.name # => 'John'
```

### Default Values

``` ruby
class Page
  include Virtus.model

  attribute :title, String

  # default from a singleton value (integer in this case)
  attribute :views, Integer, :default => 0

  # default from a singleton value (boolean in this case)
  attribute :published, Boolean, :default => false

  # default from a callable object (proc in this case)
  attribute :slug, String, :default => lambda { |page, attribute| page.title.downcase.gsub(' ', '-') }

  # default from a method name as symbol
  attribute :editor_title, String,  :default => :default_editor_title

  def default_editor_title
    published? ? title : "UNPUBLISHED: #{title}"
  end
end

page = Page.new(:title => 'Virtus README')
page.slug         # => 'virtus-readme'
page.views        # => 0
page.published    # => false
page.editor_title # => "UNPUBLISHED: Virtus README"

page.views = 10
page.views                    # => 10
page.reset_attribute(:views)  # => 0
page.views                    # => 0
```

### Default values on dynamically extended instances

This requires you to set `:lazy` option because default values are set in the
constructor if it's set to false (which is the default setting):

``` ruby
User = Class.new
user = User.new
user.extend(Virtus.model)
user.attribute :name, String, default: 'jane', lazy: true
user.name # => "jane"
```

### Embedded Value

``` ruby
class City
  include Virtus.model

  attribute :name, String
end

class Address
  include Virtus.model

  attribute :street,  String
  attribute :zipcode, String
  attribute :city,    City
end

class User
  include Virtus.model

  attribute :name,    String
  attribute :address, Address
end

user = User.new(:address => {
  :street => 'Street 1/2', :zipcode => '12345', :city => { :name => 'NYC' } })

user.address.street # => "Street 1/2"
user.address.city.name # => "NYC"
```

### Collection Member Coercions

``` ruby
# Support "primitive" classes
class Book
  include Virtus.model

  attribute :page_numbers, Array[Integer]
end

book = Book.new(:page_numbers => %w[1 2 3])
book.page_numbers # => [1, 2, 3]

# Support EmbeddedValues, too!
class Address
  include Virtus.model

  attribute :address,     String
  attribute :locality,    String
  attribute :region,      String
  attribute :postal_code, String
end

class PhoneNumber
  include Virtus.model

  attribute :number, String
end

class User
  include Virtus.model

  attribute :phone_numbers, Array[PhoneNumber]
  attribute :addresses,     Set[Address]
end

user = User.new(
  :phone_numbers => [
    { :number => '212-555-1212' },
    { :number => '919-444-3265' } ],
  :addresses => [
    { :address => '1234 Any St.', :locality => 'Anytown', :region => "DC", :postal_code => "21234" } ])

user.phone_numbers # => [#<PhoneNumber:0x007fdb2d3bef88 @number="212-555-1212">, #<PhoneNumber:0x007fdb2d3beb00 @number="919-444-3265">]

user.addresses # => #<Set: {#<Address:0x007fdb2d3be448 @address="1234 Any St.", @locality="Anytown", @region="DC", @postal_code="21234">}>
```

### Hash attributes coercion

``` ruby
class Package
  include Virtus.model

  attribute :dimensions, Hash[Symbol => Float]
end

package = Package.new(:dimensions => { 'width' => "2.2", :height => 2, "length" => 4.5 })
package.dimensions # => { :width => 2.2, :height => 2.0, :length => 4.5 }
```

### IMPORTANT note about Boolean type

Be aware that some libraries may do a terrible thing and define a global Boolean
constant which breaks virtus' constant type lookup, if you see issues with the
boolean type you can workaround it like that:

``` ruby
class User
  include Virtus.model

  attribute :admin, Axiom::Types::Boolean
end
```

This will be improved in Virtus 2.0.

### IMPORTANT note about member coercions

Virtus performs coercions only when a value is being assigned. If you mutate the value later on using its own
interfaces then coercion won't be triggered.

Here's an example:

``` ruby
class Book
  include Virtus.model

  attribute :title, String
end

class Library
  include Virtus.model

  attribute :books, Array[Book]
end

library = Library.new

# This will coerce Hash to a Book instance
library.books = [ { :title => 'Introduction to Virtus' } ]

# This WILL NOT COERCE the value because you mutate the books array with Array#<<
library.books << { :title => 'Another Introduction to Virtus' }
```

A suggested solution to this problem would be to introduce your own class instead of using Array and implement
mutation methods that perform coercions. For example:

``` ruby
class Book
  include Virtus.model

  attribute :title, String
end

class BookCollection < Array
  def <<(book)
   if book.kind_of?(Hash)
    super(Book.new(book))
   else
     super
   end
  end
end

class Library
  include Virtus.model

  attribute :books, BookCollection[Book]
end

library = Library.new
library.books << { :title => 'Another Introduction to Virtus' }
```

### Value Objects

``` ruby
class GeoLocation
  include Virtus.value_object

  values do
    attribute :latitude,  Float
    attribute :longitude, Float
  end
end

class Venue
  include Virtus.value_object

  values do
    attribute :name,     String
    attribute :location, GeoLocation
  end
end

venue = Venue.new(
  :name     => 'Pub',
  :location => { :latitude => 37.160317, :longitude => -98.437500 })

venue.location.latitude # => 37.160317
venue.location.longitude # => -98.4375

# Supports object's equality

venue_other = Venue.new(
  :name     => 'Other Pub',
  :location => { :latitude => 37.160317, :longitude => -98.437500 })

venue.location === venue_other.location # => true
```

### Custom Coercions

``` ruby
require 'json'

class Json < Virtus::Attribute
  def coerce(value)
    value.is_a?(::Hash) ? value : JSON.parse(value)
  end
end

class User
  include Virtus.model

  attribute :info, Json, default: {}
end

user = User.new
user.info = '{"email":"john@domain.com"}' # => {"email"=>"john@domain.com"}
user.info.class # => Hash

# With a custom attribute encapsulating coercion-specific configuration
class NoisyString < Virtus::Attribute
  def coerce(value)
    value.to_s.upcase
  end
end

class User
  include Virtus.model

  attribute :scream, NoisyString
end

user = User.new(:scream => 'hello world!')
user.scream # => "HELLO WORLD!"
```

### Private Attributes

``` ruby
class User
  include Virtus.model

  attribute :unique_id, String, :writer => :private

  def set_unique_id(id)
    self.unique_id = id
  end
end

user = User.new(:unique_id => '1234-1234')
user.unique_id # => nil

user.unique_id = '1234-1234' # => NoMethodError: private method `unique_id='

user.set_unique_id('1234-1234')
user.unique_id # => '1234-1234'
```

### Overriding setters

``` ruby
class User
  include Virtus.model

  attribute :name, String

  def name=(new_name)
    custom_name = nil
    if new_name == "Godzilla"
      custom_name = "Can't tell"
    end
    super custom_name || new_name
  end
end

user = User.new(name: "Frank")
user.name # => 'Frank'

user = User.new(name: "Godzilla")
user.name # => 'Can't tell'

```

## Strict Coercion Mode

By default Virtus returns the input value even when it couldn't coerce it to the expected type.
If you want to catch such cases in a noisy way you can use the strict mode in which
Virtus raises an exception when it failed to coerce an input value.

``` ruby
class User
  include Virtus.model(:strict => true)

  attribute :admin, Boolean
end

# this will raise an error
User.new :admin => "can't really say if true or false"
```

## Nullify Blank Strings Mode

If you want to replace empty Strings with `nil` values (since they can't be
coerced into the expected type), you can use the `:nullify_blank` option.

``` ruby
class User
  include Virtus.model(:nullify_blank => true)

  attribute :birthday, Date
end

User.new(:birthday => "").birthday # => nil
```


## Building modules with custom configuration

You can also build Virtus modules that contain their own configuration.

```ruby
YupNopeBooleans = Virtus.model { |mod|
  mod.coerce = true
  mod.coercer.config.string.boolean_map = { 'nope' => false, 'yup' => true }
}

class User
  include YupNopeBooleans

  attribute :name, String
  attribute :admin, Boolean
end

# Or just include the module straight away ...
class User
  include Virtus.model(:coerce => false)

  attribute :name, String
  attribute :admin, Boolean
end
```

## Attribute Finalization and Circular Dependencies

If a type references another type which happens to not be available yet you need
to use lazy-finalization of attributes and finalize virtus manually after all
types have been already loaded:

``` ruby
# in blog.rb
class Blog
  include Virtus.model(:finalize => false)

  attribute :posts, Array['Post']
end

# in post.rb
class Post
  include Virtus.model(:finalize => false)

  attribute :blog, 'Blog'
end

# after loading both files just do:
Virtus.finalize

# constants will be resolved:
Blog.attribute_set[:posts].member_type.primitive # => Post
Post.attribute_set[:blog].type.primitive # => Blog
```

Ruby version support
--------------------

Virtus is known to work correctly with the following rubies:

* 1.9.3
* 2.0.0
* 2.1.2
* jruby
* (probably) rbx

Credits
-------

* Dan Kubb ([dkubb](https://github.com/dkubb))
* Chris Corbyn ([d11wtq](https://github.com/d11wtq))
* Emmanuel Gomez ([emmanuel](https://github.com/emmanuel))
* Fabio Rehm ([fgrehm](https://github.com/fgrehm))
* Ryan Closner ([rclosner](https://github.com/rclosner))
* Markus Schirp ([mbj](https://github.com/mbj))
* Yves Senn ([senny](https://github.com/senny))

Contributing
-------------

* Fork the project.
* Make your feature addition or bug fix.
* Add tests for it. This is important so I don't break it in a
  future version unintentionally.
* Commit, do not mess with Rakefile or version
  (if you want to have your own version, that is fine but bump version in a commit by itself I can ignore when I pull)
* Send me a pull request. Bonus points for topic branches.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.ice_nine
========

Deep freeze ruby objects

[![Gem Version](https://badge.fury.io/rb/ice_nine.svg)][gem]
[![Build Status](https://secure.travis-ci.org/dkubb/ice_nine.svg?branch=master)][travis]
[![Dependency Status](https://gemnasium.com/dkubb/ice_nine.svg)][gemnasium]
[![Code Climate](https://codeclimate.com/github/dkubb/ice_nine.png)][codeclimate]
[![Coverage Status](https://coveralls.io/repos/dkubb/ice_nine/badge.png?branch=master)][coveralls]
[![Inline docs](http://inch-ci.org/github/dkubb/ice_nine.svg?branch=master)][inch]

[gem]: https://rubygems.org/gems/ice_nine
[travis]: https://travis-ci.org/dkubb/ice_nine
[gemnasium]: https://gemnasium.com/dkubb/ice_nine
[codeclimate]: https://codeclimate.com/github/dkubb/ice_nine
[coveralls]: https://coveralls.io/r/dkubb/ice_nine
[inch]: http://inch-ci.org/github/dkubb/ice_nine

Examples
--------

```ruby
require 'ice_nine'

# Deep freezes most kinds of objects
hash   = IceNine.deep_freeze('a' => '1')
array  = IceNine.deep_freeze([ 'a', 'b', 'c' ])
range  = IceNine.deep_freeze('a'..'z')
struct = IceNine.deep_freeze(Struct.new(:a, :b).new('a', 'b'))
object = IceNine.deep_freeze(Object.new)
user   = IceNine.deep_freeze(User.new(name: 'dkubb'))

# Faster deep freeze that skips deep-freezing frozen objects
object = IceNine.deep_freeze!(Object.new)

# Add core extension for Object#deep_freeze (not required by default)
require 'ice_nine'
require 'ice_nine/core_ext/object'

object = Object.new
object.deep_freeze
```

Contributing
------------

See [CONTRIBUTING.md](CONTRIBUTING.md) for details.

Copyright
---------

Copyright &copy; 2012-2014 Dan Kubb. See LICENSE for details.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Manticore

[![Build Status](https://travis-ci.org/cheald/manticore.png?branch=master)](https://travis-ci.org/cheald/manticore)

Manticore is a fast, robust HTTP client built on the Apache HTTPClient libraries. It is only compatible with JRuby.

## Installation

Add this line to your application's Gemfile:

    gem 'manticore'

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install manticore

## Documentation

  Documentation is available [at rubydoc.info](http://rubydoc.info/github/cheald/manticore/master/frames).

## Performance

  Manticore is [very fast](https://github.com/cheald/manticore/wiki/Performance).

## Major Features

  As it's built on the Apache Commons HTTP components, Manticore is very rich. It includes support for:

  * Keepalive connections (and connection pooling)
  * Transparent gzip and deflate handling
  * Transparent cookie handling
  * Both synchronous and asynchronous execution models
  * Lazy evaluation
  * Authentication
  * Proxy support
  * SSL

## Usage

### Quick Start

If you don't want to worry about setting up and maintaining client pools, Manticore comes with a facade that you can use to start making requests right away:

```ruby
document_body = Manticore.get("http://www.google.com/").body

# Or

document_body = Manticore.http(:get, "http://www.google.com/").body
```

This is threadsafe and automatically backed with a pool, so you can execute `Manticore.get` in multiple threads without harming performance.

Alternately, you can mix the `Manticore::Facade` into your own class for similar behavior:

```ruby
class MyClient
  include Manticore::Facade
  include_http_client user_agent: "MyClient/1.0"
end

response_code = MyClient.get("http://www.google.com/").code
```

Mixing the client into a class will create a new new pool. If you want to share a single pool between clients, specify the `shared_pool` option:

```ruby
class MyClient
  include Manticore::Facade
  include_http_client shared_pool: true
end

class MyOtherClient
  include Manticore::Facade
  include_http_client shared_pool: true
end
```

For detailed documentation, see the [full Manticore::Client documentation](http://www.rubydoc.info/github/cheald/manticore/master/Manticore/Client).

### Configuring clients

Rather than using the Facade, you can create your own standalone Client instances. When you create a `Client`, you will pass various parameters that it will use to set up the pool.

```ruby
client = Manticore::Client.new(request_timeout: 5, connect_timeout: 5, socket_timeout: 5, pool_max: 10, pool_max_per_route: 2)
```

Then, you can make requests from the client. Pooling and route maximum constraints are automatically managed:

```ruby
response = client.get("http://www.google.com/")
body = response.body
```

It is recommend that you instantiate a client once, then re-use it, rather than instantiating a new client per request.

Additionally, if you pass a block to the initializer, the underlying [HttpClientBuilder](http://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/impl/client/HttpClientBuilder.html) and [RequestConfig.Builder](http://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/client/config/RequestConfig.Builder.html) will be yielded so that you can operate on them directly:

```ruby
client = Manticore::Client.new(socket_timeout: 5) do |http_client_builder, request_builder|
  http_client_builder.disable_redirect_handling
end
```

### Pools

You've seen "pools" mentioned a few times. Manticore creates and configures a [PoolingHttpClientConnectionManager](http://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/impl/conn/PoolingHttpClientConnectionManager.html)
which all requests are run through. The advantage here is that configuration and setup is performed once, and this lets clients take advantage of things like keepalive,
per-route concurrency limits, and other neat things. In general, you should create one `Manticore::Client` instance pe unique configuration needed. For example, you might have an app that performs 2 functions:

1. General HTTP requesting from the internet-at-large
2. Communication with a backend service over SSL, using a custom trust store

To set this up, you might create 2 pools, each configured for the task:

```ruby
general_http_client    = Manticore::Client.new connect_timeout: 10, socket_timeout: 10, request_timeout: 10, follow_redirects: true, max_per_route: 2
proxied_backend_client = Manticore::Client.new proxy: "https://backend.internal:4242", truststore: "./truststore.jks", truststore_password: "s3cr3t"
```

This would create 2 separate request pools; the first would be configured with generous timeouts and redirect following, and would use the system
default trust stores (ie, the normal certs used to verify SSL certificates with the normal certificate authorities). Additionally, it will only permit
2 concurrent requests to a given domain ("route") at a time; this can be nice for web crawling or fetching against rate-limited APIs, to help you stay
under your rate limits even when executing in a parallel context. The second client would use a custom trust store to recognize certs signed with your
internal CA, and would proxy all requests through an internal server.

Creating pools is expensive, so you don't want to be doing it for each request. Instead, you should set up your pools once and then re-use them.
Clients and their backing pools are thread-safe, so feel free to set them up once before you start performing parallel operations.


### Parallel execution

Manticore can perform concurrent execution of multiple requests.

```ruby
client = Manticore::Client.new

# These aren't actually executed until #execute! is called.
# You can define response handlers in a block when you queue the request:
client.async.get("http://www.google.com") {|req|
  req.on_success do |response|
    puts response.body
  end

  req.on_failure do |exception|
    puts "Boom! #{exception.message}"
  end
}

# ...or by invoking the method on the queued response returned:
response = client.async.get("http://www.yahoo.com")
response.on_success do |response|
  puts "The length of the Yahoo! homepage is #{response.body.length}"
end

# ...or even by chaining them onto the call
client.async.get("http://bing.com").
  on_success {|r| puts r.code }.
  on_failure {|e| puts "on noes!"}

client.execute!
```

### Lazy Evaluation

Manticore attempts to avoid doing any actual work until right before you need results. As a result,
responses are lazy-evaluated as late as possible. The following rules apply:

1. Synchronous responses are evaluted when you call an accessor on them, like `#body` or `#headers`.
2. Synchronous responses which pass a handler block are evaluated immediately.
3. Asynchronous responses are always evaluated when you call `Client#execute!`
4. Background responses are always immediately evaluated, but return a `Future`.

As a result, with the exception of background requests, this allows you to attach handlers to synchronous
and asynchronous responses in the same fashion:

```ruby
# Response doesn't evaluate when you call get, since you don't need any results from it yet
response = client.get("http://google.com").on_success {|r| "Success handler!" }
# As soon as you request #body, the response will evaluate to a result.
body = response.body

response = client.async.get("http://google.com").on_success {|r| "Success handler!" }
client.execute!
body = response.body
```

If you want to make a response that is not lazy-evaluated, you can either pass a handler block to it, or you can
call `#call` on the resulting response:

```ruby
# This will evaluate immediately
client.get("http://google.com") {r| r.body }

# As will this, via explicit invocation of #call
client.get("http://google.com").call
```

### Stubbing

Manticore provides a stubbing interface somewhat similar to Typhoeus'

```ruby
client.stub("http://google.com", body: "response body", code: 200)
client.get("http://google.com") do |response|
  response.body.should == "response body"
end
client.clear_stubs!
```

This works for async requests as well:

```ruby
client.stub("http://google.com", body: "response body", code: 200)

# The request to google.com returns a stub as expected
client.async.get("http://google.com").on_success do |response|
  response.should be_a Manticore::ResponseStub
end

# Since yahoo.com isn't stubbed, a full request will be performed
client.async.get("http://yahoo.com").on_success do |response|
  response.should be_a Manticore::Response
end
client.clear_stubs!
```

If you don't want to worry about stub teardown, you can just use `#respond_with`, which will stub the next
response the client makes with a ResponseStub rather than permitting it to execute a remote request.

```ruby
client.respond_with(body: "body").get("http://google.com") do |response|
  response.body.should == "body"
end
```

You can also chain proxies to, say, stub an async request:

```ruby
response = client.async.respond_with(body: "response body").get("http://google.com")
client.execute!

response.body.should == "response body"
```

Additionally, you can stub and unstub individual URLs as desired:
```ruby
client.stub("http://google.com", body: "response body", code: 200)
client.stub("http://yahoo.com",  body: "response body", code: 200)

# The request to google.com returns a stub as expected
client.get("http://google.com") do |response|
  response.should be_a Manticore::ResponseStub
end

# After this point, yahoo will remain stubbed, while google will not.
client.unstub("http://google.com")
```

### Background requests

You might want to fire-and-forget requests without blocking your calling thread. You can do this with `Client#background`:

```ruby
future = client.background.get("http://google.com")
# The request is now running, but the calling thread isn't blocked
# Do whatever stuff you need to right now. At some point, if you want the result of the request, you can call `Future#get`:
response = future.get
```

## Contributing

1. Fork it
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Add some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create new Pull Request
## Awesome Print ##

[![RubyGems][gem_version_badge]][ruby_gems]
[![Travis CI][travis_ci_badge]][travis_ci]
[![Code Climate][code_climate_badge]][code_climate]
[![RubyGems][gem_downloads_badge]][ruby_gems]
[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/michaeldv/awesome_print?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)


Awesome Print is a Ruby library that pretty prints Ruby objects in full color
exposing their internal structure with proper indentation. Rails ActiveRecord
objects and usage within Rails templates are supported via included mixins.

__NOTE__: awesome_print v1.2.0 is the last release supporting Ruby versions
prior to v1.9.3 and Rails versions prior to v3.0. The upcoming awesome_print
v2.0 will *require* Ruby v1.9.3 or later and Rails v3.0 or later.

### Installation ###
    # Installing as Ruby gem
    $ gem install awesome_print

    # Cloning the repository
    $ git clone git://github.com/michaeldv/awesome_print.git

### Usage ###

```ruby
require "awesome_print"
ap object, options = {}
```

Default options:

```ruby
:indent     => 4,      # Indent using 4 spaces.
:index      => true,   # Display array indices.
:html       => false,  # Use ANSI color codes rather than HTML.
:multiline  => true,   # Display in multiple lines.
:plain      => false,  # Use colors.
:raw        => false,  # Do not recursively format object instance variables.
:sort_keys  => false,  # Do not sort hash keys.
:limit      => false,  # Limit large output for arrays and hashes. Set to a boolean or integer.
:color => {
  :args       => :pale,
  :array      => :white,
  :bigdecimal => :blue,
  :class      => :yellow,
  :date       => :greenish,
  :falseclass => :red,
  :fixnum     => :blue,
  :float      => :blue,
  :hash       => :pale,
  :keyword    => :cyan,
  :method     => :purpleish,
  :nilclass   => :red,
  :rational   => :blue,
  :string     => :yellowish,
  :struct     => :pale,
  :symbol     => :cyanish,
  :time       => :greenish,
  :trueclass  => :green,
  :variable   => :cyanish
}
```

Supported color names:

```ruby
:gray, :red, :green, :yellow, :blue, :purple, :cyan, :white
:black, :redish, :greenish, :yellowish, :blueish, :purpleish, :cyanish, :pale
```

### Examples ###

```ruby
$ cat > 1.rb
require "awesome_print"
data = [ false, 42, %w(forty two), { :now => Time.now, :class => Time.now.class, :distance => 42e42 } ]
ap data
^D
$ ruby 1.rb
[
    [0] false,
    [1] 42,
    [2] [
        [0] "forty",
        [1] "two"
    ],
    [3] {
           :class => Time < Object,
             :now => Fri Apr 02 19:55:53 -0700 2010,
        :distance => 4.2e+43
    }
]

$ cat > 2.rb
require "awesome_print"
data = { :now => Time.now, :class => Time.now.class, :distance => 42e42 }
ap data, :indent => -2  # <-- Left align hash keys.
^D
$ ruby 2.rb
{
  :class    => Time < Object,
  :now      => Fri Apr 02 19:55:53 -0700 2010,
  :distance => 4.2e+43
}

$ cat > 3.rb
require "awesome_print"
data = [ false, 42, %w(forty two) ]
data << data  # <-- Nested array.
ap data, :multiline => false
^D
$ ruby 3.rb
[ false, 42, [ "forty", "two" ], [...] ]

$ cat > 4.rb
require "awesome_print"
class Hello
  def self.world(x, y, z = nil, &blk)
  end
end
ap Hello.methods - Class.methods
^D
$ ruby 4.rb
[
    [0] world(x, y, *z, &blk) Hello
]

$ cat > 5.rb
require "awesome_print"
ap (''.methods - Object.methods).grep(/!/)
^D
$ ruby 5.rb
[
    [ 0] capitalize!()           String
    [ 1]      chomp!(*arg1)      String
    [ 2]       chop!()           String
    [ 3]     delete!(*arg1)      String
    [ 4]   downcase!()           String
    [ 5]     encode!(*arg1)      String
    [ 6]       gsub!(*arg1)      String
    [ 7]     lstrip!()           String
    [ 8]       next!()           String
    [ 9]    reverse!()           String
    [10]     rstrip!()           String
    [11]      slice!(*arg1)      String
    [12]    squeeze!(*arg1)      String
    [13]      strip!()           String
    [14]        sub!(*arg1)      String
    [15]       succ!()           String
    [16]   swapcase!()           String
    [17]         tr!(arg1, arg2) String
    [18]       tr_s!(arg1, arg2) String
    [19]     upcase!()           String
]

$ cat > 6.rb
require "awesome_print"
ap 42 == ap(42)
^D
$ ruby 6.rb
42
true
$ cat 7.rb
require "awesome_print"
some_array = (1..1000).to_a
ap some_array, :limit => true
^D
$ ruby 7.rb
[
    [  0] 1,
    [  1] 2,
    [  2] 3,
    [  3] .. [996],
    [997] 998,
    [998] 999,
    [999] 1000
]

$ cat 8.rb
require "awesome_print"
some_array = (1..1000).to_a
ap some_array, :limit => 5
^D
$ ruby 8.rb
[
    [  0] 1,
    [  1] 2,
    [  2] .. [997],
    [998] 999,
    [999] 1000
]
```

### Example (Rails console) ###
```ruby
$ rails console
rails> require "awesome_print"
rails> ap Account.limit(2).all
[
    [0] #<Account:0x1033220b8> {
                     :id => 1,
                :user_id => 5,
            :assigned_to => 7,
                   :name => "Hayes-DuBuque",
                 :access => "Public",
                :website => "http://www.hayesdubuque.com",
        :toll_free_phone => "1-800-932-6571",
                  :phone => "(111)549-5002",
                    :fax => "(349)415-2266",
             :deleted_at => nil,
             :created_at => Sat, 06 Mar 2010 09:46:10 UTC +00:00,
             :updated_at => Sat, 06 Mar 2010 16:33:10 UTC +00:00,
                  :email => "info@hayesdubuque.com",
        :background_info => nil
    },
    [1] #<Account:0x103321ff0> {
                     :id => 2,
                :user_id => 4,
            :assigned_to => 4,
                   :name => "Ziemann-Streich",
                 :access => "Public",
                :website => "http://www.ziemannstreich.com",
        :toll_free_phone => "1-800-871-0619",
                  :phone => "(042)056-1534",
                    :fax => "(106)017-8792",
             :deleted_at => nil,
             :created_at => Tue, 09 Feb 2010 13:32:10 UTC +00:00,
             :updated_at => Tue, 09 Feb 2010 20:05:01 UTC +00:00,
                  :email => "info@ziemannstreich.com",
        :background_info => nil
    }
]
rails> ap Account
class Account < ActiveRecord::Base {
                 :id => :integer,
            :user_id => :integer,
        :assigned_to => :integer,
               :name => :string,
             :access => :string,
            :website => :string,
    :toll_free_phone => :string,
              :phone => :string,
                :fax => :string,
         :deleted_at => :datetime,
         :created_at => :datetime,
         :updated_at => :datetime,
              :email => :string,
    :background_info => :string
}
rails>
```

### IRB integration ###
To use awesome_print as default formatter in irb and Rails console add the following
code to your ~/.irbrc file:

```ruby
require "awesome_print"
AwesomePrint.irb!
```

### PRY integration ###
If you miss awesome_print's way of formatting output, here's how you can use it in place
of the formatting which comes with pry. Add the following code to your ~/.pryrc:

```ruby
require "awesome_print"
AwesomePrint.pry!
```

### Logger Convenience Method ###
awesome_print adds the 'ap' method to the Logger and ActiveSupport::BufferedLogger classes
letting you call:

    logger.ap object

By default, this logs at the :debug level. You can override that globally with:

    :log_level => :info

in the custom defaults (see below). You can also override on a per call basis with:

    logger.ap object, :warn

### ActionView Convenience Method ###
awesome_print adds the 'ap' method to the ActionView::Base class making it available
within Rails templates. For example:

    <%= ap @accounts.first %>   # ERB
    != ap @accounts.first       # HAML

With other web frameworks (ex: in Sinatra templates) you can explicitly request HTML
formatting:

    <%= ap @accounts.first, :html => true %>

### Setting Custom Defaults ###
You can set your own default options by creating ``.aprc`` file in your home
directory. Within that file assign your  defaults to ``AwesomePrint.defaults``.
For example:

```ruby
# ~/.aprc file.
AwesomePrint.defaults = {
  :indent => -2,
  :color => {
    :hash  => :pale,
    :class => :white
  }
}
```

## Versioning

AwesomePrint follows the [Semantic Versioning](http://semver.org/) standard.

### Running Specs ###

    $ gem install rspec           # RSpec 2.x is the requirement.
    $ rake spec                   # Run the entire spec suite.
    $ rspec spec/logger_spec.rb   # Run individual spec file.

### Note on Patches/Pull Requests ###
* Fork the project on Github.
* Make your feature addition or bug fix.
* Add specs for it, making sure $ rake spec is all green.
* Commit, do not mess with rakefile, version, or history.
* Send commit URL (*do not* send pull requests).

### Contributors ###
Special thanks goes to awesome team of contributors, namely:

* 6fusion.com -- https://github.com/6fusion
* Adam Doppelt -- https://github.com/gurgeous
* Andrew O'Brien -- https://github.com/AndrewO
* Andrew Horsman -- https://github.com/basicxman
* Barry Allard -- https://github.com/steakknife
* Benoit Daloze -- http://github.com/eregon
* Brandon Zylstra -- https://github.com/brandondrew
* Dan Lynn -- https://github.com/danlynn
* Daniel Johnson -- https://github.com/adhd360
* Daniel Bretoi -- http://github.com/danielb2
* Eloy Duran -- http://github.com/alloy
* Elpizo Choi -- https://github.com/fuJiin
* Evan Senter -- https://github.com/evansenter
* George . -- https://github.com/gardelea
* Greg Weber -- https://github.com/gregwebs
* Jan Vansteenkiste -- https://github.com/vStone
* Jeff Felchner -- https://github.com/jfelchner
* Jonathan Davies -- send your Github URL ;-)
* Kevin Olbrich -- https://github.com/olbrich
* Matthew Schulkind -- https://github.com/mschulkind
* Mike McQuaid -- https://github.com/mikemcquaid
* Nami-Doc -- https://github.com/Nami-Doc
* Nicolas Viennot -- https://github.com/nviennot
* Nikolaj Nikolajsen -- https://github.com/nikolajsen
* Richard Hall -- https://github.com/richardardrichard
* Ryan Schlesinger -- https://github.com/ryansch
* Scott Hyndman -- https://github.com/shyndman
* Sean Gallagher -- http://github.com/torandu
* Stephan Hagemann -- https://github.com/shageman
* Tim Harper -- http://github.com/timcharper
* Tobias Crawley -- http://github.com/tobias
* Thibaut Barrère -- https://github.com/thbar
* Trevor Wennblom -- https://github.com/trevor
* vfrride -- https://github.com/vfrride
* Viktar Basharymau -- https://github.com/DNNX

### License ###
Copyright (c) 2010-2013 Michael Dvorkin

http://www.dvorkin.net

%w(mike dvorkin.net) * "@" || "twitter.com/mid"

Released under the MIT license. See LICENSE file for details.

[gem_version_badge]: https://img.shields.io/gem/v/awesome_print.svg?style=flat
[gem_downloads_badge]: http://img.shields.io/gem/dt/awesome_print.svg?style=flat
[ruby_gems]: http://rubygems.org/gems/awesome_print
[travis_ci]: http://travis-ci.org/michaeldv/awesome_print
[travis_ci_badge]: https://img.shields.io/travis/michaeldv/awesome_print.svg?style=flat
[code_climate]: https://codeclimate.com/github/michaeldv/awesome_print
[code_climate_badge]: http://img.shields.io/codeclimate/github/michaeldv/awesome_print.svg?style=flat
# Faraday

Faraday is an HTTP client lib that provides a common interface over many
adapters (such as Net::HTTP) and embraces the concept of Rack middleware when
processing the request/response cycle.

Faraday supports these adapters:

* Net::HTTP
* [Excon][]
* [Typhoeus][]
* [Patron][]
* [EventMachine][]
* [HTTPClient][]

It also includes a Rack adapter for hitting loaded Rack applications through
Rack::Test, and a Test adapter for stubbing requests by hand.

## Usage

```ruby
conn = Faraday.new(:url => 'http://sushi.com') do |faraday|
  faraday.request  :url_encoded             # form-encode POST params
  faraday.response :logger                  # log requests to STDOUT
  faraday.adapter  Faraday.default_adapter  # make requests with Net::HTTP
end

## GET ##

response = conn.get '/nigiri/sake.json'     # GET http://sushi.com/nigiri/sake.json
response.body

conn.get '/nigiri', { :name => 'Maguro' }   # GET http://sushi.com/nigiri?name=Maguro

conn.get do |req|                           # GET http://sushi.com/search?page=2&limit=100
  req.url '/search', :page => 2
  req.params['limit'] = 100
end

## POST ##

conn.post '/nigiri', { :name => 'Maguro' }  # POST "name=maguro" to http://sushi.com/nigiri

# post payload as JSON instead of "www-form-urlencoded" encoding:
conn.post do |req|
  req.url '/nigiri'
  req.headers['Content-Type'] = 'application/json'
  req.body = '{ "name": "Unagi" }'
end

## Per-request options ##

conn.get do |req|
  req.url '/search'
  req.options.timeout = 5           # open/read timeout in seconds
  req.options.open_timeout = 2      # connection open timeout in seconds
end
```

If you don't need to set up anything, you can roll with just the default middleware
stack and default adapter (see [Faraday::RackBuilder#initialize](https://github.com/lostisland/faraday/blob/master/lib/faraday/rack_builder.rb)):

```ruby
response = Faraday.get 'http://sushi.com/nigiri/sake.json'
```

## Advanced middleware usage

The order in which middleware is stacked is important. Like with Rack, the
first middleware on the list wraps all others, while the last middleware is the
innermost one, so that must be the adapter.

```ruby
Faraday.new(...) do |conn|
  # POST/PUT params encoders:
  conn.request :multipart
  conn.request :url_encoded

  conn.adapter :net_http
end
```

This request middleware setup affects POST/PUT requests in the following way:

1. `Request::Multipart` checks for files in the payload, otherwise leaves
  everything untouched;
2. `Request::UrlEncoded` encodes as "application/x-www-form-urlencoded" if not
  already encoded or of another type

Swapping middleware means giving the other priority. Specifying the
"Content-Type" for the request is explicitly stating which middleware should
process it.

Examples:

```ruby
# uploading a file:
payload[:profile_pic] = Faraday::UploadIO.new('/path/to/avatar.jpg', 'image/jpeg')

# "Multipart" middleware detects files and encodes with "multipart/form-data":
conn.put '/profile', payload
```

## Writing middleware

Middleware are classes that implement a `call` instance method. They hook into
the request/response cycle.

```ruby
def call(request_env)
  # do something with the request
  # request_env[:request_headers].merge!(...)

  @app.call(request_env).on_complete do |response_env|
    # do something with the response
    # response_env[:response_headers].merge!(...)
  end
end
```

It's important to do all processing of the response only in the `on_complete`
block. This enables middleware to work in parallel mode where requests are
asynchronous.

The `env` is a hash with symbol keys that contains info about the request and,
later, response. Some keys are:

```
# request phase
:method - :get, :post, ...
:url    - URI for the current request; also contains GET parameters
:body   - POST parameters for :post/:put requests
:request_headers

# response phase
:status - HTTP response status code, such as 200
:body   - the response body
:response_headers
```

## Using Faraday for testing

```ruby
# It's possible to define stubbed request outside a test adapter block.
stubs = Faraday::Adapter::Test::Stubs.new do |stub|
  stub.get('/tamago') { |env| [200, {}, 'egg'] }
end

# You can pass stubbed request to the test adapter or define them in a block
# or a combination of the two.
test = Faraday.new do |builder|
  builder.adapter :test, stubs do |stub|
    stub.get('/ebi') { |env| [ 200, {}, 'shrimp' ]}
  end
end

# It's also possible to stub additional requests after the connection has
# been initialized. This is useful for testing.
stubs.get('/uni') { |env| [ 200, {}, 'urchin' ]}

resp = test.get '/tamago'
resp.body # => 'egg'
resp = test.get '/ebi'
resp.body # => 'shrimp'
resp = test.get '/uni'
resp.body # => 'urchin'
resp = test.get '/else' #=> raises "no such stub" error

# If you like, you can treat your stubs as mocks by verifying that all of
# the stubbed calls were made. NOTE that this feature is still fairly
# experimental: It will not verify the order or count of any stub, only that
# it was called once during the course of the test.
stubs.verify_stubbed_calls
```

## TODO

* support streaming requests/responses
* better stubbing API

## Supported Ruby versions

This library aims to support and is [tested against][travis] the following Ruby
implementations:

* MRI 1.8.7
* MRI 1.9.2
* MRI 1.9.3
* MRI 2.0.0
* MRI 2.1.0
* [JRuby][]
* [Rubinius][]

If something doesn't work on one of these Ruby versions, it's a bug.

This library may inadvertently work (or seem to work) on other Ruby
implementations, however support will only be provided for the versions listed
above.

If you would like this library to support another Ruby version, you may
volunteer to be a maintainer. Being a maintainer entails making sure all tests
run and pass on that implementation. When something breaks on your
implementation, you will be responsible for providing patches in a timely
fashion. If critical issues for a particular implementation exist at the time
of a major release, support for that Ruby version may be dropped.

## Copyright

Copyright (c) 2009-2013 [Rick Olson](mailto:technoweenie@gmail.com), Zack Hobson.
See [LICENSE][] for details.

[travis]:    http://travis-ci.org/lostisland/faraday
[excon]:     https://github.com/geemus/excon#readme
[typhoeus]:  https://github.com/typhoeus/typhoeus#readme
[patron]:    http://toland.github.com/patron/
[eventmachine]: https://github.com/igrigorik/em-http-request#readme
[httpclient]: https://github.com/nahi/httpclient
[jruby]:     http://jruby.org/
[rubinius]:  http://rubini.us/
[license]:   LICENSE.md
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Elasticsearch::Transport

**This library is part of the [`elasticsearch-ruby`](https://github.com/elasticsearch/elasticsearch-ruby/) package;
please refer to it, unless you want to use this library standalone.**

----

The `elasticsearch-transport` library provides a low-level Ruby client for connecting
to an [Elasticsearch](http://elasticsearch.org) cluster.

It handles connecting to multiple nodes in the cluster, rotating across connections,
logging and tracing requests and responses, maintaining failed connections,
discovering nodes in the cluster, and provides an abstraction for
data serialization and transport.

It does not handle calling the Elasticsearch API;
see the [`elasticsearch-api`](https://github.com/elasticsearch/elasticsearch-ruby/tree/master/elasticsearch-api) library.

The library is compatible with Ruby 1.8.7 or higher and with Elasticsearch 0.90 and 1.0.

Features overview:

* Pluggable logging and tracing
* Plugabble connection selection strategies (round-robin, random, custom)
* Pluggable transport implementation, customizable and extendable
* Pluggable serializer implementation
* Request retries and dead connections handling
* Node reloading (based on cluster state) on errors or on demand

For optimal performance, you should use a HTTP library which supports persistent ("keep-alive") connections,
e.g. [Patron](https://github.com/toland/patron) or [Typhoeus](https://github.com/typhoeus/typhoeus).
Just `require 'patron'` or `require 'typhoeus'; require 'typhoeus/adapters/faraday'` in your code,
and it will be automatically used; other automatically used libraries are
[HTTPClient](https://rubygems.org/gems/httpclient) and
[Net::HTTP::Persistent](https://rubygems.org/gems/net-http-persistent).

For detailed information, see example configurations [below](#transport-implementations).

## Installation

Install the package from [Rubygems](https://rubygems.org):

    gem install elasticsearch-transport

To use an unreleased version, either add it to your `Gemfile` for [Bundler](http://gembundler.com):

    gem 'elasticsearch-transport', git: 'git://github.com/elasticsearch/elasticsearch-ruby.git'

or install it from a source code checkout:

    git clone https://github.com/elasticsearch/elasticsearch-ruby.git
    cd elasticsearch-ruby/elasticsearch-transport
    bundle install
    rake install

## Example Usage

In the simplest form, connect to Elasticsearch running on <http://localhost:9200>
without any configuration:

    require 'elasticsearch/transport'

    client = Elasticsearch::Client.new
    response = client.perform_request 'GET', '_cluster/health'
    # => #<Elasticsearch::Transport::Transport::Response:0x007fc5d506ce38 @status=200, @body={ ... } >

Full documentation is available at <http://rubydoc.info/gems/elasticsearch-transport>.

## Configuration

The client supports many configurations options for setting up and managing connections,
configuring logging, customizing the transport library, etc.

### Setting Hosts

To connect to a specific Elasticsearch host:

    Elasticsearch::Client.new host: 'search.myserver.com'

To connect to a host with specific port:

    Elasticsearch::Client.new host: 'myhost:8080'

To connect to multiple hosts:

    Elasticsearch::Client.new hosts: ['myhost1', 'myhost2']

Instead of Strings, you can pass host information as an array of Hashes:

    Elasticsearch::Client.new hosts: [ { host: 'myhost1', port: 8080 }, { host: 'myhost2', port: 8080 } ]

Common URL parts -- scheme, HTTP authentication credentials, URL prefixes, etc -- are handled automatically:

    Elasticsearch::Client.new url: 'https://username:password@api.server.org:4430/search'

You can pass multiple URLs separated by a comma:

    Elasticsearch::Client.new urls: 'http://localhost:9200,http://localhost:9201'

Another way to configure the URL(s) is to export the `ELASTICSEARCH_URL` variable.

The client will automatically round-robin across the hosts
(unless you select or implement a different [connection selector](#connection-selector)).

### Authentication

You can pass the authentication credentials, scheme and port in the host configuration hash:

    Elasticsearch::Client.new hosts: [
      { host: 'my-protected-host',
        port: '443',
        user: 'USERNAME',
        password: 'PASSWORD',
        scheme: 'https'
      } ]

... or simply use the common URL format:

    Elasticsearch::Client.new url: 'https://username:password@example.com:9200'

To pass a custom certificate for SSL peer verification to Faraday-based clients,
use the `transport_options` option:

    Elasticsearch::Client.new url: 'https://username:password@example.com:9200',
                              transport_options: { ssl: { ca_file: '/path/to/cacert.pem' } }

### Logging

To log requests and responses to standard output with the default logger (an instance of Ruby's {::Logger} class),
set the `log` argument:

    Elasticsearch::Client.new log: true

To trace requests and responses in the _Curl_ format, set the `trace` argument:

    Elasticsearch::Client.new trace: true

You can customize the default logger or tracer:

    client.transport.logger.formatter = proc { |s, d, p, m| "#{s}: #{m}\n" }
    client.transport.logger.level = Logger::INFO

Or, you can use a custom {::Logger} instance:

    Elasticsearch::Client.new logger: Logger.new(STDERR)

You can pass the client any conforming logger implementation:

    require 'logging' # https://github.com/TwP/logging/

    log = Logging.logger['elasticsearch']
    log.add_appenders Logging.appenders.stdout
    log.level = :info

    client = Elasticsearch::Client.new logger: log

### Randomizing Hosts

If you pass multiple hosts to the client, it rotates across them in a round-robin fashion, by default.
When the same client would be running in multiple processes (eg. in a Ruby web server such as Thin),
it might keep connecting to the same nodes "at once". To prevent this, you can randomize the hosts
collection on initialization and reloading:

    Elasticsearch::Client.new hosts: ['localhost:9200', 'localhost:9201'], randomize_hosts: true

### Retrying on Failures

When the client is initialized with multiple hosts, it makes sense to retry a failed request
on a different host:

    Elasticsearch::Client.new hosts: ['localhost:9200', 'localhost:9201'], retry_on_failure: true

You can specify how many times should the client retry the request before it raises an exception:

    Elasticsearch::Client.new hosts: ['localhost:9200', 'localhost:9201'], retry_on_failure: 5

### Reloading Hosts

Elasticsearch by default dynamically discovers new nodes in the cluster. You can leverage this
in the client, and periodically check for new nodes to spread the load.

To retrieve and use the information from the
[_Nodes Info API_](http://www.elasticsearch.org/guide/reference/api/admin-cluster-nodes-info/)
on every 10,000th request:

    Elasticsearch::Client.new hosts: ['localhost:9200', 'localhost:9201'], reload_connections: true

You can pass a specific number of requests after which the reloading should be performed:

    Elasticsearch::Client.new hosts: ['localhost:9200', 'localhost:9201'], reload_connections: 1_000

To reload connections on failures, use:

    Elasticsearch::Client.new hosts: ['localhost:9200', 'localhost:9201'], reload_on_failure: true

The reloading will timeout if not finished under 1 second by default. To change the setting:

    Elasticsearch::Client.new hosts: ['localhost:9200', 'localhost:9201'], sniffer_timeout: 3

### Connection Selector

By default, the client will rotate the connections in a round-robin fashion, using the
{Elasticsearch::Transport::Transport::Connections::Selector::RoundRobin} strategy.

You can implement your own strategy to customize the behaviour. For example,
let's have a "rack aware" strategy, which will prefer the nodes with a specific
[attribute](https://github.com/elasticsearch/elasticsearch/blob/1.0/config/elasticsearch.yml#L81-L85).
Only when these would be unavailable, the strategy will use the other nodes:

    class RackIdSelector
      include Elasticsearch::Transport::Transport::Connections::Selector::Base

      def select(options={})
        connections.select do |c|
          # Try selecting the nodes with a `rack_id:x1` attribute first
          c.host[:attributes] && c.host[:attributes][:rack_id] == 'x1'
        end.sample || connections.to_a.sample
      end
    end

    Elasticsearch::Client.new hosts: ['x1.search.org', 'x2.search.org'], selector_class: RackIdSelector

### Transport Implementations

By default, the client will use the [_Faraday_](https://rubygems.org/gems/faraday) HTTP library
as a transport implementation.

It will auto-detect and use an _adapter_ for _Faraday_ based on gems loaded in your code,
preferring HTTP clients with support for persistent connections.

To use the [_Patron_](https://github.com/toland/patron) HTTP, for example, just require it:

    require 'patron'

Then, create a new client, and the _Patron_  gem will be used as the "driver":

    client = Elasticsearch::Client.new

    client.transport.connections.first.connection.builder.handlers
    # => [Faraday::Adapter::Patron]

    10.times do
      client.nodes.stats(metric: 'http')['nodes'].values.each do |n|
        puts "#{n['name']} : #{n['http']['total_opened']}"
      end
    end

    # => Stiletoo : 24
    # => Stiletoo : 24
    # => Stiletoo : 24
    # => ...

To use a specific adapter for _Faraday_, pass it as the `adapter` argument:

    client = Elasticsearch::Client.new adapter: :net_http_persistent

    client.transport.connections.first.connection.builder.handlers
    # => [Faraday::Adapter::NetHttpPersistent]

To configure the _Faraday_ instance, pass a configuration block to the transport constructor:

    require 'typhoeus'
    require 'typhoeus/adapters/faraday'

    transport_configuration = lambda do |f|
      f.response :logger
      f.adapter  :typhoeus
    end

    transport = Elasticsearch::Transport::Transport::HTTP::Faraday.new \
      hosts: [ { host: 'localhost', port: '9200' } ],
      &transport_configuration

    # Pass the transport to the client
    #
    client = Elasticsearch::Client.new transport: transport

To pass options to the
[`Faraday::Connection`](https://github.com/lostisland/faraday/blob/master/lib/faraday/connection.rb)
constructor, use the `transport_options` key:

    client = Elasticsearch::Client.new transport_options: {
      request: { open_timeout: 1 },
      headers: { user_agent:   'MyApp' },
      params:  { :format => 'yaml' },
      ssl:     { verify: false }
    }

You can also use a bundled [_Curb_](https://rubygems.org/gems/curb) based transport implementation:

    require 'curb'
    require 'elasticsearch/transport/transport/http/curb'

    client = Elasticsearch::Client.new transport_class: Elasticsearch::Transport::Transport::HTTP::Curb

    client.transport.connections.first.connection
    # => #<Curl::Easy http://localhost:9200/>

It's possible to customize the _Curb_ instance by passing a block to the constructor as well
(in this case, as an inline block):

    transport = Elasticsearch::Transport::Transport::HTTP::Curb.new \
      hosts: [ { host: 'localhost', port: '9200' } ],
      & lambda { |c| c.verbose = true }

    client = Elasticsearch::Client.new transport: transport

Instead of passing the transport to the constructor, you can inject it at run time:

    # Set up the transport
    #
    faraday_configuration = lambda do |f|
      f.instance_variable_set :@ssl, { verify: false }
      f.adapter :excon
    end

    faraday_client = Elasticsearch::Transport::Transport::HTTP::Faraday.new \
      hosts: [ { host: 'my-protected-host',
                 port: '443',
                 user: 'USERNAME',
                 password: 'PASSWORD',
                 scheme: 'https'
              }],
      &faraday_configuration

    # Create a default client
    #
    client = Elasticsearch::Client.new

    # Inject the transport to the client
    #
    client.transport = faraday_client

You can write your own transport implementation easily, by including the
{Elasticsearch::Transport::Transport::Base} module, implementing the required contract,
and passing it to the client as the `transport_class` parameter -- or injecting it directly.

### Serializer Implementations

By default, the [MultiJSON](http://rubygems.org/gems/multi_json) library is used as the
serializer implementation, and it will pick up the "right" adapter based on gems available.

The serialization component is pluggable, though, so you can write your own by including the
{Elasticsearch::Transport::Transport::Serializer::Base} module, implementing the required contract,
and passing it to the client as the `serializer_class` or `serializer` parameter.

### Exception Handling

The library defines a [number of exception classes](https://github.com/elasticsearch/elasticsearch-ruby/blob/master/elasticsearch-transport/lib/elasticsearch/transport/transport/errors.rb)
for various client and server errors, as well as unsuccessful HTTP responses,
making it possible to `rescue` specific exceptions with desired granularity.

The highest-level exception is {Elasticsearch::Transport::Transport::Error}
and will be raised for any generic client *or* server errors.

{Elasticsearch::Transport::Transport::ServerError} will be raised for server errors only.

As an example for response-specific errors, a `404` response status will raise
an {Elasticsearch::Transport::Transport::Errors::NotFound} exception.

Finally, {Elasticsearch::Transport::Transport::SnifferTimeoutError} will be raised
when connection reloading ("sniffing") times out.

## Development and Community

For local development, clone the repository and run `bundle install`. See `rake -T` for a list of
available Rake tasks for running tests, generating documentation, starting a testing cluster, etc.

Bug fixes and features must be covered by unit tests. Integration tests are written in Ruby 1.9 syntax.

Github's pull requests and issues are used to communicate, send bug reports and code contributions.

## The Architecture

* {Elasticsearch::Transport::Client} is composed of {Elasticsearch::Transport::Transport}

* {Elasticsearch::Transport::Transport} is composed of {Elasticsearch::Transport::Transport::Connections},
  and an instance of logger, tracer, serializer and sniffer.

* Logger and tracer can be any object conforming to Ruby logging interface,
  ie. an instance of [`Logger`](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/logger/rdoc/Logger.html),
  [_log4r_](https://rubygems.org/gems/log4r), [_logging_](https://github.com/TwP/logging/), etc.

* The {Elasticsearch::Transport::Transport::Serializer::Base} implementations handle converting data for Elasticsearch
  (eg. to JSON). You can implement your own serializer.

* {Elasticsearch::Transport::Transport::Sniffer} allows to discover nodes in the cluster and use them as connections.

* {Elasticsearch::Transport::Transport::Connections::Collection} is composed of
  {Elasticsearch::Transport::Transport::Connections::Connection} instances and a selector instance.

* {Elasticsearch::Transport::Transport::Connections::Connection} contains the connection attributes such as hostname and port,
  as well as the concrete persistent "session" connected to a specific node.

* The {Elasticsearch::Transport::Transport::Connections::Selector::Base} implementations allow to choose connections
  from the pool, eg. in a round-robin or random fashion. You can implement your own selector strategy.

## Development

To work on the code, clone and bootstrap the main repository first --
please see instructions in the main [README](../README.md#development).

To run tests, launch a testing cluster -- again, see instructions
in the main [README](../README.md#development) -- and use the Rake tasks:

```
time rake test:unit
time rake test:integration
```

Unit tests have to use Ruby 1.8 compatible syntax, integration tests
can use Ruby 2.x syntax and features.

## License

This software is licensed under the Apache 2 license, quoted below.

    Copyright (c) 2013 Elasticsearch <http://www.elasticsearch.org>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
h1. Ruby I18n

!https://secure.travis-ci.org/svenfuchs/i18n.png?branch=master(Build Status)!:http://travis-ci.org/svenfuchs/i18n

Ruby Internationalization and localization solution.

Features:

* translation and localization
* interpolation of values to translations (Ruby 1.9 compatible syntax)
* pluralization (CLDR compatible)
* customizable transliteration to ASCII
* flexible defaults
* bulk lookup
* lambdas as translation data
* custom key/scope separator
* custom exception handlers
* extensible architecture with a swappable backend

Pluggable features:

* Cache
* Pluralization: lambda pluralizers stored as translation data
* Locale fallbacks, RFC4647 compliant (optionally: RFC4646 locale validation)
* Gettext support
* Translation metadata

Alternative backends:

* Chain
* ActiveRecord (optionally: ActiveRecord::Missing and ActiveRecord::StoreProcs)
* KeyValue (uses active_support/json and cannot store procs)

For more information and lots of resources see: "http://ruby-i18n.org/wiki":http://ruby-i18n.org/wiki

h2. Installation

gem install i18n

h4. Rails version warning

On Rails < 2.3.6 the method I18n.localize will fail with MissingInterpolationArgument (issue "20":http://github.com/svenfuchs/i18n/issues/issue/20). Upgrade to Rails 2.3.6 or higher (2.3.8 preferably) is recommended.

h3. Installation on Rails < 2.3.5 (deprecated)

Up to version 2.3.4 Rails will not accept i18n gems > 0.1.3. There is an unpacked
gem inside of active_support/lib/vendor which gets loaded unless gem 'i18n', '~> 0.1.3'.
This requirement is relaxed in "6da03653":http://github.com/rails/rails/commit/6da03653

The new i18n gem can be loaded from vendor/plugins like this:

<pre>
  def reload_i18n!
    raise "Move to i18n version 0.2.0 or greater" if Rails.version > "2.3.4"

    $:.grep(/i18n/).each { |path| $:.delete(path) }
    I18n::Backend.send :remove_const, "Simple"
    $: << Rails.root.join('vendor', 'plugins', 'i18n', 'lib').to_s
  end
</pre>

Then you can `reload_i18n!` inside an i18n initializer.

h2. Tests

You can run tests both with

* `rake test` or just `rake`
* run any test file directly, e.g. `ruby -Ilib -Itest test/api/simple_test.rb`
* run all tests with `ruby -Ilib -Itest test/all.rb`

You can run all tests against all Gemfiles with

* `ruby test/run_all.rb`

The structure of the test suite is a bit unusual as it uses modules to reuse
particular tests in different test cases.

The reason for this is that we need to enforce the I18n API across various
combinations of extensions. E.g. the Simple backend alone needs to support
the same API as any combination of feature and/or optimization modules included
to the Simple backend. We test this by reusing the same API defition (implemented
as test methods) in test cases with different setups.

You can find the test cases that enforce the API in test/api. And you can find
the API definition test methods in test/api/tests.

All other test cases (e.g. as defined in test/backend, test/core\_ext) etc.
follow the usual test setup and should be easy to grok.

h2. Authors

* "Sven Fuchs":http://www.artweb-design.de
* "Joshua Harvey":http://www.workingwithrails.com/person/759-joshua-harvey
* "Stephan Soller":http://www.arkanis-development.de
* "Saimon Moore":http://saimonmoore.net
* "Matt Aimonetti":http://railsontherun.com

h2. Contributors

http://github.com/svenfuchs/i18n/contributors

h2. License

MIT License. See the included MIT-LICENSE file.
# What is BinData?

[![Version     ](http://img.shields.io/gem/v/bindata.svg)                       ](https://rubygems.org/gems/bindata)
[![Travis CI   ](http://img.shields.io/travis/dmendel/bindata/master.svg)     ](https://travis-ci.org/dmendel/bindata)
[![Quality     ](http://img.shields.io/codeclimate/github/dmendel/bindata.svg)](https://codeclimate.com/github/dmendel/bindata)
[![Coverage    ](http://img.shields.io/coveralls/dmendel/bindata.svg)         ](https://coveralls.io/r/dmendel/bindata)

Do you ever find yourself writing code like this?

```ruby
io = File.open(...)
len = io.read(2).unpack("v")
name = io.read(len)
width, height = io.read(8).unpack("VV")
puts "Rectangle #{name} is #{width} x #{height}"
```

It’s ugly, violates DRY and feels like you’re writing Perl, not Ruby.

There is a better way. Here’s how you’d write the above using BinData.

```ruby
class Rectangle < BinData::Record
  endian :little
  uint16 :len
  string :name, :read_length => :len
  uint32 :width
  uint32 :height
end

io = File.open(...)
r  = Rectangle.read(io)
puts "Rectangle #{r.name} is #{r.width} x #{r.height}"
```

BinData provides a _declarative_ way to read and write structured binary data.

This means the programmer specifies *what* the format of the binary
data is, and BinData works out *how* to read and write data in this
format.  It is an easier (and more readable) alternative to
ruby's `#pack` and `#unpack` methods.

BinData makes it easy to create new data types. It supports all the common
primitive datatypes that are found in structured binary data formats. Support
for dependent and variable length fields is built in. 

# Installation

    $ gem install bindata

or if running ruby 1.8

    $ gem install bindata -v '~> 1.8.0'

# Documentation

[Read the wiki](http://github.com/dmendel/bindata/wiki).

# Contact

If you have any queries / bug reports / suggestions, please contact me
(Dion Mendel) via email at dion@lostrealm.com
= Nokogiri {<img src="https://secure.travis-ci.org/sparklemotion/nokogiri.png?rvm=1.9.3" />}[http://travis-ci.org/sparklemotion/nokogiri] {<img src="https://codeclimate.com/github/sparklemotion/nokogiri.png" />}[https://codeclimate.com/github/sparklemotion/nokogiri] {<img src="https://www.versioneye.com/ruby/nokogiri/badge.png" alt="Dependency Status" />}[https://www.versioneye.com/ruby/nokogiri]

* http://nokogiri.org
* https://github.com/sparklemotion/nokogiri
* https://groups.google.com/group/nokogiri-talk
* https://github.com/sparklemotion/nokogiri/issues

== DESCRIPTION:

Nokogiri (鋸) is an HTML, XML, SAX, and Reader parser.  Among Nokogiri's
many features is the ability to search documents via XPath or CSS3 selectors.

XML is like violence - if it doesn’t solve your problems, you are not using
enough of it.

== FEATURES:

* XPath 1.0 support for document searching
* CSS3 selector support for document searching
* XML/HTML builder

Nokogiri parses and searches XML/HTML very quickly, and also has
correctly implemented CSS3 selector support as well as XPath 1.0 support.

== SUPPORT:

Before filing a bug report, please read our {submission guidelines}[http://nokogiri.org/tutorials/getting_help.html] at:

  * http://nokogiri.org/tutorials/getting_help.html

The Nokogiri {mailing list}[https://groups.google.com/group/nokogiri-talk]
is available here:

  * https://groups.google.com/group/nokogiri-talk

The {bug tracker}[https://github.com/sparklemotion/nokogiri/issues]
is available here:

  * https://github.com/sparklemotion/nokogiri/issues

The IRC channel is #nokogiri on freenode.

== SYNOPSIS:

  require 'nokogiri'
  require 'open-uri'

  # Fetch and parse HTML document
  doc = Nokogiri::HTML(open('http://www.nokogiri.org/tutorials/installing_nokogiri.html'))

  ####
  # Search for nodes by css
  doc.css('nav ul.menu li a').each do |link|
    puts link.content
  end

  ####
  # Search for nodes by xpath
  doc.xpath('//h2 | //h3').each do |link|
    puts link.content
  end

  ####
  # Or mix and match.
  doc.search('code.sh', '//h2').each do |link|
    puts link.content
  end


== REQUIREMENTS:

* ruby 1.9.3 or higher

* in Nokogiri 1.6.0 and later libxml2 and libxslt are bundled with the
  gem, but if you want to use them installed on the system:

  * libxml2 >=2.6.21 with iconv support
    (libxml2-dev/-devel is required too)

  * libxslt, built with and supported by the given libxml2
    (libxslt-dev/-devel is required too)

== ENCODING:

Strings are always stored as UTF-8 internally.  Methods that return
text values will always return UTF-8 encoded strings.  Methods that
return XML (like to_xml, to_html and inner_html) will return a string
encoded like the source document.

*WARNING*

Some documents declare one particular encoding, but use a different
one. So, which encoding should the parser choose?

Remember that data is just a stream of bytes. Only we humans add
meaning to that stream. Any particular set of bytes could be valid
characters in multiple encodings, so detecting encoding with 100%
accuracy is not possible. libxml2 does its best, but it can't be right
100% of the time.

If you want Nokogiri to handle the document encoding properly, your
best bet is to explicitly set the encoding.  Here is an example of
explicitly setting the encoding to EUC-JP on the parser:

    doc = Nokogiri.XML('<foo><bar /><foo>', nil, 'EUC-JP')

== INSTALL:

* sudo gem install nokogiri

=== Binary packages

Binary packages are available for:

* SuSE[https://download.opensuse.org/repositories/devel:/languages:/ruby:/extensions/]
* Fedora[http://s390.koji.fedoraproject.org/koji/packageinfo?packageID=6756]

== DEVELOPMENT:

=== Developing on C Ruby (MRI)

Developing Nokogiri requires racc and rexical to generate the parser and
tokenizer.  To start development, make sure you have `libxml2` and `libxslt`
installed.

Then install core gems and bootstrap:

    $ gem install hoe rake-compiler mini_portile
    $ rake newb

=== Developing on JRuby

Currently, development with JRuby depends on CRuby being installed.  With
CRuby, install racc and rexical:

    $ gem install racc rexical

Make sure hoe and rake compiler are installed with JRuby:

    $ jgem install hoe rake-compiler

Then run rake:

    $ jruby -S rake

== LICENSE:

(The MIT License)

Copyright (c) 2008 - 2015:

* {Aaron Patterson}[http://tenderlovemaking.com]
* {Mike Dalessio}[http://mike.daless.io]
* {Charles Nutter}[http://blog.headius.com]
* {Sergio Arbeo}[http://www.serabe.com]
* {Patrick Mahoney}[http://polycrystal.org]
* {Yoko Harada}[http://yokolet.blogspot.com]
* {Akinori MUSHA}[https://akinori.org]

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
= Nokogiri (鋸) {<img src="https://secure.travis-ci.org/sparklemotion/nokogiri.png?rvm=1.9.3" />}[http://travis-ci.org/sparklemotion/nokogiri] {<img src="https://codeclimate.com/badge.png" />}[https://codeclimate.com/github/sparklemotion/nokogiri]

* http://nokogiri.org
* https://github.com/sparklemotion/nokogiri
* https://groups.google.com/group/nokogiri-talk
* https://github.com/sparklemotion/nokogiri/issues

== DESCRIPTION:

Nokogiri はHTMLとXMLとSAXとXSLTとReaderのパーサーです。とりわけ重要な特徴は、
ドキュメントをXPathやCSS3セレクター経由で探索する機能を持つことです。

XMLは暴力に似ている - XMLが君の問題を解決しないとしたら、君はXMLを十分に
使いこなしていない事になる。

== FEATURES:

* XPath 1.0による探索
* CSS3 のセレクターによる探索
* XML/HTMLのビルダー

XML/HTMLの高速な解析と探索検索、ならびにCSS3セレクタとXPath 1.0をサポートしています。

== SUPPORT:

日本語でNokogiriの
{メーリングリスト}[https://groups.google.com/group/nokogiri-list]

  * https://groups.google.com/group/nokogiri-list

{バグ報告}[https://github.com/sparklemotion/nokogiri/issues]

  * https://github.com/sparklemotion/nokogiri/issues

IRCのチャンネルはfreenodeの #nokogiri です。

== SYNOPSIS:

  require 'nokogiri'
  require 'open-uri'

  # Fetch and parse HTML document
  doc = Nokogiri::HTML(open('http://www.nokogiri.org/tutorials/installing_nokogiri.html'))

  ####
  # Search for nodes by css
  doc.css('nav ul.menu li a').each do |link|
    puts link.content
  end

  ####
  # Search for nodes by xpath
  doc.xpath('//h2 | //h3').each do |link|
    puts link.content
  end

  ####
  # Or mix and match.
  doc.search('code.sh', '//h2').each do |link|
    puts link.content
  end


== REQUIREMENTS:

* ruby 1.9.3以上

* Nokogiri 1.6.0以降ではlibxml2とlibxsltは同梱されているが、
  もしインストール済みのものを使いたい場合:

  * libxml2 2.6.21以上, iconvサポート付きのもの
    (libxml2-dev/-develパッケージも必要)

  * libxslt 上記のlibxml2でビルドされ、サポートされているもの
    (libxslt-dev/-develパッケージも必要)

== INSTALL:

* sudo gem install nokogiri

== LICENSE:

(The MIT License)

Copyright (c) 2008 - 2015:

* {Aaron Patterson}[http://tenderlovemaking.com]
* {Mike Dalessio}[http://mike.daless.io]
* {Charles Nutter}[http://blog.headius.com]
* {Sergio Arbeo}[http://www.serabe.com]
* {Patrick Mahoney}[http://polycrystal.org]
* {Yoko Harada}[http://yokolet.blogspot.com]
* {Akinori MUSHA}[https://akinori.org]

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
This directory contains valgrind suppression files generated by the hoe-debugging gem.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# simple_oauth

[![Gem Version](http://img.shields.io/gem/v/simple_oauth.svg)][gem]
[![Build Status](http://img.shields.io/travis/laserlemon/simple_oauth.svg)][travis]
[![Dependency Status](http://img.shields.io/gemnasium/laserlemon/simple_oauth.svg)][gemnasium]
[![Code Climate](http://img.shields.io/codeclimate/github/laserlemon/simple_oauth.svg)][codeclimate]
[![Coverage Status](http://img.shields.io/coveralls/laserlemon/simple_oauth.svg)][coveralls]

[gem]: https://rubygems.org/gems/simple_oauth
[travis]: http://travis-ci.org/laserlemon/simple_oauth
[gemnasium]: https://gemnasium.com/laserlemon/simple_oauth
[codeclimate]: https://codeclimate.com/github/laserlemon/simple_oauth
[coveralls]: https://coveralls.io/r/laserlemon/simple_oauth

Simply builds and verifies OAuth headers

## Supported Rubies
This library aims to support and is [tested
against](http://travis-ci.org/laserlemon/simple_oauth) the following Ruby
implementations:

* Ruby 1.8.7
* Ruby 1.9.3
* Ruby 2.0.0
* Ruby 2.1
* [JRuby](http://jruby.org/)
* [Rubinius](http://rubini.us/)

If something doesn't work on one of these interpreters, it's a bug.

This library may inadvertently work (or seem to work) on other Ruby
implementations, however support will only be provided for the versions listed
above.

If you would like this library to support another Ruby version, you may
volunteer to be a maintainer. Being a maintainer entails making sure all tests
run and pass on that implementation. When something breaks on your
implementation, you will be responsible for providing patches in a timely
fashion. If critical issues for a particular implementation exist at the time
of a major release, support for that Ruby version may be dropped.

## Copyright
Copyright (c) 2010-2013 Steve Richert, Erik Michaels-Ober. See
[LICENSE](LICENSE.md) for details.
# BufferedTokenizer

[![Gem Version](https://badge.fury.io/rb/buftok.png)][gem]
[![Build Status](https://travis-ci.org/sferik/buftok.png?branch=master)][travis]
[![Dependency Status](https://gemnasium.com/sferik/buftok.png?travis)][gemnasium]
[![Code Climate](https://codeclimate.com/github/sferik/buftok.png)][codeclimate]

[gem]: https://rubygems.org/gems/buftok
[travis]: https://travis-ci.org/sferik/buftok
[gemnasium]: https://gemnasium.com/sferik/buftok
[codeclimate]: https://codeclimate.com/github/sferik/buftok

###### Statefully split input data by a specifiable token

BufferedTokenizer takes a delimiter upon instantiation, or acts line-based by
default.  It allows input to be spoon-fed from some outside source which
receives arbitrary length datagrams which may-or-may-not contain the token by
which entities are delimited.  In this respect it's ideally paired with
something like [EventMachine][].

[EventMachine]: http://rubyeventmachine.com/

## Supported Ruby Versions
This library aims to support and is [tested against][travis] the following Ruby
implementations:

* Ruby 1.8.7
* Ruby 1.9.2
* Ruby 1.9.3
* Ruby 2.0.0

If something doesn't work on one of these interpreters, it's a bug.

This library may inadvertently work (or seem to work) on other Ruby
implementations, however support will only be provided for the versions listed
above.

If you would like this library to support another Ruby version, you may
volunteer to be a maintainer. Being a maintainer entails making sure all tests
run and pass on that implementation. When something breaks on your
implementation, you will be responsible for providing patches in a timely
fashion. If critical issues for a particular implementation exist at the time
of a major release, support for that Ruby version may be dropped.

## Copyright
Copyright (c) 2006-2013 Tony Arcieri, Martin Emde, Erik Michaels-Ober.
Distributed under the [Ruby license][license].
[license]: http://www.ruby-lang.org/en/LICENSE.txt
maven tools 
===========

* [![Build Status](https://secure.travis-ci.org/torquebox/maven-tools.png)](http://travis-ci.org/torquebox/maven-tools)
* [![Code Climate](https://codeclimate.com/badge.png)](https://codeclimate.com/github/torquebox/maven-tools)

Note on Ruby-1.8
----------------

ordering is important within the pom.xml since it carry info on the sequence of execution. jruby and ruby-1.9 do iterate in same order as the keys gets included, that helps to copy the order of declaration from the ruby DSL over to pom.xml. with ruby-1.8 the hash behaviour is different and since ruby-1.8 is end of life there is no support for ruby-1.8. though it might just works fine on simple setup.

Contributing
------------

1. Fork it
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Added some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create new Pull Request

meta-fu
-------

enjoy :) 

# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.## hitimes

* [Homepage](http://github.com/copiousfreetime/hitimes)
* [Github project](http://github.com.org/copiousfreetime/hitimes)
* email jeremy at copiousfreetime dot org
* `git clone url git://github.com/copiousfreetime/hitimes.git`

## INSTALL

* `gem install hitimes`

## DESCRIPTION

Hitimes is a fast, high resolution timer library for recording
performance metrics.  It uses the appropriate low method calls for each
system to get the highest granularity time increments possible.  

It currently supports any of the following systems:

* any system with the POSIX call `clock_gettime()`
* Mac OS X
* Windows
* JRuby

Using Hitimes can be faster than using a series of `Time.new` calls, and
it will have a much higher granularity. It is definitely faster than
using `Process.times`. 

## SYNOPSIS

### Interval

Use Hitimes::Interval to calculate only the duration of a block of code

``` ruby
duration = Hitimes::Interval.measure do
             # some operation ...
           end

puts duration
```

### TimedMetric

Use a Hitimes::TimedMetric to calculate statistics about an iterative operation

``` ruby
timed_metric = Hitimes::TimedMetric.new('operation on items')
```

Explicitly use `start` and `stop`:

``` ruby
collection.each do |item|
  timed_metric.start
  # .. do something with item
  timed_metric.stop
end
```

Or use the block.  In TimedMetric the return value of +measure+ is the return
value of the block

``` ruby
collection.each do |item|
  result_of_do_something = timed_metric.measure { do_something( item ) }
end
```
And then look at the stats

``` ruby
puts timed_metric.mean
puts timed_metric.max
puts timed_metric.min
puts timed_metric.stddev
puts timed_metric.rate
```
### ValueMetric 

Use a Hitimes::ValueMetric to calculate statistics about measured samples

``` ruby
value_metric = Hitimes::ValueMetric.new( 'size of thing' )
loop do
  # ... do stuff changing sizes of 'thing'
  value_metric.measure( thing.size )
  # ... do other stuff that may change size of thing
end

puts value_metric.mean
puts value_metric.max
puts value_metric.min
puts value_metric.stddev
puts value_metric.rate
```

### TimedValueMetric

Use a Hitimes::TimedValueMetric to calculate statistics about batches of samples

``` ruby
timed_value_metric = Hitimes::TimedValueMetric.new( 'batch times' )
loop do 
  batch = ... # get a batch of things
  timed_value_metric.start
  # .. do something with batch
  timed_value_metric.stop( batch.size )
end

puts timed_value_metric.rate

puts timed_value_metric.timed_stats.mean
puts timed_value_metric.timed_stats.max
puts timed_value_metric.timed_stats.min
puts timed_value_metric.timed_stats.stddev

puts timed_value_metric.value_stats.mean
puts timed_value_metric.value_stats.max
puts timed_value_metric.value_stats.min
puts timed_value_metric.value_stats.stddev
```

## CHANGES

Read the HISTORY.md file.

## BUILDING FOR WINDOWS

[rake-compiler](https://github.com/luislavena/rake-compiler) is use for building
the windows version. For me, on OSX to cross compile the process is:

```
% gem install rake-compiler # in each rvm instance, 1.8.7, 1.9.3
% rvm use 2.0.0@hitimes
% rake-compiler cross-ruby VERSION=2.0.0-p0 # or latest
% rvm use 1.9.3@hitimes
% rake-compiler cross-ruby VERSION=1.9.3-p374 # or latest
% rvm use 1.8.7@hitimes
% rake-compiler cross-ruby VERSION=1.8.7-p371

# This only works via 1.8.7 at the current moment
% rake cross native gem RUBY_CC_VERSION=1.8.7:1.9.3:2.0.0
```

## CREDITS

* [Bruce Williams](https://github.com/bruce) for suggesting the idea

## ISC License

Copyright (c) 2008-2012 Jeremy Hinegardner

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Threadsafe

[![Gem Version](https://badge.fury.io/rb/thread_safe.svg)](http://badge.fury.io/rb/thread_safe) [![Build Status](https://travis-ci.org/ruby-concurrency/thread_safe.svg?branch=master)](https://travis-ci.org/ruby-concurrency/thread_safe) [![Coverage Status](https://img.shields.io/coveralls/ruby-concurrency/thread_safe/master.svg)](https://coveralls.io/r/ruby-concurrency/thread_safe) [![Code Climate](https://codeclimate.com/github/ruby-concurrency/thread_safe.svg)](https://codeclimate.com/github/ruby-concurrency/thread_safe) [![Dependency Status](https://gemnasium.com/ruby-concurrency/thread_safe.svg)](https://gemnasium.com/ruby-concurrency/thread_safe) [![License](https://img.shields.io/badge/license-apache-green.svg)](http://opensource.org/licenses/MIT) [![Gitter chat](http://img.shields.io/badge/gitter-join%20chat%20%E2%86%92-brightgreen.svg)](https://gitter.im/ruby-concurrency/concurrent-ruby)

A collection of thread-safe versions of common core Ruby classes.

## Installation

Add this line to your application's Gemfile:

    gem 'thread_safe'

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install thread_safe

## Usage

```ruby
require 'thread_safe'

sa = ThreadSafe::Array.new # supports standard Array.new forms
sh = ThreadSafe::Hash.new # supports standard Hash.new forms
```

`ThreadSafe::Cache` also exists, as a hash-like object, and should have
much better performance characteristics esp. under high concurrency than
`ThreadSafe::Hash`. However, `ThreadSafe::Cache` is not strictly semantically
equivalent to a ruby `Hash` -- for instance, it does not necessarily retain
ordering by insertion time as `Hash` does. For most uses it should do fine
though, and we recommend you consider `ThreadSafe::Cache` instead of
`ThreadSafe::Hash` for your concurrency-safe hash needs. It understands some
options when created (depending on your ruby platform) that control some of the
internals - when unsure just leave them out:


```ruby
require 'thread_safe'

cache = ThreadSafe::Cache.new
```

## Contributing

1. Fork it
2. Clone it (`git clone git@github.com:you/thread_safe.git`)
3. Create your feature branch (`git checkout -b my-new-feature`)
4. Build the jar (`rake jar`) NOTE: Requires JRuby
5. Install dependencies (`bundle install`)
6. Commit your changes (`git commit -am 'Added some feature'`)
7. Push to the branch (`git push origin my-new-feature`)
8. Create new Pull Request
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Stud.

Ruby's stdlib is missing many things I use to solve most of my software
problems. Things like like retrying on a failure, supervising workers, resource
pools, etc.

In general, I started exploring solutions to these things in code over in my
[software-patterns](https://github.com/jordansissel/software-patterns) repo.
This library (stud) aims to be a well-tested, production-quality implementation
of the patterns described in that repo.

For now, these all exist in a single repo because, so far, implementations of
each 'pattern' are quite small by code size.

## Features

* {Stud::Try} (and {Stud.try}) - retry on failure, with back-off, where failure is any exception.
* {Stud::Pool} - generic resource pools
* {Stud::Task} - tasks (threads that can return values, exceptions, etc)
* {Stud.interval} - interval execution (do X every N seconds)
* {Stud::Buffer} - batch & flush behavior.

## TODO:

* Make sure all things are documented. rubydoc.info should be able to clearly
  show folks how to use features of this library.
* Add tests to cover all supported features.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.[![Version     ](https://img.shields.io/gem/v/bundler.svg?style=flat)](https://rubygems.org/gems/bundler)
[![Build Status](https://img.shields.io/travis/bundler/bundler/master.svg?style=flat)](https://travis-ci.org/bundler/bundler)
[![Code Climate](https://img.shields.io/codeclimate/github/bundler/bundler.svg?style=flat)](https://codeclimate.com/github/bundler/bundler)
[![Inline docs ](http://inch-ci.org/github/bundler/bundler.svg?style=flat)](http://inch-ci.org/github/bundler/bundler)

# Bundler: a gem to bundle gems

Bundler makes sure Ruby applications run the same code on every machine.

It does this by managing the gems that the application depends on. Given a list of gems, it can automatically download and install those gems, as well as any other gems needed by the gems that are listed. Before installing gems, it checks the versions of every gem to make sure that they are compatible, and can all be loaded at the same time. After the gems have been installed, Bundler can help you update some or all of them when new versions become available. Finally, it records the exact versions that have been installed, so that others can install the exact same gems.

### Installation and usage

```
gem install bundler
bundle init
echo "gem 'rails'" >> Gemfile
bundle install
bundle exec rails new myapp
```

See [bundler.io](http://bundler.io) for the full documentation.

### Troubleshooting

For help with common problems, see [ISSUES](https://github.com/bundler/bundler/blob/master/ISSUES.md).

### Other questions

To see what has changed in recent versions of Bundler, see the [CHANGELOG](https://github.com/bundler/bundler/blob/master/CHANGELOG.md).

Feel free to chat with the Bundler core team (and many other users) on IRC in the  [#bundler](irc://irc.freenode.net/bundler) channel on Freenode, or via email on the [Bundler mailing list](http://groups.google.com/group/ruby-bundler).

### Contributing

If you'd like to contribute to Bundler, that's awesome, and we <3 you. There's a guide to contributing to Bundler (both code and general help) over in [DEVELOPMENT](https://github.com/bundler/bundler/blob/master/DEVELOPMENT.md)
# <%=config[:constant_name]%>

Welcome to your new gem! In this directory, you'll find the files you need to be able to package up your Ruby library into a gem. Put your Ruby code in the file `lib/<%=config[:namespaced_path]%>`. To experiment with that code, run `bin/console` for an interactive prompt.

TODO: Delete this and the text above, and describe your gem

## Installation

Add this line to your application's Gemfile:

```ruby
gem '<%=config[:name]%>'
```

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install <%=config[:name]%>

## Usage

TODO: Write usage instructions here

## Development

After checking out the repo, run `bin/setup` to install dependencies. Then, run `bin/console` for an interactive prompt that will allow you to experiment.<% if config[:bin] %> Run `bundle exec <%= config[:name] %>` to use the code located in this directory, ignoring other installed copies of this gem.<% end %>

To install this gem onto your local machine, run `bundle exec rake install`. To release a new version, update the version number in `version.rb`, and then run `bundle exec rake release` to create a git tag for the version, push git commits and tags, and push the `.gem` file to [rubygems.org](https://rubygems.org).

## Contributing

1. Fork it ( https://github.com/[my-github-username]/<%=config[:name]%>/fork )
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Add some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create a new Pull Request
= statsd-ruby {<img src="https://secure.travis-ci.org/reinh/statsd.png" />}[http://travis-ci.org/reinh/statsd]

A Ruby client for {StatsD}[https://github.com/etsy/statsd]

= Installing

Bundler:
  gem "statsd-ruby", :require => "statsd"

= Basic Usage

  # Set up a global Statsd client for a server on localhost:9125
  $statsd = Statsd.new 'localhost', 9125

  # Send some stats
  $statsd.increment 'garets'
  $statsd.timing 'glork', 320
  $statsd.gauge 'bork', 100

  # Use {#time} to time the execution of a block
  $statsd.time('account.activate') { @account.activate! }

  # Create a namespaced statsd client and increment 'account.activate'
  statsd = Statsd.new('localhost').tap{|sd| sd.namespace = 'account'}
  statsd.increment 'activate'

= Testing

Run the specs with <tt>rake spec</tt>

Run the specs and include live integration specs with <tt>LIVE=true rake spec</tt>. Note: This will test over a real UDP socket.

= Performance

* A short note about DNS: If you use a dns name for the host option, then you will want to use a local caching dns service for optimial performance (e.g. nscd).

== Contributing to statsd

* Check out the latest master to make sure the feature hasn't been implemented or the bug hasn't been fixed yet
* Check out the issue tracker to make sure someone already hasn't requested it and/or contributed it
* Fork the project
* Start a feature/bugfix branch
* Commit and push until you are happy with your contribution
* Make sure to add tests for it. This is important so I don't break it in a future version unintentionally.
* Please try not to mess with the Rakefile, version, or history. If you want to have your own version, or is otherwise necessary, that is fine, but please isolate to its own commit so I can cherry-pick around it.

== Contributors

* Rein Henrichs
* Ray Krueger
* Jeremy Kemper
* Ryan Tomayko
* Gabriel Burt
* Rick Olson
* Trae Robrock
* Corey Donohoe
* James Tucker
* Dotan Nahum
* Eric Chapweske
* Hannes Georg
* John Nunemaker
* Mahesh Murthy
* Manu J
* Matt Sanford
* Nate Bird
* Noah Lorang
* Oscar Del Ben
* Peter Mounce
* Ray Krueger
* Reed Lipman
* Thomas Whaples

== Copyright

Copyright (c) 2011, 2012, 2013 Rein Henrichs. See LICENSE.txt for further details.
= CodeRay

Tired of blue'n'gray? Try the original version of this documentation on
coderay.rubychan.de[http://coderay.rubychan.de/doc/] :-)

== About

CodeRay is a Ruby library for syntax highlighting.

You put your code in, and you get it back colored; Keywords, strings,
floats, comments - all in different colors. And with line numbers.

*Syntax* *Highlighting*...
* makes code easier to read and maintain
* lets you detect syntax errors faster
* helps you to understand the syntax of a language
* looks nice
* is what everybody wants to have on their website
* solves all your problems and makes the girls run after you


== Installation

 % gem install coderay


=== Dependencies

CodeRay needs Ruby 1.8.7+ or 1.9.2+. It also runs on Rubinius and JRuby.


== Example Usage

 require 'coderay'
 
 html = CodeRay.scan("puts 'Hello, world!'", :ruby).div(:line_numbers => :table)


== Documentation

See CodeRay.


== Credits

=== Special Thanks to

* licenser (Heinz N. Gies) for ending my QBasic career, inventing the Coder
  project and the input/output plugin system.
  CodeRay would not exist without him.
* bovi (Daniel Bovensiepen) for helping me out on various occasions.

=== Thanks to

* Caleb Clausen for writing RubyLexer (see
  http://rubyforge.org/projects/rubylexer) and lots of very interesting mail
  traffic
* birkenfeld (Georg Brandl) and mitsuhiku (Arnim Ronacher) for PyKleur, now pygments.
  You guys rock!
* Jamis Buck for writing Syntax (see http://rubyforge.org/projects/syntax)
  I got some useful ideas from it.
* Doug Kearns and everyone else who worked on ruby.vim - it not only helped me
  coding CodeRay, but also gave me a wonderful target to reach for the Ruby
  scanner.
* everyone who uses CodeBB on http://www.rubyforen.de and http://www.python-forum.de
* iGEL, magichisoka, manveru, WoNáDo and everyone I forgot from rubyforen.de
* Dethix from ruby-mine.de
* zickzackw
* Dookie (who is no longer with us...) and Leonidas from http://www.python-forum.de
* Andreas Schwarz for finding out that CaseIgnoringWordList was not case
  ignoring! Such things really make you write tests.
* closure for the first version of the Scheme scanner.
* Stefan Walk for the first version of the JavaScript and PHP scanners.
* Josh Goebel for another version of the JavaScript scanner, a SQL and a Diff scanner.
* Jonathan Younger for pointing out the licence confusion caused by wrong LICENSE file.
* Jeremy Hinegardner for finding the shebang-on-empty-file bug in FileType.
* Charles Oliver Nutter and Yehuda Katz for helping me benchmark CodeRay on JRuby.
* Andreas Neuhaus for pointing out a markup bug in coderay/for_redcloth.
* 0xf30fc7 for the FileType patch concerning Delphi file extensions.
* The folks at redmine.org - thank you for using and fixing CodeRay!
* Keith Pitt for his SQL scanners
* Rob Aldred for the terminal encoder
* Trans for pointing out $DEBUG dependencies
* Flameeyes for finding that Term::ANSIColor was obsolete
* matz and all Ruby gods and gurus
* The inventors of: the computer, the internet, the true color display, HTML &
  CSS, VIM, Ruby, pizza, microwaves, guitars, scouting, programming, anime, 
  manga, coke and green ice tea.

Where would we be without all those people?

=== Created using

* Ruby[http://ruby-lang.org/]
* Chihiro (my Sony VAIO laptop); Henrietta (my old MacBook);
  Triella, born Rico (my new MacBook); as well as
  Seras and Hikari (my PCs)
* RDE[http://homepage2.nifty.com/sakazuki/rde_e.html],
  VIM[http://vim.org] and TextMate[http://macromates.com]
* Subversion[http://subversion.tigris.org/]
* Redmine[http://redmine.org/]
* Firefox[http://www.mozilla.org/products/firefox/],
  Firebug[http://getfirebug.com/], Safari[http://www.apple.com/safari/], and
  Thunderbird[http://www.mozilla.org/products/thunderbird/]
* RubyGems[http://docs.rubygems.org/] and Rake[http://rake.rubyforge.org/]
* TortoiseSVN[http://tortoisesvn.tigris.org/] using Apache via
  XAMPP[http://www.apachefriends.org/en/xampp.html]
* RDoc (though I'm quite unsatisfied with it)
* Microsoft Windows (yes, I confess!) and MacOS X
* GNUWin32, MinGW and some other tools to make the shell under windows a bit
  less useless
* Term::ANSIColor[http://term-ansicolor.rubyforge.org/]
* PLEAC[http://pleac.sourceforge.net/] code examples
* Github
* Travis CI (http://travis-ci.org/rubychan/github)

=== Free

* As you can see, CodeRay was created under heavy use of *free* software.
* So CodeRay is also *free*.
* If you use CodeRay to create software, think about making this software
  *free*, too.
* Thanks :)
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Memoizable

[![Gem Version](http://img.shields.io/gem/v/memoizable.svg)][gem]
[![Build Status](http://img.shields.io/travis/dkubb/memoizable.svg)][travis]
[![Dependency Status](http://img.shields.io/gemnasium/dkubb/memoizable.svg)][gemnasium]
[![Code Climate](http://img.shields.io/codeclimate/github/dkubb/memoizable.svg)][codeclimate]
[![Coverage Status](http://img.shields.io/coveralls/dkubb/memoizable.svg)][coveralls]

[gem]: https://rubygems.org/gems/memoizable
[travis]: https://travis-ci.org/dkubb/memoizable
[gemnasium]: https://gemnasium.com/dkubb/memoizable
[codeclimate]: https://codeclimate.com/github/dkubb/memoizable
[coveralls]: https://coveralls.io/r/dkubb/memoizable

Memoize method return values

## Contributing

See [CONTRIBUTING.md](CONTRIBUTING.md) for details.

## Rationale

Memoization is an optimization that saves the return value of a method so it
doesn't need to be re-computed every time that method is called. For example,
perhaps you've written a method like this:

```ruby
class Planet
  # This is the equation for the area of a sphere. If it's true for a
  # particular instance of a planet, then that planet is spherical.
  def spherical?
    4 * Math::PI * radius ** 2 == area
  end
end
```

This code will re-compute whether a particular planet is spherical every time
the method is called. If the method is called more than once, it may be more
efficient to save the computed value in an instance variable, like so:

```ruby
class Planet
  def spherical?
    @spherical ||= 4 * Math::PI * radius ** 2 == area
  end
end
```

One problem with this approach is that, if the return value is `false`, the
value will still be computed each time the method is called. It also becomes
unweildy for methods that grow to be longer than one line.

These problems can be solved by mixing-in the `Memoizable` module and memoizing
the method.

```ruby
require 'memoizable'

class Planet
  include Memoizable
  def spherical?
    4 * Math::PI * radius ** 2 == area
  end
  memoize :spherical?
end
```

## Warning

The example above assumes that the radius and area of a planet will not change
over time. This seems like a reasonable assumption but such an assumption is
not safe in every domain. If it was possible for one of the attributes to
change between method calls, memoizing that value could produce the wrong
result. Please keep this in mind when considering which methods to memoize.

Supported Ruby Versions
-----------------------

This library aims to support and is [tested against][travis] the following Ruby
implementations:

* Ruby 1.8.7
* Ruby 1.9.2
* Ruby 1.9.3
* Ruby 2.0.0
* Ruby 2.1.0
* [JRuby][]
* [Rubinius][]
* [Ruby Enterprise Edition][ree]

[jruby]: http://jruby.org/
[rubinius]: http://rubini.us/
[ree]: http://www.rubyenterpriseedition.com/

If something doesn't work on one of these versions, it's a bug.

This library may inadvertently work (or seem to work) on other Ruby versions or
implementations, however support will only be provided for the implementations
listed above.

If you would like this library to support another Ruby version or
implementation, you may volunteer to be a maintainer. Being a maintainer
entails making sure all tests run and pass on that implementation. When
something breaks on your implementation, you will be responsible for providing
patches in a timely fashion. If critical issues for a particular implementation
exist at the time of a major release, support for that Ruby version may be
dropped.

## Copyright

Copyright &copy; 2013 Dan Kubb, Erik Michaels-Ober. See LICENSE for details.
## filesize
filesize.rb provides a class for easily working with file sizes.
That means:

* Parsing strings (e.g. "1 GiB") and saving it internally as bytes
* Handling both SI and binary prefixes
* Converting from any type and unit to any other (SI to SI, SI to Binary and so on)
* doing calculations with filesizes (in a smart way, see Usage for more)
* filesize.rb also provides some default sizes, like the ones of DVDs

## Usage
### Parsing a string
```ruby
Filesize.from("1 GiB")
# => #<Filesize:0x93c06c8 @bytes=1073741824, @type={:regexp=>/^([\d,.]+)?\s?(?:([kmgtpezy])i)?b$/i, :multiplier=>1024, :presuffix=>"i"}>
```

### Converting filesizes
```ruby
Filesize.from("1 GiB").to_f('KiB') # => 1048576.0
Filesize.from("1 GiB").to_f('KB')  # => 1073741.824
Filesize.from("1 GB").to_i         # => 1000000000
```

### Outputting filesizes
```ruby
Filesize.from("12502343 B").to_s('GiB') # => "0.01 GiB"
Filesize.from("12502343 B").pretty      # => "11.92 MiB"
```

### Calculating with filesizes
#### The file size on the left side sets the type
```ruby
(Filesize.from("1400 MB")  + Filesize.from("1400 MiB")).pretty # => "2.87 GB"
(Filesize.from("1400 MiB") + Filesize.from("1400 MB")).pretty  # => "2.67 GiB"
```

#### Filesizes can also be coerced
```ruby
(Filesize.from("1400 MiB") + 1024).pretty # => "1.37 GiB"
(1024 + Filesize.from("1400 MB")).pretty  # => "1.40 GB"
```

#### filesize.rb is smart about the return value
```ruby
Filesize.from("1400 MiB") / Filesize.from("700 MiB") # => 2.0
```

#### One can also use predefined sizes
```ruby
Filesize::DVD / Filesize::CD # => 6.13566756571429
```
# Elasticsearch::API

**This library is part of the [`elasticsearch-ruby`](https://github.com/elasticsearch/elasticsearch-ruby/) package;
please refer to it, unless you want to use this library standalone.**

----

The `elasticsearch-api` library provides a Ruby implementation of
the [Elasticsearch](http://elasticsearch.org) REST API.

It does not provide an Elasticsearch client; see the
[`elasticsearch-transport`](https://github.com/elasticsearch/elasticsearch-ruby/tree/master/elasticsearch-transport)
library.

The library is compatible with Ruby 1.8.7 or higher.

The library is compatible with Elasticsearch 0.90 and 1.0 -- you have to install and use a matching version, though.

The 1.x versions and the master branch are compatible with **Elasticsearch 1.x** API.

To use the **Elasticsearch 0.90** API, install the **0.4.x** gem version or use the corresponding
[`0.4`](https://github.com/elasticsearch/elasticsearch-ruby/tree/0.4) branch.

## Installation

Install the package from [Rubygems](https://rubygems.org):

    gem install elasticsearch-api

To use an unreleased version, either add it to your `Gemfile` for [Bundler](http://gembundler.com):

    gem 'elasticsearch-api', git: 'git://github.com/elasticsearch/elasticsearch-ruby.git'

or install it from a source code checkout:

    git clone https://github.com/elasticsearch/elasticsearch-ruby.git
    cd elasticsearch-ruby/elasticsearch-api
    bundle install
    rake install

## Usage

The library is designed as a group of standalone Ruby modules, which can be mixed into a class
providing connection to Elasticsearch -- an Elasticsearch client.

### Usage with the `elasticsearch` gem

**When you use the client from the [`elasticsearch-ruby`](https://github.com/elasticsearch/elasticsearch-ruby/) package,
the library modules have been already included**, so you just call the API methods:

```ruby
require 'elasticsearch'

client = Elasticsearch::Client.new log: true

client.index  index: 'myindex', type: 'mytype', id: 1, body: { title: 'Test' }
# => {"_index"=>"myindex", ... "created"=>true}

client.search index: 'myindex', body: { query: { match: { title: 'test' } } }
# => {"took"=>2, ..., "hits"=>{"total":5, ...}}
```

Full documentation and examples are included as RDoc annotations in the source code
and available online at <http://rubydoc.info/gems/elasticsearch-api>.

### Usage with a custom client

When you want to mix the library into your own client, it must conform to a following _contract_:

* It responds to a `perform_request(method, path, params, body)` method,
* the method returns an object with `status`, `body` and `headers` methods.

A simple client could look like this:

```ruby
require 'multi_json'
require 'faraday'
require 'elasticsearch/api'

class MySimpleClient
  include Elasticsearch::API

  CONNECTION = ::Faraday::Connection.new url: 'http://localhost:9200'

  def perform_request(method, path, params, body)
    puts "--> #{method.upcase} #{path} #{params} #{body}"

    CONNECTION.run_request \
      method.downcase.to_sym,
      path,
      ( body ? MultiJson.dump(body): nil ),
      {'Content-Type' => 'application/json'}
  end
end

client = MySimpleClient.new

p client.cluster.health
# --> GET _cluster/health {}
# => "{"cluster_name":"elasticsearch" ... }"

p client.index index: 'myindex', type: 'mytype', id: 'custom', body: { title: "Indexing from my client" }
# --> PUT myindex/mytype/custom {} {:title=>"Indexing from my client"}
# => "{"ok":true, ... }"
```

### Using JSON Builders

Instead of passing the `:body` argument as a Ruby _Hash_, you can pass it as a _String_, potentially
taking advantage of JSON builders such as [JBuilder](https://github.com/rails/jbuilder) or
[Jsonify](https://github.com/bsiggelkow/jsonify):

```ruby
require 'jbuilder'

query = Jbuilder.encode do |json|
  json.query do
    json.match do
      json.title do
        json.query    'test 1'
        json.operator 'and'
      end
    end
  end
end

client.search index: 'myindex', body: query

# 2013-06-25 09:56:05 +0200: GET http://localhost:9200/myindex/_search [status:200, request:0.015s, query:0.011s]
# 2013-06-25 09:56:05 +0200: > {"query":{"match":{"title":{"query":"test 1","operator":"and"}}}}
# ...
# => {"took"=>21, ..., "hits"=>{"total"=>1, "hits"=>[{ "_source"=>{"title"=>"Test 1", ...}}]}}
```

### Using Hash Wrappers

For a more comfortable access to response properties, you may wrap it in one of the _Hash_ "object access"
wrappers, such as [`Hashie::Mash`](https://github.com/intridea/hashie):

```ruby
require 'hashie'

response = client.search index: 'myindex',
                         body: {
                           query: { match: { title: 'test' } },
                           facets: { tags: { terms: { field: 'tags' } } }
                         }

mash = Hashie::Mash.new response

mash.hits.hits.first._source.title
# => 'Test'

mash.facets.tags.terms.first
# => #<Hashie::Mash count=3 term="z">
```

## Development

To work on the code, clone and bootstrap the main repository first --
please see instructions in the main [README](../README.md#development).

To run tests, launch a testing cluster -- again, see instructions
in the main [README](../README.md#development) -- and use the Rake tasks:

```
time rake test:unit
time rake test:integration
```

Unit tests have to use Ruby 1.8 compatible syntax, integration tests
can use Ruby 2.x syntax and features.

## License

This software is licensed under the Apache 2 license, quoted below.

    Copyright (c) 2013 Elasticsearch <http://www.elasticsearch.org>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
= GMetric

A pure Ruby client for generating Ganglia 3.1.x+ gmetric meta and metric packets and talking to your gmond / gmetad nodes over UDP protocol. Supports host spoofing, and all the same parameters as the gmetric command line executable.

- http://www.igvita.com/2010/01/28/cluster-monitoring-with-ganglia-ruby/

== Example: Sending a gmetric to a gmond over UDP

  Ganglia::GMetric.send("127.0.0.1", 8670, {
    :name => 'pageviews',
    :units => 'req/min',
    :type => 'uint8',
    :value => 7000,
    :tmax => 60,
    :dmax => 300
  })

== Example: Generating the Meta and Metric packets

  g = Ganglia::GMetric.pack(
    :slope => 'positive',
    :name => 'ruby',
    :value => rand(100),
    :tmax => 60,
    :units => '',
    :dmax => 60,
    :type => 'uint8'
  )

  # g[0] = meta packet
  # g[1] = gmetric packet
  
  s = UDPSocket.new
  s.connect("127.0.0.1", 8670)
  s.send g[0], 0
  s.send g[1], 0

== License

(The MIT License)

Copyright (c) 2009 Ilya Grigorik

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.# Concurrent Ruby
[![Gem Version](https://badge.fury.io/rb/concurrent-ruby.svg)](http://badge.fury.io/rb/concurrent-ruby) [![Build Status](https://travis-ci.org/ruby-concurrency/concurrent-ruby.svg?branch=master)](https://travis-ci.org/ruby-concurrency/concurrent-ruby) [![Coverage Status](https://img.shields.io/coveralls/ruby-concurrency/concurrent-ruby/master.svg)](https://coveralls.io/r/ruby-concurrency/concurrent-ruby) [![Code Climate](https://codeclimate.com/github/ruby-concurrency/concurrent-ruby.svg)](https://codeclimate.com/github/ruby-concurrency/concurrent-ruby) [![Inline docs](http://inch-ci.org/github/ruby-concurrency/concurrent-ruby.svg)](http://inch-ci.org/github/ruby-concurrency/concurrent-ruby) [![Dependency Status](https://gemnasium.com/ruby-concurrency/concurrent-ruby.svg)](https://gemnasium.com/ruby-concurrency/concurrent-ruby) [![License](https://img.shields.io/badge/license-MIT-green.svg)](http://opensource.org/licenses/MIT) [![Gitter chat](http://img.shields.io/badge/gitter-join%20chat%20%E2%86%92-brightgreen.svg)](https://gitter.im/ruby-concurrency/concurrent-ruby)

<table>
  <tr>
    <td align="left" valign="top">
      <p>
        Modern concurrency tools for Ruby. Inspired by
        <a href="http://www.erlang.org/doc/reference_manual/processes.html">Erlang</a>,
        <a href="http://clojure.org/concurrent_programming">Clojure</a>,
        <a href="http://akka.io/">Scala</a>,
        <a href="http://www.haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism#Concurrent_Haskell">Haskell</a>,
        <a href="http://blogs.msdn.com/b/dsyme/archive/2010/02/15/async-and-parallel-design-patterns-in-f-part-3-agents.aspx">F#</a>,
        <a href="http://msdn.microsoft.com/en-us/library/vstudio/hh191443.aspx">C#</a>,
        <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html">Java</a>,
        and classic concurrency patterns.
      </p>
      <p>
        The design goals of this gem are:
        <ul>
          <li>Be an 'unopinionated' toolbox that provides useful utilities without debating which is better or why</li>
          <li>Remain free of external gem dependencies</li>
          <li>Stay true to the spirit of the languages providing inspiration</li>
          <li>But implement in a way that makes sense for Ruby</li>
          <li>Keep the semantics as idiomatic Ruby as possible</li>
          <li>Support features that make sense in Ruby</li>
          <li>Exclude features that don't make sense in Ruby</li>
          <li>Be small, lean, and loosely coupled</li>
        </ul>
      </p>
    </td>
    <td align="right" valign="top">
      <img src="https://raw.githubusercontent.com/ruby-concurrency/concurrent-ruby/master/doc/logo/concurrent-ruby-logo-300x300.png"/>
    </td>
  </tr>
</table>

### Supported Ruby versions

MRI 1.9.3, 2.0, 2.1, 2.2, JRuby (1.9 mode), and Rubinius 2.x are supported.
This gem should be fully compatible with any interpreter that is compliant with Ruby 1.9.3 or newer.

## Features & Documentation

We have a roadmap guiding our work toward the [v1.0.0 release](https://github.com/ruby-concurrency/concurrent-ruby/wiki/v1.0-Roadmap).

The primary site for documentation is the automatically generated [API documentation](http://ruby-concurrency.github.io/concurrent-ruby/frames.html)

We also have a [mailing list](http://groups.google.com/group/concurrent-ruby).

This library contains a variety of concurrency abstractions at high and low levels. One of the high-level abstractions is likely to meet most common needs. 

### High-level, general-purpose asynchronous concurrency abstractions

* [Actor](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Actor.html): Implements the Actor Model, where concurrent actors exchange messages.
* [Agent](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Agent.html): A single atomic value that represents an identity.
* [Async](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Async.html): A mixin module that provides simple asynchronous behavior to any standard class/object or object.
* [Future](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Future.html): An asynchronous operation that produces a value.
  * [Dataflow](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Dataflow.html): Built on Futures, Dataflow allows you to create a task that will be scheduled when all of its data dependencies are available.
* [Promise](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Promise.html): Similar to Futures, with more features.
* [ScheduledTask](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/ScheduledTask.html): Like a Future scheduled for a specific future time.
* [TimerTask](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/TimerTask.html): A Thread that periodically wakes up to perform work at regular intervals. 
* [Channel](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Channel.html): Communicating Sequential Processes (CSP). 

### Java-inspired ThreadPools and other executors

* See [ThreadPool](http://ruby-concurrency.github.io/concurrent-ruby/file.thread_pools.html) overview, which also contains a list of other Executors available.

### Thread-safe Observers

* [Concurrent::Observable](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Observable.html) mixin module
* [CopyOnNotifyObserverSet](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/CopyOnNotifyObserverSet.html)
* [CopyOnWriteObserverSet](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/CopyOnWriteObserverSet.html)

### Thread synchronization classes and algorithms

Lower-level abstractions mainly used as building blocks. 

* [condition](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Condition.html)
* [countdown latch](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/CountDownLatch.html)
* [cyclic barrier](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/CyclicBarrier.html)
* [event](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Event.html)
* [exchanger](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Exchanger.html)
* [semaphore](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Semaphore.html)
* [timeout](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent.html#timeout-class_method)
* [timer](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent.html#timer-class_method)

### Thread-safe variables

Lower-level abstractions mainly used as building blocks. 

* [AtomicBoolean](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/AtomicBoolean.html)
* [AtomicFixnum](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/AtomicFixnum.html)
* AtomicReference (no docs currently available, check source)
* [I-Structures](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/IVar.html) (IVar)
* [M-Structures](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/MVar.html) (MVar)
* [thread-local variables](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/ThreadLocalVar.html)
* [software transactional memory](http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/TVar.html) (TVar)

## Usage

All abstractions within this gem can be loaded simply by requiring it:

```ruby
require 'concurrent'
```

To reduce the amount of code loaded at runtime, subsets of this gem can be required:

```ruby
require 'concurrent'                # everything

# groups

require 'concurrent/actor'          # Concurrent::Actor and supporting code
require 'concurrent/atomics'        # atomic and thread synchronization classes
require 'concurrent/channels'       # Concurrent::Channel and supporting code
require 'concurrent/executors'      # Thread pools and other executors
require 'concurrent/utilities'      # utility methods such as processor count and timers

# individual abstractions

require 'concurrent/agent'          # Concurrent::Agent
require 'concurrent/async'          # Concurrent::Async
require 'concurrent/atomic'         # Concurrent::Atomic (formerly the `atomic` gem)
require 'concurrent/dataflow'       # Concurrent::dataflow
require 'concurrent/delay'          # Concurrent::Delay
require 'concurrent/exchanger'      # Concurrent::Exchanger
require 'concurrent/future'         # Concurrent::Future
require 'concurrent/ivar'           # Concurrent::IVar
require 'concurrent/mvar'           # Concurrent::MVar
require 'concurrent/promise'        # Concurrent::Promise
require 'concurrent/scheduled_task' # Concurrent::ScheduledTask
require 'concurrent/timer_task'     # Concurrent::TimerTask
require 'concurrent/tvar'           # Concurrent::TVar
```

## Installation

```shell
gem install concurrent-ruby
```

or add the following line to Gemfile:

```ruby
gem 'concurrent-ruby'
```

and run `bundle install` from your shell.

### C Extensions for MRI

Potential performance improvements may be achieved under MRI by installing optional C extensions.
To minimize installation errors the C extensions are available in the `concurrent-ruby-ext` extension
gem. The extension gem lists `concurrent-ruby` as a dependency so it is not necessary to install both.
Simply install the extension gen:

```ruby
gem install concurrent-ruby-ext
```

or add the following line to Gemfile:

```ruby
gem 'concurrent-ruby-ext'
```

and run `bundle install` from your shell.

In code it is only necessary to

```ruby
require 'concurrent'
```

The `concurrent-ruby` gem will automatically detect the presence of the `concurrent-ruby-ext` gem
and load the appropriate C extensions.

#### Note For gem developers

No gems should depend on `concurrent-ruby-ext`. Doing so will force C extensions on your users.
The best practice is to depend on `concurrent-ruby` and let users to decide if they want C extensions.

### Building

All published versions of this gem (core, extension, and several platform-specific packages) are compiled,
packaged, tested, and published using an open, [automated process](https://github.com/ruby-concurrency/rake-compiler-dev-box).
This process can also be used to create pre-compiled binaries of the extension gem for virtally
any platform. *Documentation is forthcoming...*

```
*MRI only*
rake build:native       # Build concurrent-ruby-ext-<version>-<platform>.gem into the pkg directory
rake compile:extension  # Compile extension

*JRuby only*
rake build              # Build JRuby-specific core gem (alias for `build:core`)
rake build:core         # Build concurrent-ruby-<version>-java.gem into the pkg directory

*All except JRuby*
rake build              # Build core and extension gems
rake build:core         # Build concurrent-ruby-<version>.gem into the pkg directory
rake build:ext          # Build concurrent-ruby-ext-<version>.gem into the pkg directory

*All*
rake clean              # Remove any temporary products
rake clobber            # Remove any generated file
rake compile            # Compile all the extensions
```

## Maintainers

* [Jerry D'Antonio](https://github.com/jdantonio)
* [Michele Della Torre](https://github.com/mighe)
* [Chris Seaton](https://github.com/chrisseaton)
* [Lucas Allan](https://github.com/lucasallan)
* [Petr Chalupa](https://github.com/pitr-ch)
* [Paweł Obrok](https://github.com/obrok)

### Contributing

1. Fork it
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Add some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create new Pull Request

## License and Copyright

*Concurrent Ruby* is free software released under the [MIT License](http://www.opensource.org/licenses/MIT).

The *Concurrent Ruby* [logo](https://github.com/ruby-concurrency/concurrent-ruby/wiki/Logo)
was designed by [David Jones](https://twitter.com/zombyboy).
It is Copyright &copy; 2014 [Jerry D'Antonio](https://twitter.com/jerrydantonio). All Rights Reserved.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.= GELF

This is the new GELF gem written by Alexey Palazhchenko. It is based on the old gem by Lennart Koopmann and allows you to send GELF messages to Graylog2 server instances. See http://www.graylog2.org/about/gelf for more information about GELF and http://rdoc.info/github/Graylog2/gelf-rb/master/frames for API documentation.

Works with Ruby 1.8.7 and 1.9.x. 1.8.6 is not supported.

== Note on Patches/Pull Requests

* Fork the project.
* Make your feature addition or bug fix.
* Add tests for it. This is important so I don't break it in a future version unintentionally.
* Commit, do not mess with rakefile, version, or history.
  (if you want to have your own version, that is fine but bump version in a commit by itself I can ignore when I pull)
* Send me a pull request. Bonus points for topic branches.

== Copyright

Copyright (c) 2010-2011 Lennart Koopmann and Alexey Palazhchenko. See LICENSE for details.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# Metriks Client

This is an experiment in making a threadsafe, low impact library to measure
aspects of your ruby.

The library is very much a work-in-progress. It is being developed as
I find needs while developing [Papertrail](https://papertrailapp.com/).


# Installing

The API is still in flux, but you can add this to your project by installing
the gem.

To install, add this to your `Gemfile`:

``` ruby
gem 'metriks'
```

and re-run `bundle`.


# Metric API Overview

## Counters

Basic atomic counter. Used as an underlying metric for many of the other
more advanced metrics.


### increment(incr = 1)

Increment the counter. Without an argument it will increment by `1`.

``` ruby
  counter = Metriks.counter('calls')
  counter.increment
```

### decrement(decr = 1)

Decrement the counter. Without an argument it will decrement by `1`.

``` ruby
  counter = Metriks.counter('calls')
  counter.decrement
```

#### count()

Return the current value of the counter.

``` ruby
  counter = Metriks.counter('calls')
  puts "counter: #{counter.count}"
```

## Gauges

A gauge is an instantaneous measurement of a value.

It takes a callback to measure the value in form of a block or a callable
object.

**WARNING:** The code in the callback is executed every time the `#value`
method is called on the gauge. Most of the time this will be done by a
metriks reporter that is running in a separate thread.

``` ruby
  # Callback as block
  gauge = Metriks.gauge('queue.size') { queue.size }

  # Callback as object responding to #call
  callable = proc { queue.size }
  gauge = Metriks.gauge('queue.size', callable)
```

### set(val)

Set the current value.

``` ruby
  gauge = Metriks.gauge('queue_size')
  gauge.set(queue.size)
```

### value()

Returns the value returned by the callback (if one is defined), returns the
value set via `#set` (or the default of 0) otherwise.

``` ruby
  gauge = Metriks.gauge('queue_size')
  puts "queue size: #{gauge.value}"
```

## Meters

A meter that measures the mean throughput and the one-, five-, and
fifteen-minute exponentially-weighted moving average throughputs.

### mark(val = 1)

Record an event with the meter. Without an argument it will record one event.

``` ruby
  meter = Metriks.meter('requests')
  meter.mark
```

### count()

Returns the total number of events that have been recorded.

``` ruby
  meter = Metriks.meter('requests')
  puts "total: #{meter.count}"
```

### one_minute_rate()

Returns the one-minute average rate.

``` ruby
  meter = Metriks.meter('requests')
  puts "rate: #{meter.one_minute_rate}/sec"
```

### five_minute_rate()

Returns the five-minute average rate.

``` ruby
  meter = Metriks.meter('requests')
  puts "rate: #{meter.five_minute_rate}/sec"
```

### fifteen_minute_rate()

Returns the fifteen-minute average rate.

``` ruby
  meter = Metriks.meter('requests')
  puts "rate: #{meter.fifteen_minute_rate}/sec"
```

### mean_rate()

Returns the mean (average) rate of the events since the start of the process.

``` ruby
  meter = Metriks.meter('requests')
  puts "rate: #{meter.mean_rate}/sec"
```

## Timers

A timer that measures the average time as well as throughput metrics via
a meter.

### update(duration)

Records the duration of an operation. This normally wouldn't need to be
called — the `#time` method is provided to simplify recording a duration.

``` ruby
  timer = Metriks.timer('requests')
  t0 = Time.now
  work
  timer.update(Time.now - t0)
```

### time(callable = nil, &block)

Measure the amount of time a proc takes to execute. Takes either a block
or an object responding to `#call` (normally a `proc` or `lambda`).

``` ruby
  timer = Metriks.timer('requests')
  work_result = timer.time do
    work
  end
```

If neither a block or an object is passed to the method, an object that
responds to `#stop` will be returned. When `#stop` is called, the time
will be recorded.

``` ruby
  timer = Metriks.timer('requests')
  t = timer.time
  work
  t.stop
```

### count()

Returns the number of measurements that have been made.

``` ruby
  timer = Metriks.timer('requests')
  puts "calls: #{timer.count}"
```

### one_minute_rate()

Returns the one-minute average rate.

``` ruby
  meter = Metriks.timer('requests')
  puts "rate: #{meter.one_minute_rate}/sec"
```

### five_minute_rate()

Returns the five-minute average rate.

``` ruby
  meter = Metriks.timer('requests')
  puts "rate: #{meter.five_minute_rate}/sec"
```

### fifteen_minute_rate()

Returns the fifteen-minute average rate.

``` ruby
  meter = Metriks.timer('requests')
  puts "rate: #{meter.fifteen_minute_rate}/sec"
```

### mean_rate()

Returns the mean (average) rate of the events since the start of the process.

``` ruby
  meter = Metriks.timer('requests')
  puts "rate: #{meter.mean_rate}/sec"
```

### min()

Returns the minimum amount of time spent in the operation.

``` ruby
  meter = Metriks.timer('requests')
  puts "time: #{meter.min} seconds"
```

### max()

Returns the maximum time spent in the operation.

``` ruby
  meter = Metriks.timer('requests')
  puts "time: #{meter.max} seconds"
```

### mean()

Returns the mean (average) time spent in the operation.

``` ruby
  meter = Metriks.timer('requests')
  puts "time: #{meter.mean} seconds"
```

### stddev()

Returns the standard deviation of the mean spent in the operation.

``` ruby
  meter = Metriks.timer('requests')
  puts "time: #{meter.stddev} seconds"
```


## Utilization Timer

A specialized `Timer` that calculates the percentage (between `0.0` and `1.0`) of
wall-clock time that was spent. It includes all of the methods of `Timer`.


### one_minute_utilization()

Returns the one-minute average utilization as a percentage between `0.0` and `1.0`.

``` ruby
  meter = Metriks.utilization_timer('requests')
  puts "utilization: #{meter.one_minute_utilization * 100}%"
```

### five_minute_utilization()

Returns the five-minute average utilization as a percentage between `0.0` and `1.0`.

``` ruby
  meter = Metriks.utilization_timer('requests')
  puts "utilization: #{meter.five_minute_utilization * 100}%"
```

### fifteen_minute_utilization()

Returns the fifteen-minute average utilization as a percentage between `0.0` and `1.0`.

``` ruby
  meter = Metriks.utilization_timer('requests')
  puts "utilization: #{meter.fifteen_minute_utilization * 100}%"
```

### mean_utilization()

Returns the mean (average) utilization as a percentage between `0.0` and `1.0`
since the process started.

``` ruby
  meter = Metriks.utilization_timer('requests')
  puts "utilization: #{meter.mean_utilization * 100}%"
```


# Reporter Overview

How to get metrics out of the process.

## Graphite Reporter

Sends metrics to Graphite every 60 seconds.

``` ruby
  reporter = Metriks::Reporter::Graphite.new 'localhost', 3004
  reporter.start
```


## Logger Reporter

Send metrics to a logger every 60 seconds.

``` ruby
  reporter = Metriks::Reporter::Logger.new(:logger => Logger.new('log/metrics.log'))
  reporter.start
```


## Librato Metrics Reporter

The Librato Metrics reporter has been moved to
[eric/metriks-librato_metrics](https://github.com/eric/metriks-librato_metrics).


## Proc Title Reporter

Provides a simple way to get up-to-date statistics from a process by
updating the proctitle every 5 seconds (default).

``` ruby
  reporter = Metriks::Reporter::ProcTitle.new :interval => 5
  reporter.add 'reqs', 'sec' do
    Metriks.meter('rack.requests').one_minute_rate
  end
  reporter.start
```

will display:

```
501      17015 26.0  1.9 416976 246956 ?       Ss   18:54  11:43 thin reqs: 273.3/sec
```

## Sematext Metrics Reporter

[metriks-sematext](https://github.com/sematext/metriks-sematext) gem provides reporter for sending metrics to [SPM](http://sematext.com/spm/index.html).

# Application Server Configuration

Depending on how your application server operates, you may need to configure how reporters are created. Please look at [Troubleshooting](https://github.com/eric/metriks/wiki/Troubleshooting) for more information.

# Plans

An incomplete list of things I would like to see added:

* Rack middleware to measure utilization, throughput and worker time
* Basic reporters:
  * Rack endpoint returning JSON
  * [Statsd](https://github.com/etsy/statsd) reporter
* Metaprogramming instrumentation hooks like [Shopify's statsd-instrument](https://github.com/Shopify/statsd-instrument)


# Credits

Most of the inspiration for this project comes from Coda Hale's amazing
[Metrics, Metrics Everywhere][metrics-talk] talk at CodeConf and his sweet
[Metrics][metrics] Java Library.

[metrics-talk]: http://pivotallabs.com/talks/139-metrics-metrics-everywhere
[metrics]: https://github.com/codahale/metrics


# License

Copyright (c) 2012 Eric Lindvall

Published under the MIT License, see LICENSE
TZInfo - Ruby Timezone Library
==============================

[![Gem Version](https://badge.fury.io/rb/tzinfo.svg)](http://badge.fury.io/rb/tzinfo) [![Build Status](https://travis-ci.org/tzinfo/tzinfo.svg?branch=master)](https://travis-ci.org/tzinfo/tzinfo)

[TZInfo](http://tzinfo.github.io) provides daylight savings aware 
transformations between times in different timezones.


Data Sources
------------

TZInfo requires a source of timezone data. There are two built-in options:

1. The TZInfo::Data library (the tzinfo-data gem). TZInfo::Data contains a set 
   of Ruby modules that are generated from the [IANA Time Zone Database](http://www.iana.org/time-zones).
2. A zoneinfo directory. Most Unix-like systems include a zoneinfo directory 
   containing timezone definitions. These are also generated from the 
   [IANA Time Zone Database](http://www.iana.org/time-zones).

By default, TZInfo::Data will be used. If TZInfo::Data is not available (i.e. 
if `require 'tzinfo/data'` fails), then TZInfo will search for a zoneinfo
directory instead (using the search path specified by 
`TZInfo::ZoneinfoDataSource::DEFAULT_SEARCH_PATH`).

If no data source can be found, a `TZInfo::DataSourceNotFound` exception will be
raised when TZInfo is used. Further information is available 
[in the wiki](http://tzinfo.github.io/datasourcenotfound) to help with 
resolving `TZInfo::DataSourceNotFound` errors.

The default data source selection can be overridden using 
`TZInfo::DataSource.set`.

Custom data sources can also be used. See `TZInfo::DataSource.set` for
further details.


Installation
------------

The TZInfo gem can be installed by running:

    gem install tzinfo

To use the Ruby modules as the data source, TZInfo::Data will also need to be
installed:

    gem install tzinfo-data
  

Example Usage
-------------

The following code will obtain the America/New_York timezone (as an instance
of `TZInfo::Timezone`) and convert a time in UTC to local New York time:

    require 'tzinfo'
    
    tz = TZInfo::Timezone.get('America/New_York')
    local = tz.utc_to_local(Time.utc(2005,8,29,15,35,0))

Note that the local Time returned will have a UTC timezone (`local.zone` will 
return `"UTC"`). This is because the Ruby Time class only supports two timezones: 
UTC and the current system local timezone.
  
To convert from a local time to UTC, the `local_to_utc` method can be used as
follows:

    utc = tz.local_to_utc(local)

Note that the timezone information of the local Time object is ignored (TZInfo
will just read the date and time and treat them as if there were in the `tz`
timezone). The following two lines will return the same result regardless of 
the system's local timezone:

    tz.local_to_utc(Time.local(2006,6,26,1,0,0))
    tz.local_to_utc(Time.utc(2006,6,26,1,0,0))
  
To obtain information about the rules in force at a particular UTC or local 
time, the `TZInfo::Timezone.period_for_utc` and 
`TZInfo::Timezone.period_for_local` methods can be used. Both of these methods 
return `TZInfo::TimezonePeriod` objects. The following gets the identifier for 
the period (in this case EDT).

    period = tz.period_for_utc(Time.utc(2005,8,29,15,35,0))
    id = period.zone_identifier
  
The current local time in a `Timezone` can be obtained with the 
`TZInfo::Timezone#now` method:

    now = tz.now

All methods in TZInfo that operate on a time can be used with either `Time` or 
`DateTime` instances or with Integer timestamps (i.e. as returned by 
`Time#to_i`). The type of the values returned will match the type passed in.

A list of all the available timezone identifiers can be obtained using the
`TZInfo::Timezone.all_identifiers` method. `TZInfo::Timezone.all` can be called
to get an `Array` of all the `TZInfo::Timezone` instances.

Timezones can also be accessed by country (using an ISO 3166-1 alpha-2 country 
code). The following code retrieves the `TZInfo::Country` instance representing 
the USA (country code 'US') and then gets all the timezone identifiers used in 
the USA.

    us = TZInfo::Country.get('US')
    timezones = us.zone_identifiers
  
The `TZInfo::Country#zone_info` method provides an additional description and 
geographic location for each timezone in a country.

A list of all the available country codes can be obtained using the
`TZInfo::Country.all_codes` method. `TZInfo::Country.all` can be called to get 
an `Array` of all the `Country` instances.
  
For further detail, please refer to the API documentation for the 
`TZInfo::Timezone` and `TZInfo::Country` classes.


Thread-Safety
-------------

The `TZInfo::Country` and `TZInfo::Timezone` classes are thread-safe. It is safe
to use class and instance methods of `TZInfo::Country` and `TZInfo::Timezone` in 
concurrently executing threads. Instances of both classes can be shared across 
thread boundaries.


Documentation
-------------

API documentation for TZInfo is available on [RubyDoc.info](http://rubydoc.info/gems/tzinfo/frames).


License
-------

TZInfo is released under the MIT license, see LICENSE for details.


Source Code
-----------

Source code for TZInfo is available on [GitHub](https://github.com/tzinfo/tzinfo).


Issue Tracker
-------------

Please post any bugs, issues, feature requests or questions to the 
[GitHub issue tracker](https://github.com/tzinfo/tzinfo/issues).
English.rb	lets Perl'ish global variables have English names
README		this file
abbrev.rb	abbreviation calculator
base64.rb	Base64 de- and encoder
benchmark.rb	a benchmark utility
cgi.rb		CGI support library
cgi/session.rb	CGI session class
cmath.rb	math support for complex numbers
complex.rb	includes cmath and set complex arithemtic as default (obsolete)
csv.rb		CSV parser/generator
debug.rb	ruby debugger
delegate.rb	delegates messages to other object
drb.rb		distributed Ruby
e2mmap.rb	exception utilities
erb.rb		tiny eRuby library
fileutils.rb	file utilities
find.rb		traverses directory tree
forwardable.rb	explicit delegation library
gauntlet_rubygems.rb 	Gem package validator
getoptlong.rb	GNU getoptlong compatible
gserver.rb	general TCP server
ipaddr.rb	defines the IPAddr class
irb.rb		interactive ruby
logger.rb	simple logging utility
mathn.rb	extended math operation (obsolete)
matrix.rb	matrix calculation library
minitest/unit	minimal drop-in replacement for test-unit
mkmf.rb		Makefile maker
monitor.rb	exclusive region monitor for thread
mutex_m.rb	mutex mixin
net/ftp.rb	ftp access
net/http.rb	HTTP access
net/https.rb	HTTPS access
net/imap.rb	IMAP4 access
net/pop.rb	POP3 access
net/protocol.rb	abstract class for net library (DO NOT USE)
net/smtp.rb	SMTP access
net/telnet.rb	telnet library
observer.rb	observer desing pattern library (provides Observable)
open-uri.rb	easy-to-use network interface using URI and Net
open3.rb	opens subprocess connection stdin/stdout/stderr
optparse.rb	command line option analysis
ostruct.rb	python style object
pathname.rb	Object-Oriented Pathname Class
pp.rb		pretty print objects
prettyprint.rb	pretty printing algorithm
prime.rb        prime numbers and factorization
profile.rb	runs ruby profiler
profiler.rb	ruby profiler module
pstore.rb	persistent object strage using marshal
racc/parser.rb	racc (Ruby yACC) runtime
rake.rb		Ruby Make
rational.rb	rational number support (obsolete)
rdoc		source-code documentation tool
resolv-replace.rb	replace Socket DNS by resolve.rb
resolv.rb	DNS resolver in Ruby
rexml		an XML parser for Ruby, in Ruby
rinda/rinda.rb	Linda distributed computing paradigm for drb
rinda/ring.rb	RingServer for tuplespace
rinda/tuplespace.rb	tuplespace for drb
rss.rb		RSS parser/generator
rubygems	Ruby package management system
scanf.rb	scanf for Ruby
securerandom.rb	Secure random number generator interface
set.rb		defines the Set class
shell.rb	runs commands and does pipeline operations like shell
shellwords.rb	split into words like shell
singleton.rb	singleton design pattern library
sync.rb		2 phase lock
tempfile.rb	temporary file with automatic removal
test/unit	Ruby Unit Testing Framework
thread.rb	thread support
thwait.rb	thread syncronization class
time.rb		RFC2822, RFC2616, ISO8601 style time formatting/parsing
timeout.rb	provides timeout
tmpdir.rb	retrieve temporary directory path
tracer.rb	execution tracer
tsort.rb	topological sorting
ubygems.rb	command line shortcut for RubyGems
un.rb		Utilities to replace common UNIX commands in Makefiles etc
uri.rb		URI support
uri/ftp.rb	ftp scheme support
uri/http.rb	http scheme support
uri/https.rb	https scheme support
uri/ldap.rb	ldap scheme support
uri/ldaps.rb	ldaps scheme support
uri/mailto.rb	mailto scheme support
weakref.rb	weak reference class
webrick.rb	WEB server toolkit
xmlrpc		XML-RPC implementation
yaml.rb		YAML implementation
= XMLRPC for Ruby, Standard Library Documentation

== Overview

XMLRPC is a lightweight protocol that enables remote procedure calls over
HTTP.  It is defined at http://www.xmlrpc.com.

XMLRPC allows you to create simple distributed computing solutions that span
computer languages.  Its distinctive feature is its simplicity compared to
other approaches like SOAP and CORBA.

The Ruby standard library package 'xmlrpc' enables you to create a server that
implements remote procedures and a client that calls them.  Very little code
is required to achieve either of these.

== Example

Try the following code.  It calls a standard demonstration remote procedure.

  require 'xmlrpc/client'
  require 'pp'

  server = XMLRPC::Client.new2("http://xmlrpc-c.sourceforge.net/api/sample.php")
  result = server.call("sample.sumAndDifference", 5, 3)
  pp result

== Documentation

See http://www.ntecs.de/projects/xmlrpc4r.  There is plenty of detail there to
use the client and implement a server.

= XMLRPC for Ruby

== Author and Copyright

Copyright (C) 2001-2004 by Michael Neumann (mailto:mneumann@ntecs.de)

Released under the same term of license as Ruby.

== Overview

XMLRPC is a lightweight protocol that enables remote procedure calls over
HTTP.  It is defined at http://www.xmlrpc.com.

XMLRPC allows you to create simple distributed computing solutions that span
computer languages.  Its distinctive feature is its simplicity compared to
other approaches like SOAP and CORBA.

The Ruby standard library package 'xmlrpc' enables you to create a server that
implements remote procedures and a client that calls them.  Very little code
is required to achieve either of these.

== Example

Try the following code.  It calls a standard demonstration remote procedure.

  require 'xmlrpc/client'
  require 'pp'

  server = XMLRPC::Client.new2("http://xmlrpc-c.sourceforge.net/api/sample.php")
  result = server.call("sample.sumAndDifference", 5, 3)
  pp result

== Documentation

See http://www.ntecs.de/projects/xmlrpc4r.  There is plenty of detail there to
use the client and implement a server.

== Features of XMLRPC for Ruby

* Extensions
  * Introspection
  * multiCall
  * optionally nil values and integers larger than 32 Bit

* Server
  * Standalone XML-RPC server
  * CGI-based (works with FastCGI)
  * Apache mod_ruby server
  * WEBrick servlet

* Client
  * synchronous/asynchronous calls
  * Basic HTTP-401 Authentification
  * HTTPS protocol (SSL)

* Parsers
  * NQXML (NQXMLStreamParser, NQXMLTreeParser)
  * Expat (XMLStreamParser, XMLTreeParser)
  * REXML (REXMLStreamParser)
  * xml-scan (XMLScanStreamParser)
  * Fastest parser is Expat's XMLStreamParser!

* General
  * possible to choose between XMLParser module (Expat wrapper) and REXML/NQXML (pure Ruby) parsers
  * Marshalling Ruby objects to Hashs and reconstruct them later from a Hash
  * SandStorm component architecture Client interface

== Howto

=== Client

  require "xmlrpc/client"

  # Make an object to represent the XML-RPC server.
  server = XMLRPC::Client.new( "xmlrpc-c.sourceforge.net", "/api/sample.php")

  # Call the remote server and get our result
  result = server.call("sample.sumAndDifference", 5, 3)

  sum = result["sum"]
  difference = result["difference"]

  puts "Sum: #{sum}, Difference: #{difference}"

=== Client with XML-RPC fault-structure handling

There are two possible ways, of handling a fault-structure:

==== by catching a XMLRPC::FaultException exception

  require "xmlrpc/client"

  # Make an object to represent the XML-RPC server.
  server = XMLRPC::Client.new( "xmlrpc-c.sourceforge.net", "/api/sample.php")

  begin
    # Call the remote server and get our result
    result = server.call("sample.sumAndDifference", 5, 3)

    sum = result["sum"]
    difference = result["difference"]

    puts "Sum: #{sum}, Difference: #{difference}"

  rescue XMLRPC::FaultException => e
    puts "Error: "
    puts e.faultCode
    puts e.faultString
  end

==== by calling "call2" which returns a boolean

  require "xmlrpc/client"

  # Make an object to represent the XML-RPC server.
  server = XMLRPC::Client.new( "xmlrpc-c.sourceforge.net", "/api/sample.php")

  # Call the remote server and get our result
  ok, result = server.call2("sample.sumAndDifference", 5, 3)

  if ok
    sum = result["sum"]
    difference = result["difference"]

    puts "Sum: #{sum}, Difference: #{difference}"
  else
    puts "Error: "
    puts result.faultCode
    puts result.faultString
  end

=== Client using Proxy

You can create a +Proxy+ object onto which you can call methods. This way it
looks nicer. Both forms, _call_ and _call2_ are supported through _proxy_ and
<i>proxy2</i>.  You can additionally give arguments to the Proxy, which will be
given to each XML-RPC call using that Proxy.

  require "xmlrpc/client"

  # Make an object to represent the XML-RPC server.
  server = XMLRPC::Client.new( "xmlrpc-c.sourceforge.net", "/api/sample.php")

  # Create a Proxy object
  sample = server.proxy("sample")

  # Call the remote server and get our result
  result = sample.sumAndDifference(5,3)

  sum = result["sum"]
  difference = result["difference"]

  puts "Sum: #{sum}, Difference: #{difference}"

=== CGI-based Server

There are also two ways to define handler, the first is
like C/PHP, the second like Java, of course both ways
can be mixed:

==== C/PHP-like (handler functions)

  require "xmlrpc/server"

  s = XMLRPC::CGIServer.new

  s.add_handler("sample.sumAndDifference") do |a,b|
    { "sum" => a + b, "difference" => a - b }
  end

  s.serve

==== Java-like (handler classes)

  require "xmlrpc/server"

  s = XMLRPC::CGIServer.new

  class MyHandler
    def sumAndDifference(a, b)
      { "sum" => a + b, "difference" => a - b }
    end
  end

  # NOTE: Security Hole (read below)!!!
  s.add_handler("sample", MyHandler.new)
  s.serve


To return a fault-structure you have to raise an FaultException e.g.:

  raise XMLRPC::FaultException.new(3, "division by Zero")

===== Security Note

From Brian Candler:

  Above code sample has an extremely nasty security hole, in that you can now call
  any method of 'MyHandler' remotely, including methods inherited from Object
  and Kernel! For example, in the client code, you can use

    puts server.call("sample.send","`","ls")

  (backtick being the method name for running system processes). Needless to
  say, 'ls' can be replaced with something else.

  The version which binds proc objects (or the version presented below in the next section)
  doesn't have this problem, but people may be tempted to use the second version because it's
  so nice and 'Rubyesque'. I think it needs a big red disclaimer.


From Michael:

A solution is to undef insecure methods or to use (({XMLRPC::iPIMethods})) as shown below:

  class MyHandler
    def sumAndDifference(a, b)
      { "sum" => a + b, "difference" => a - b }
    end
  end

  # ... server initialization ...

  s.add_handler(XMLRPC::iPIMethods("sample"), MyHandler.new)

  # ...

This adds only public instance methods explicitly declared in class MyHandler
(and not those inherited from any other class).

==== With interface declarations

Code sample from the book Ruby Developer's Guide:

  require "xmlrpc/server"

  class Num
    INTERFACE = XMLRPC::interface("num") {
      meth 'int add(int, int)', 'Add two numbers', 'add'
      meth 'int div(int, int)', 'Divide two numbers'
    }

    def add(a, b) a + b end
    def div(a, b) a / b end
  end


  s = XMLRPC::CGIServer.new
  s.add_handler(Num::INTERFACE, Num.new)
  s.serve

=== Standalone server

Same as CGI-based server, only that the line

  server = XMLRPC::CGIServer.new

must be changed to

  server = XMLRPC::Server.new(8080)

if you want a server listening on port 8080.
The rest is the same.

=== Choosing a different XML Parser or XML Writer

The examples above all use the default parser (which is now since 1.8
REXMLStreamParser) and a default XML writer.  If you want to use a different
XML parser, then you have to call the <i>set_parser</i> method of
<tt>XMLRPC::Client</tt> instances or instances of subclasses of
<tt>XMLRPC::BasicServer</tt> or by editing xmlrpc/config.rb.

Client Example:

  # ...
  server = XMLRPC::Client.new( "xmlrpc-c.sourceforge.net", "/api/sample.php")
  server.set_parser(XMLRPC::XMLParser::XMLParser.new)
  # ...

Server Example:

  # ...
  s = XMLRPC::CGIServer.new
  s.set_parser(XMLRPC::XMLParser::XMLStreamParser.new)
  # ...

or:

  # ...
  server = XMLRPC::Server.new(8080)
  server.set_parser(XMLRPC::XMLParser::NQXMLParser.new)
  # ...


Note that XMLStreamParser is incredible faster (and uses less memory) than any
other parser and scales well for large documents. For example for a 0.5 MB XML
document with many tags, XMLStreamParser is ~350 (!) times faster than
NQXMLTreeParser and still ~18 times as fast as XMLTreeParser.

You can change the XML-writer by calling method <i>set_writer</i>.
= minitest/*

* http://rubyforge.org/projects/bfts

== DESCRIPTION:

minitest provides a complete suite of testing facilities supporting
TDD, BDD, mocking, and benchmarking.

minitest/unit is a small and incredibly fast unit testing framework.
It provides a rich set of assertions to make your tests clean and
readable.

minitest/spec is a functionally complete spec engine. It hooks onto
minitest/unit and seamlessly bridges test assertions over to spec
expectations.

minitest/benchmark is an awesome way to assert the performance of your
algorithms in a repeatable manner. Now you can assert that your newb
co-worker doesn't replace your linear algorithm with an exponential
one!

minitest/mock by Steven Baker, is a beautifully tiny mock object
framework.

minitest/pride shows pride in testing and adds coloring to your test
output.

minitest/unit is meant to have a clean implementation for language
implementors that need a minimal set of methods to bootstrap a working
test suite. For example, there is no magic involved for test-case
discovery.

== FEATURES/PROBLEMS:

* minitest/autorun - the easy and explicit way to run all your tests.
* minitest/unit - a very fast, simple, and clean test system.
* minitest/spec - a very fast, simple, and clean spec system.
* minitest/mock - a simple and clean mock system.
* minitest/benchmark - an awesome way to assert your algorithm's performance.
* minitest/pride - show your pride in testing!
* Incredibly small and fast runner, but no bells and whistles.

== RATIONALE:

See design_rationale.rb to see how specs and tests work in minitest.

== SYNOPSIS:

Given that you'd like to test the following class:

  class Meme
    def i_can_has_cheezburger?
      "OHAI!"
    end

    def will_it_blend?
      "YES!"
    end
  end

=== Unit tests

  require 'minitest/autorun'

  class TestMeme < MiniTest::Unit::TestCase
    def setup
      @meme = Meme.new
    end

    def test_that_kitty_can_eat
      assert_equal "OHAI!", @meme.i_can_has_cheezburger?
    end

    def test_that_it_will_not_blend
      refute_match /^no/i, @meme.will_it_blend?
    end
  end

=== Specs

  require 'minitest/autorun'

  describe Meme do
    before do
      @meme = Meme.new
    end

    describe "when asked about cheeseburgers" do
      it "must respond positively" do
        @meme.i_can_has_cheezburger?.must_equal "OHAI!"
      end
    end

    describe "when asked about blending possibilities" do
      it "won't say no" do
        @meme.will_it_blend?.wont_match /^no/i
      end
    end
  end

=== Benchmarks

Add benchmarks to your regular unit tests. If the unit tests fail, the
benchmarks won't run.

  # optionally run benchmarks, good for CI-only work!
  require 'minitest/benchmark' if ENV["BENCH"]

  class TestMeme < MiniTest::Unit::TestCase
    # Override self.bench_range or default range is [1, 10, 100, 1_000, 10_000]
    def bench_my_algorithm
      assert_performance_linear 0.9999 do |n| # n is a range value
        n.times do
          @obj.my_algorithm
        end
      end
    end
  end

Or add them to your specs. If you make benchmarks optional, you'll
need to wrap your benchmarks in a conditional since the methods won't
be defined.

  describe Meme do
    if ENV["BENCH"] then
      bench_performance_linear "my_algorithm", 0.9999 do |n|
        100.times do
          @obj.my_algorithm(n)
        end
      end
    end
  end

outputs something like:

  # Running benchmarks:

  TestBlah	100	1000	10000
  bench_my_algorithm	 0.006167	 0.079279	 0.786993
  bench_other_algorithm	 0.061679	 0.792797	 7.869932

Output is tab-delimited to make it easy to paste into a spreadsheet.

=== Mocks

  class MemeAsker
    def initialize(meme)
      @meme = meme
    end

    def ask(question)
      method = question.tr(" ","_") + "?"
      @meme.send(method)
    end
  end

  require 'minitest/autorun'

  describe MemeAsker do
    before do
      @meme = MiniTest::Mock.new
      @meme_asker = MemeAsker.new @meme
    end

    describe "#ask" do
      describe "when passed an unpunctuated question" do
        it "should invoke the appropriate predicate method on the meme" do
          @meme.expect :will_it_blend?, :return_value
          @meme_asker.ask "will it blend"
          @meme.verify
        end
      end
    end
  end

=== Customizable Test Runner Types:

MiniTest::Unit.runner=(runner) provides an easy way of creating custom
test runners for specialized needs. Justin Weiss provides the
following real-world example to create an alternative to regular
fixture loading:

  class MiniTestWithHooks::Unit < MiniTest::Unit
    def before_suites
    end

    def after_suites
    end

    def _run_suites(suites, type)
      begin
        before_suites
        super(suites, type)
      ensure
        after_suites
      end
    end

    def _run_suite(suite, type)
      begin
        suite.before_suite
        super(suite, type)
      ensure
        suite.after_suite
      end
    end
  end

  module MiniTestWithTransactions
    class Unit < MiniTestWithHooks::Unit
      include TestSetupHelper

      def before_suites
        super
        setup_nested_transactions
        # load any data we want available for all tests
      end

      def after_suites
        teardown_nested_transactions
        super
      end
    end
  end

  MiniTest::Unit.runner = MiniTestWithTransactions::Unit.new

== REQUIREMENTS:

* Ruby 1.8, maybe even 1.6 or lower. No magic is involved.

== INSTALL:

  sudo gem install minitest

On 1.9, you already have it. To get newer candy you can still install
the gem, but you'll need to activate the gem explicitly to use it:

  require 'rubygems'
  gem 'minitest' # ensures you're using the gem, and not the built in MT
  require 'minitest/autorun'
  
  # ... usual testing stuffs ...

== LICENSE:

(The MIT License)

Copyright (c) Ryan Davis, Seattle.rb

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# Coercible

[![Build Status](https://travis-ci.org/solnic/coercible.png?branch=master)](https://travis-ci.org/solnic/coercible)
[![Code Climate](https://codeclimate.com/github/solnic/coercible.png)](https://codeclimate.com/github/solnic/coercible)
[![Dependency Status](https://gemnasium.com/solnic/coercible.png)](https://gemnasium.com/solnic/coercible)

## Installation

Add this line to your application's Gemfile:

    gem 'coercible'

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install coercible

## Usage

Coercible gives you access to coercer objects where each object is responsible
for coercing only one type into other types. For example a string coercer knows
only how to coerce string objects, integer coercer knows only how to coerce integers
etc.

Here's the most basic example:

```ruby
coercer = Coercible::Coercer.new

# coerce a string to a date
coercer[String].to_date('2012/12/25') # => #<Date: 4912573/2,0,2299161>

# coerce a string to a boolean value
coercer[String].to_boolean('yes') # => true

# you got the idea :)
```

For more control you can configure your coercer like that:

``` ruby
# build coercer instance
coercer = Coercible::Coercer.new do |config|
  config.string.boolean_map = { 'yup' => true, 'nope' => false }
end

# coerce a string to boolean
coercer[String].to_boolean('yup') # => true
coercer[String].to_boolean('nope') # => false
```

Note that at the moment only Integer and String are configurable. More configurable
coercers will be added later whenever we find good usecases.

## Contributing

1. Fork it
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Add some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create new Pull Request

                          Apache Maven

  What is it?
  -----------

  Maven is a software project management and comprehension tool. Based on
  the concept of a Project Object Model (POM), Maven can manage a project's
  build, reporting and documentation from a central piece of information.

  Documentation
  -------------

  The most up-to-date documentation can be found at http://maven.apache.org/.

  Release Notes
  -------------

  The full list of changes can be found at http://maven.apache.org/release-notes.html.

  System Requirements
  -------------------

  JDK:
    1.5 or above (this is to execute Maven - it still allows you to build against 1.3
    and prior JDK's).
  Memory:
    No minimum requirement.
  Disk:
    No minimum requirement. Approximately 100MB will be used for your local repository,
    however this will vary depending on usage and can be removed and redownloaded at
    any time.
  Operating System:
    No minimum requirement. On Windows, Windows NT and above or Cygwin is required for
    the startup scripts. Tested on Windows XP, Fedora Core and Mac OS X.

  Installing Maven
  ----------------

  1) Unpack the archive where you would like to store the binaries, eg:

    Unix-based Operating Systems (Linux, Solaris and Mac OS X)
      tar zxvf apache-maven-3.x.y.tar.gz
    Windows 2000/XP
      unzip apache-maven-3.x.y.zip

  2) A directory called "apache-maven-3.x.y" will be created.

  3) Add the bin directory to your PATH, eg:

    Unix-based Operating Systems (Linux, Solaris and Mac OS X)
      export PATH=/usr/local/apache-maven-3.x.y/bin:$PATH
    Windows 2000/XP
      set PATH="c:\program files\apache-maven-3.x.y\bin";%PATH%

  4) Make sure JAVA_HOME is set to the location of your JDK

  5) Run "mvn --version" to verify that it is correctly installed.

  For complete documentation, see http://maven.apache.org/download.html#Installation

  Licensing
  ---------

  Please see the file called LICENSE.TXT

  Maven URLS
  ----------

  Home Page:          http://maven.apache.org/
  Downloads:          http://maven.apache.org/download.html
  Release Notes:      http://maven.apache.org/release-notes.html
  Mailing Lists:      http://maven.apache.org/mail-lists.html
  Source Code:        https://git-wip-us.apache.org/repos/asf/maven.git/apache-maven
  Issue Tracking:     http://jira.codehaus.org/browse/MNG
  Wiki:               https://cwiki.apache.org/confluence/display/MAVEN/
  Available Plugins:  http://maven.apache.org/plugins/index.html
Use this directory to contribute 3rd-party extensions to the Maven core. These extensions can either extend or override
Maven's default implementation.
# Threadsafe

[![Build Status](https://travis-ci.org/headius/thread_safe.png)](https://travis-ci.org/headius/thread_safe)

A collection of thread-safe versions of common core Ruby classes.

## Installation

Add this line to your application's Gemfile:

    gem 'thread_safe'

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install thread_safe

## Usage

```ruby
require 'thread_safe'

sa = ThreadSafe::Array.new # supports standard Array.new forms
sh = ThreadSafe::Hash.new # supports standard Hash.new forms
```

`ThreadSafe::Cache` also exists, as a hash-like object, and should have
much better performance characteristics esp. under high concurrency than
`ThreadSafe::Hash`. However, `ThreadSafe::Cache` is not strictly semantically
equivalent to a ruby `Hash` -- for instance, it does not necessarily retain
ordering by insertion time as `Hash` does. For most uses it should do fine
though, and we recommend you consider `ThreadSafe::Cache` instead of
`ThreadSafe::Hash` for your concurrency-safe hash needs. It understands some
options when created (depending on your ruby platform) that control some of the
internals - when unsure just leave them out:


```ruby
require 'thread_safe'

cache = ThreadSafe::Cache.new
```

## Contributing

1. Fork it
2. Clone it (`git clone git@github.com:you/thread_safe.git`)
3. Create your feature branch (`git checkout -b my-new-feature`)
4. Build the jar (`rake jar`) NOTE: Requires JRuby
5. Install dependencies (`bundle install`)
6. Commit your changes (`git commit -am 'Added some feature'`)
7. Push to the branch (`git push origin my-new-feature`)
8. Create new Pull Request
# axiom-types

Define types with optional constraints for use within axiom and other libraries.

[![Gem Version](https://badge.fury.io/rb/axiom-types.png)][gem]
[![Build Status](https://secure.travis-ci.org/dkubb/axiom-types.png?branch=master)][travis]
[![Dependency Status](https://gemnasium.com/dkubb/axiom-types.png)][gemnasium]
[![Code Climate](https://codeclimate.com/github/dkubb/axiom-types.png)][codeclimate]
[![Coverage Status](https://coveralls.io/repos/dkubb/axiom-types/badge.png?branch=master)][coveralls]

[gem]: https://rubygems.org/gems/axiom-types
[travis]: https://travis-ci.org/dkubb/axiom-types
[gemnasium]: https://gemnasium.com/dkubb/axiom-types
[codeclimate]: https://codeclimate.com/github/dkubb/axiom-types
[coveralls]: https://coveralls.io/r/dkubb/axiom-types

## Examples

```ruby
# Setup constraints for all defined types
Axiom::Types.finalize

# Create Name subtype
Name = Axiom::Types::String.new do
  minimum_length 1
  maximum_length 30
end

# Test if the string is a member of the type
Name.include?('a')       # => true
Name.include?('a' * 30)  # => true
Name.include?('')        # => false
Name.include?('a' * 31)  # => false
```

## Contributing

See [CONTRIBUTING.md](CONTRIBUTING.md) for details.

## Copyright

Copyright &copy; 2013 Dan Kubb. See LICENSE for details.
# descendants_tracker

[![Gem Version](https://badge.fury.io/rb/descendants_tracker.png)][gem]
[![Build Status](https://secure.travis-ci.org/dkubb/descendants_tracker.png?branch=master)][travis]
[![Dependency Status](https://gemnasium.com/dkubb/descendants_tracker.png)][gemnasium]
[![Code Climate](https://codeclimate.com/github/dkubb/descendants_tracker.png)][codeclimate]
[![Coverage Status](https://coveralls.io/repos/dkubb/descendants_tracker/badge.png?branch=master)][coveralls]

[gem]: https://rubygems.org/gems/descendants_tracker
[travis]: https://travis-ci.org/dkubb/descendants_tracker
[gemnasium]: https://gemnasium.com/dkubb/descendants_tracker
[codeclimate]: https://codeclimate.com/github/dkubb/descendants_tracker
[coveralls]: https://coveralls.io/r/dkubb/descendants_tracker

Small module to track descendants in an unobtrusive way.

## Examples

``` ruby
class Foo
  extend DescendantsTracker
end

class Bar < Foo
end

Foo.descendants # => [Bar]
```

## Credits

* Dan Kubb ([dkubb](https://github.com/dkubb))
* Piotr Solnica ([solnic](https://github.com/solnic))
* Markus Schirp ([mbj](https://github.com/mbj))

## Contributing

See [CONTRIBUTING.md](CONTRIBUTING.md) for details.

## Copyright

Copyright &copy; 2012-2013 Dan Kubb (author)
Copyright &copy; 2011-2012 Piotr Solnica (source maintainer)
Copyright &copy; 2012 Markus Schirp (packaging)

See LICENSE for details.
equalizer
=========

Module to define equality, equivalence and inspection methods

[![Gem Version](https://badge.fury.io/rb/equalizer.png)][gem]
[![Build Status](https://secure.travis-ci.org/dkubb/equalizer.png?branch=master)][travis]
[![Dependency Status](https://gemnasium.com/dkubb/equalizer.png)][gemnasium]
[![Code Climate](https://codeclimate.com/github/dkubb/equalizer.png)][codeclimate]
[![Coverage Status](https://coveralls.io/repos/dkubb/equalizer/badge.png?branch=master)][coveralls]

[gem]: https://rubygems.org/gems/equalizer
[travis]: https://travis-ci.org/dkubb/equalizer
[gemnasium]: https://gemnasium.com/dkubb/equalizer
[codeclimate]: https://codeclimate.com/github/dkubb/equalizer
[coveralls]: https://coveralls.io/r/dkubb/equalizer

Examples
--------

``` ruby
class GeoLocation
  include Equalizer.new(:latitude, :longitude)

  attr_reader :latitude, :longitude

  def initialize(latitude, longitude)
    @latitude, @longitude = latitude, longitude
  end
end

point_a = GeoLocation.new(1, 2)
point_b = GeoLocation.new(1, 2)
point_c = GeoLocation.new(2, 2)

point_a.inspect    # => "#<GeoLocation latitude=1 longitude=2>"

point_a == point_b           # => true
point_a.hash == point_b.hash # => true
point_a.eql?(point_b)        # => true
point_a.equal?(point_b)      # => false

point_a == point_c           # => false
point_a.hash == point_c.hash # => false
point_a.eql?(point_c)        # => false
point_a.equal?(point_c)      # => false
```

Supported Ruby Versions
-----------------------

This library aims to support and is [tested against][travis] the following Ruby
implementations:

* Ruby 1.8.7
* Ruby 1.9.2
* Ruby 1.9.3
* Ruby 2.0.0
* [JRuby][]
* [Rubinius][]
* [Ruby Enterprise Edition][ree]

[jruby]: http://jruby.org/
[rubinius]: http://rubini.us/
[ree]: http://www.rubyenterpriseedition.com/

If something doesn't work on one of these versions, it's a bug.

This library may inadvertently work (or seem to work) on other Ruby versions or
implementations, however support will only be provided for the implementations
listed above.

If you would like this library to support another Ruby version or
implementation, you may volunteer to be a maintainer. Being a maintainer
entails making sure all tests run and pass on that implementation. When
something breaks on your implementation, you will be responsible for providing
patches in a timely fashion. If critical issues for a particular implementation
exist at the time of a major release, support for that Ruby version may be
dropped.

Credits
-------

* Dan Kubb ([dkubb](https://github.com/dkubb))
* Piotr Solnica ([solnic](https://github.com/solnic))
* Markus Schirp ([mbj](https://github.com/mbj))
* Erik Michaels-Ober ([sferik](https://github.com/sferik))

Contributing
-------------

See [CONTRIBUTING.md](CONTRIBUTING.md) for details.

Copyright
---------

Copyright &copy; 2009-2013 Dan Kubb. See LICENSE for details.
ice_nine
========

Deep freeze ruby objects

[![Gem Version](https://badge.fury.io/rb/ice_nine.svg)][gem]
[![Build Status](https://secure.travis-ci.org/dkubb/ice_nine.svg?branch=master)][travis]
[![Dependency Status](https://gemnasium.com/dkubb/ice_nine.svg)][gemnasium]
[![Code Climate](https://codeclimate.com/github/dkubb/ice_nine.png)][codeclimate]
[![Coverage Status](https://coveralls.io/repos/dkubb/ice_nine/badge.png?branch=master)][coveralls]
[![Inline docs](http://inch-ci.org/github/dkubb/ice_nine.svg?branch=master)][inch]

[gem]: https://rubygems.org/gems/ice_nine
[travis]: https://travis-ci.org/dkubb/ice_nine
[gemnasium]: https://gemnasium.com/dkubb/ice_nine
[codeclimate]: https://codeclimate.com/github/dkubb/ice_nine
[coveralls]: https://coveralls.io/r/dkubb/ice_nine
[inch]: http://inch-ci.org/github/dkubb/ice_nine

Examples
--------

```ruby
require 'ice_nine'

# Deep freezes most kinds of objects
hash   = IceNine.deep_freeze('a' => '1')
array  = IceNine.deep_freeze([ 'a', 'b', 'c' ])
range  = IceNine.deep_freeze('a'..'z')
struct = IceNine.deep_freeze(Struct.new(:a, :b).new('a', 'b'))
object = IceNine.deep_freeze(Object.new)
user   = IceNine.deep_freeze(User.new(name: 'dkubb'))

# Faster deep freeze that skips deep-freezing frozen objects
object = IceNine.deep_freeze!(Object.new)

# Add core extension for Object#deep_freeze (not required by default)
require 'ice_nine'
require 'ice_nine/core_ext/object'

object = Object.new
object.deep_freeze
```

Contributing
------------

See [CONTRIBUTING.md](CONTRIBUTING.md) for details.

Copyright
---------

Copyright &copy; 2012-2014 Dan Kubb. See LICENSE for details.
maven tools 
===========

* [![Build Status](https://secure.travis-ci.org/torquebox/maven-tools.png)](http://travis-ci.org/torquebox/maven-tools)
* [![Code Climate](https://codeclimate.com/badge.png)](https://codeclimate.com/github/torquebox/maven-tools)

Note on Ruby-1.8
----------------

ordering is important within the pom.xml since it carry info on the sequence of execution. jruby and ruby-1.9 do iterate in same order as the keys gets included, that helps to copy the order of declaration from the ruby DSL over to pom.xml. with ruby-1.8 the hash behaviour is different and since ruby-1.8 is end of life there is no support for ruby-1.8. though it might just works fine on simple setup.

Contributing
------------

1. Fork it
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Added some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create new Pull Request

meta-fu
-------

enjoy :) 

[gem]: https://rubygems.org/gems/virtus
[travis]: https://travis-ci.org/solnic/virtus
[gemnasium]: https://gemnasium.com/solnic/virtus
[codeclimate]: https://codeclimate.com/github/solnic/virtus
[coveralls]: https://coveralls.io/r/solnic/virtus
[inchpages]: http://inch-ci.org/github/solnic/virtus/

Virtus
======

# Ruby Object Mapper

[![Gem Version](https://badge.fury.io/rb/rom.svg)][gem]
[![Build Status](https://travis-ci.org/solnic/virtus.svg?branch=master)][travis]
[![Dependency Status](https://gemnasium.com/solnic/virtus.png)][gemnasium]
[![Code Climate](https://codeclimate.com/github/solnic/virtus/badges/gpa.svg)][codeclimate]
[![Test Coverage](https://codeclimate.com/github/solnic/virtus/badges/coverage.svg)][codeclimate]
[![Inline docs](http://inch-ci.org/github/solnic/virtus.svg?branch=master)][inchpages]

Virtus allows you to define attributes on classes, modules or class instances with
optional information about types, reader/writer method visibility and coercion
behavior. It supports a lot of coercions and advanced mapping of embedded objects
and collections.

You can use it in many different contexts like:

* Input parameter sanitization and coercion in web applications
* Mapping JSON to domain objects
* Encapsulating data-access in Value Objects
* Domain model prototyping

And probably more.

Installation
------------

``` terminal
$ gem install virtus
```

or in your **Gemfile**

``` ruby
gem 'virtus'
```

Examples
--------

### Using Virtus with Classes

You can create classes extended with Virtus and define attributes:

``` ruby
class User
  include Virtus.model

  attribute :name, String
  attribute :age, Integer
  attribute :birthday, DateTime
end

user = User.new(:name => 'Piotr', :age => 29)
user.attributes # => { :name => "Piotr", :age => 29 }

user.name # => "Piotr"

user.age = '29' # => 29
user.age.class # => Fixnum

user.birthday = 'November 18th, 1983' # => #<DateTime: 1983-11-18T00:00:00+00:00 (4891313/2,0/1,2299161)>

# mass-assignment
user.attributes = { :name => 'Jane', :age => 21 }
user.name # => "Jane"
user.age  # => 21
```

### Cherry-picking extensions

``` ruby
# include attribute DSL + constructor + mass-assignment
class User
  include Virtus.model

  attribute :name, String
end

user = User.new(:name => 'Piotr')
user.attributes = { :name => 'John' }
user.attributes
# => {:name => 'John'}

# include attribute DSL + constructor
class User
  include Virtus.model(:mass_assignment => false)

  attribute :name, String
end

User.new(:name => 'Piotr')

# include just the attribute DSL
class User
  include Virtus.model(:constructor => false, :mass_assignment => false)

  attribute :name, String
end

user = User.new
user.name = 'Piotr'
```

### Using Virtus with Modules

You can create modules extended with Virtus and define attributes for later
inclusion in your classes:

```ruby
module Name
  include Virtus.module

  attribute :name, String
end

module Age
  include Virtus.module(:coerce => false)

  attribute :age, Integer
end

class User
  include Name, Age
end

user = User.new(:name => 'John', :age => 30)
```

### Dynamically Extending Instances

It's also possible to dynamically extend an object with Virtus:

```ruby
class User
  # nothing here
end

user = User.new
user.extend(Virtus.model)
user.attribute :name, String
user.name = 'John'
user.name # => 'John'
```

### Default Values

``` ruby
class Page
  include Virtus.model

  attribute :title, String

  # default from a singleton value (integer in this case)
  attribute :views, Integer, :default => 0

  # default from a singleton value (boolean in this case)
  attribute :published, Boolean, :default => false

  # default from a callable object (proc in this case)
  attribute :slug, String, :default => lambda { |page, attribute| page.title.downcase.gsub(' ', '-') }

  # default from a method name as symbol
  attribute :editor_title, String,  :default => :default_editor_title

  def default_editor_title
    published? ? title : "UNPUBLISHED: #{title}"
  end
end

page = Page.new(:title => 'Virtus README')
page.slug         # => 'virtus-readme'
page.views        # => 0
page.published    # => false
page.editor_title # => "UNPUBLISHED: Virtus README"

page.views = 10
page.views                    # => 10
page.reset_attribute(:views)  # => 0
page.views                    # => 0
```

### Default values on dynamically extended instances

This requires you to set `:lazy` option because default values are set in the
constructor if it's set to false (which is the default setting):

``` ruby
User = Class.new
user = User.new
user.extend(Virtus.model)
user.attribute :name, String, default: 'jane', lazy: true
user.name # => "jane"
```

### Embedded Value

``` ruby
class City
  include Virtus.model

  attribute :name, String
end

class Address
  include Virtus.model

  attribute :street,  String
  attribute :zipcode, String
  attribute :city,    City
end

class User
  include Virtus.model

  attribute :name,    String
  attribute :address, Address
end

user = User.new(:address => {
  :street => 'Street 1/2', :zipcode => '12345', :city => { :name => 'NYC' } })

user.address.street # => "Street 1/2"
user.address.city.name # => "NYC"
```

### Collection Member Coercions

``` ruby
# Support "primitive" classes
class Book
  include Virtus.model

  attribute :page_numbers, Array[Integer]
end

book = Book.new(:page_numbers => %w[1 2 3])
book.page_numbers # => [1, 2, 3]

# Support EmbeddedValues, too!
class Address
  include Virtus.model

  attribute :address,     String
  attribute :locality,    String
  attribute :region,      String
  attribute :postal_code, String
end

class PhoneNumber
  include Virtus.model

  attribute :number, String
end

class User
  include Virtus.model

  attribute :phone_numbers, Array[PhoneNumber]
  attribute :addresses,     Set[Address]
end

user = User.new(
  :phone_numbers => [
    { :number => '212-555-1212' },
    { :number => '919-444-3265' } ],
  :addresses => [
    { :address => '1234 Any St.', :locality => 'Anytown', :region => "DC", :postal_code => "21234" } ])

user.phone_numbers # => [#<PhoneNumber:0x007fdb2d3bef88 @number="212-555-1212">, #<PhoneNumber:0x007fdb2d3beb00 @number="919-444-3265">]

user.addresses # => #<Set: {#<Address:0x007fdb2d3be448 @address="1234 Any St.", @locality="Anytown", @region="DC", @postal_code="21234">}>
```

### Hash attributes coercion

``` ruby
class Package
  include Virtus.model

  attribute :dimensions, Hash[Symbol => Float]
end

package = Package.new(:dimensions => { 'width' => "2.2", :height => 2, "length" => 4.5 })
package.dimensions # => { :width => 2.2, :height => 2.0, :length => 4.5 }
```

### IMPORTANT note about Boolean type

Be aware that some libraries may do a terrible thing and define a global Boolean
constant which breaks virtus' constant type lookup, if you see issues with the
boolean type you can workaround it like that:

``` ruby
class User
  include Virtus.model

  attribute :admin, Axiom::Types::Boolean
end
```

This will be improved in Virtus 2.0.

### IMPORTANT note about member coercions

Virtus performs coercions only when a value is being assigned. If you mutate the value later on using its own
interfaces then coercion won't be triggered.

Here's an example:

``` ruby
class Book
  include Virtus.model

  attribute :title, String
end

class Library
  include Virtus.model

  attribute :books, Array[Book]
end

library = Library.new

# This will coerce Hash to a Book instance
library.books = [ { :title => 'Introduction to Virtus' } ]

# This WILL NOT COERCE the value because you mutate the books array with Array#<<
library.books << { :title => 'Another Introduction to Virtus' }
```

A suggested solution to this problem would be to introduce your own class instead of using Array and implement
mutation methods that perform coercions. For example:

``` ruby
class Book
  include Virtus.model

  attribute :title, String
end

class BookCollection < Array
  def <<(book)
   if book.kind_of?(Hash)
    super(Book.new(book))
   else
     super
   end
  end
end

class Library
  include Virtus.model

  attribute :books, BookCollection[Book]
end

library = Library.new
library.books << { :title => 'Another Introduction to Virtus' }
```

### Value Objects

``` ruby
class GeoLocation
  include Virtus.value_object

  values do
    attribute :latitude,  Float
    attribute :longitude, Float
  end
end

class Venue
  include Virtus.value_object

  values do
    attribute :name,     String
    attribute :location, GeoLocation
  end
end

venue = Venue.new(
  :name     => 'Pub',
  :location => { :latitude => 37.160317, :longitude => -98.437500 })

venue.location.latitude # => 37.160317
venue.location.longitude # => -98.4375

# Supports object's equality

venue_other = Venue.new(
  :name     => 'Other Pub',
  :location => { :latitude => 37.160317, :longitude => -98.437500 })

venue.location === venue_other.location # => true
```

### Custom Coercions

``` ruby
require 'json'

class Json < Virtus::Attribute
  def coerce(value)
    value.is_a?(::Hash) ? value : JSON.parse(value)
  end
end

class User
  include Virtus.model

  attribute :info, Json, default: {}
end

user = User.new
user.info = '{"email":"john@domain.com"}' # => {"email"=>"john@domain.com"}
user.info.class # => Hash

# With a custom attribute encapsulating coercion-specific configuration
class NoisyString < Virtus::Attribute
  def coerce(value)
    value.to_s.upcase
  end
end

class User
  include Virtus.model

  attribute :scream, NoisyString
end

user = User.new(:scream => 'hello world!')
user.scream # => "HELLO WORLD!"
```

### Private Attributes

``` ruby
class User
  include Virtus.model

  attribute :unique_id, String, :writer => :private

  def set_unique_id(id)
    self.unique_id = id
  end
end

user = User.new(:unique_id => '1234-1234')
user.unique_id # => nil

user.unique_id = '1234-1234' # => NoMethodError: private method `unique_id='

user.set_unique_id('1234-1234')
user.unique_id # => '1234-1234'
```

### Overriding setters

``` ruby
class User
  include Virtus.model

  attribute :name, String

  def name=(new_name)
    custom_name = nil
    if new_name == "Godzilla"
      custom_name = "Can't tell"
    end
    super custom_name || new_name
  end
end

user = User.new(name: "Frank")
user.name # => 'Frank'

user = User.new(name: "Godzilla")
user.name # => 'Can't tell'

```

## Strict Coercion Mode

By default Virtus returns the input value even when it couldn't coerce it to the expected type.
If you want to catch such cases in a noisy way you can use the strict mode in which
Virtus raises an exception when it failed to coerce an input value.

``` ruby
class User
  include Virtus.model(:strict => true)

  attribute :admin, Boolean
end

# this will raise an error
User.new :admin => "can't really say if true or false"
```

## Building modules with custom configuration

You can also build Virtus modules that contain their own configuration.

```ruby
YupNopeBooleans = Virtus.model { |mod|
  mod.coerce = true
  mod.coercer.config.string.boolean_map = { 'nope' => false, 'yup' => true }
}

class User
  include YupNopeBooleans

  attribute :name, String
  attribute :admin, Boolean
end

# Or just include the module straight away ...
class User
  include Virtus.model(:coerce => false)

  attribute :name, String
  attribute :admin, Boolean
end
```

## Attribute Finalization and Circular Dependencies

If a type references another type which happens to not be available yet you need
to use lazy-finalization of attributes and finalize virtus manually after all
types have been already loaded:

``` ruby
# in blog.rb
class Blog
  include Virtus.model(:finalize => false)

  attribute :posts, Array['Post']
end

# in post.rb
class Post
  include Virtus.model(:finalize => false)

  attribute :blog, 'Blog'
end

# after loading both files just do:
Virtus.finalize

# constants will be resolved:
Blog.attribute_set[:posts].member_type.primitive # => Post
Post.attribute_set[:blog].type.primitive # => Blog
```

Ruby version support
--------------------

Virtus is known to work correctly with the following rubies:

* 1.9.3
* 2.0.0
* 2.1.2
* jruby
* (probably) rbx

Credits
-------

* Dan Kubb ([dkubb](https://github.com/dkubb))
* Chris Corbyn ([d11wtq](https://github.com/d11wtq))
* Emmanuel Gomez ([emmanuel](https://github.com/emmanuel))
* Fabio Rehm ([fgrehm](https://github.com/fgrehm))
* Ryan Closner ([rclosner](https://github.com/rclosner))
* Markus Schirp ([mbj](https://github.com/mbj))
* Yves Senn ([senny](https://github.com/senny))

Contributing
-------------

* Fork the project.
* Make your feature addition or bug fix.
* Add tests for it. This is important so I don't break it in a
  future version unintentionally.
* Commit, do not mess with Rakefile or version
  (if you want to have your own version, that is fine but bump version in a commit by itself I can ignore when I pull)
* Send me a pull request. Bonus points for topic branches.
Running Emma
============
To run the emma coverage report:
ant clean emma test

A coverage report will be created  (build/test-results/html-coverage/coverage.html)

To run the unit tests and without emma instrumentation or the emma coverage report just ommit 
the "emma" target from the line above:
ant clean test# Writing Tests

1. There are actually *4* core test suites:

   a) `org.jruby.test.MainTestSuite`, a suite of pure-java tests;

   b) `org.jruby.test.TestUnitTestSuite`, which runs a suite of files named
   one-per-line in `test/jruby_index` (and other `test/*_index` files).
   Note: some are commented out.

   c) `Rubyspecs`, a recent point-in-time copy of [RubySpec](http://rubyspec.org)
   project. The specs
   are written in `rspec `format and aim to test conformance of JRuby
   against the Ruby specification.

   d) MRI's own tests, synced periodically. The tests are run with
   `rake test:mri19` and known failing tests are marked as such in 
   excludes files under `test/externals/ruby1.9/excludes`.

2. If you'd like to contribute new tests, we'd prefer you write them via the
`rubyspecs` project.  If the tests are very specific to JRuby (like Java
Integration) we prefer writing `rspec`s under our `specs` directory.

3. We're also interested in running tests for other ruby software suites; if
you want to grab your favorite ruby software and run its own tests under JRuby
and report to the mailing list at `dev@jruby.codehaus.org`, that would be great.

4. Please file any and all patches in [Github issues](https://github.com/jruby/jruby/issues)

# Running Tests

Using ant, type

    ant test

The three test suites should be run in order.

To run rubyspecs, type

    ant spec

A slightly shorter run we run frequently is:

    ant spec-short

The rubyspecs will be fetched over the net, and then executed.

To run an individual test:

1. run `ant install-dev-gems` which will install `bin/rspec` for use.
2. run `ant compile-test` to compile the java fixtures (you don't need to wait for the tests to finish) then test as normal with `bin/rspec spec/path-to-spec`
## JRuby implementation of Ruby C extensions API.

This document explains the state of C extensions on JRuby. This is
meant to become an exhaustive listing of the restrictions in the C API
layer, their reasons, and how to work around them.

We also provide code examples for some workarounds at the end of this
document.

If more restrictions are found, or you have code examples, please feel
free to add them.

### Objectives

Provide a highly compatible implementation of C extensions on
JRuby. The goal here is not performance, but compatibility. We do not
recommend running Ruby C extensions in production, at least not for a
longer period of time, and we probably never will. The idea here is
that if you're transitioning to JRuby, you can run your C extensions
until you find something more suitable. The focus is also very clearly
on Gems that have no JRuby specific version available. The C API is
implemented as a JNI plugin to the JVM.

### Restrictions

#### Runtime

JRuby supports multiple "Runtimes" in a single process. Because you
can only load a dynamic/shared library into the JVM once, and we
cannot be sure whether a C extension is thread-safe, so we disallow
loading C extensions in more than one runtime. To work around this,
you may disable JRuby's in-process execution (default from 1.6.5
onwards).

#### Strings

* **RSTRING_PTR(VALUE)**

    *Problem:* In order to support direct manipulation of C array
     backed strings, whenever you call this macro, the object
     referenced by VALUE is added to a synchronization list, and
     whenever you transition between C and Java land, the contents of
     the Java and C string are copied back and forth, adding a
     potentially significant overhead.  The lifetime of the C memory
     referenced by the result of RSTRING_PTR is the same as the
     garbage collection lifetime of the corresponding String object,
     so it will only go off the synchronization list if the associated
     object is collected.

    *Workaround:* To change bytes in a String object, use one of

	void rb_str_update(VALUE str, long beg, long len, VALUE val);
	VALUE rb_str_buf_append(VALUE str, VALUE val);
	VALUE rb_str_buf_cat(VALUE str, const char* bytes, long len);
	VALUE rb_str_buf_cat2(VALUE str, const char* cstring);
	VALUE rb_str_append(VALUE str, VALUE arg);

#### Arrays

* **RARRAY_PTR**

    *Problem:* The same runtime overhead implications as for RSTRING_PTR apply.

    *Workaround:* To access elements of an Array, use rb_ary_entry or
    rb_ary_store which are also available in MagLev and Rubinius.

#### IO

* **rb_io_wait_readable, rb_io_wait_writable, rb_io_check_readable, rb_io_check_writable, rb_io_check_closed, GetOpenFile**
    
    *Problem:* Mixing native file descriptors with JVM fds doesn't
     work very well. Sometimes, things will work just fine, but more
     often than not, these functions will simply fail.

    *Workaround:* Upcall to Ruby for dealing with IO and files.

#### Hash

* **rb_iterate_each_pair**, **rb_iterate**, **rb_each**

    *Problem:* Only supports iteration on Array arguments for now

    *Workaround:* You can coerce you're Hash into an array of pairs
     before iterating.

* **RHASH**, **RHASH_TBL**

    *Problem:* Like on MagLev and Rubinius, these macros aren't supported.

#### Threads

* **thread_critical**

    *Problem:* Not supported, setting this to `true` is ignored

#### Globals and GC

* **Object lifetime**

    *Problem:* C-references aren't kept alive/valid after returning
    from C extension code.

    Each call from Ruby into a C extension initializes a list known to
    the garbage collector that is kept alive for the duration of that
    entry into a C extension. This list is dereferenced when returning
    from C back to Ruby.

    *Workaround:* For a newly created object to stay alive after
    returning from C to Ruby it must have been stored as the value of
    a Ruby global variable, Ruby constant, or stored into an instance
    variable of some other object reachable from top level Ruby state,
    or be reachable from the VALUE returned from C back to Ruby.

#### Numerics

* **rb_num2ulong**
  
  *Problem:* Java longs are of a different size than whatever the
   native long size may be on the machine. This can be observed in the
   spec failure "rb_num2ulong converts -1 to an unsigned number" in
   the Ruby specs.

  *Workaround:* None.

### Bugs and status of rubyspecs (as of 30 Sep 2011)

For the rubyspecs in optional/capi/ , the following specs are skipped
and are not supported

 * rb_define_hooked_variable
 * rb_define_variable
 * rb_protect_inspect
 * rb_inspecting_p
 * rb_exec_recursive

The following functions have known bugs that we will try to fix

 * rb_class_new fails to throw an error when passed a singleton class as superclass
 * rb_rescue has some spec failures
 * rb_thread_select fails to detect an fd that's ready to read
 * rb_str_buf_* sometimes fails to synchronize the C buffer correctly

= RbYAML - A pure Ruby YAML 1.1 loader and dumper

Project Contact: Ola Bini <ola@ologix.com>

The code is based mostly on the Python code written by Kirill Simonov <xi@resolvent.net> for PyYAML3000.

RbYAML is a project originating in the JRuby project (http://jruby.sourceforge.net), to create a pure Ruby
YAML parser for use in JRuby and SYCK cannot be used in this case. 
Since the effort of writing a new one from scratch seemed like a major undertaking it seemed easier to
port an existing one. 

The current functionality is more or less 1.1-compliant. What's missing is the Unicode-support. The idea
is to have the interface resemble SYCK as much as possible, but this is still work in progress, since some
of the major architectural choices are quite different.

== Use

Just require 'rbyaml' and use it as you would use YAML, but in module RbYAML instead:
   
        require 'rbyaml'
        
        RbYAML.load("--- \n- A\n- b\n- c\n")       ---->   ["A","b","c"]
        "foo".to_yaml                              ---->   "foo\n"

== More information

Visit http://rbyaml.rubyforge.org for more information and updated versions

== License

RbYAML is distributed with a MIT license, which can be found in the file LICENSE.
To compile the nailgun client, type './configure' and 'make' in this directory.

Windows binary is distributed with JRuby.

Documentation is under development.  For up-to-date information,
including a "Quick Start" guide, visit:

	http://www.martiansoftware.com/nailgun
	
Javadocs for NailGun are in the "docs/api" directory with the
source distribution, and are also available at the above website.
# Logstash Plugin

This is a plugin for [Logstash](https://github.com/elasticsearch/logstash).

It is fully free and fully open source. The license is Apache 2.0, meaning you are pretty much free to use it however you want in whatever way.

## Documentation

Logstash provides infrastructure to automatically generate documentation for this plugin. We use the asciidoc format to write documentation so any comments in the source code will be first converted into asciidoc and then into html. All plugin documentation are placed under one [central location](http://www.elasticsearch.org/guide/en/logstash/current/).

- For formatting code or config example, you can use the asciidoc `[source,ruby]` directive
- For more asciidoc formatting tips, see the excellent reference here https://github.com/elasticsearch/docs#asciidoc-guide

## Need Help?

Need help? Try #logstash on freenode IRC or the logstash-users@googlegroups.com mailing list.

## Developing

### 1. Plugin Developement and Testing

#### Code
- To get started, you'll need JRuby with the Bundler gem installed.

- Create a new plugin or clone and existing from the GitHub [logstash-plugins](https://github.com/logstash-plugins) organization. We also provide [example plugins](https://github.com/logstash-plugins?query=example).

- Install dependencies
```sh
bundle install
```

#### Test

- Update your dependencies

```sh
bundle install
```

- Run tests

```sh
bundle exec rspec
```

### 2. Running your unpublished Plugin in Logstash

#### 2.1 Run in a local Logstash clone

- Edit Logstash `Gemfile` and add the local plugin path, for example:
```ruby
gem "logstash-filter-awesome", :path => "/your/local/logstash-filter-awesome"
```
- Install plugin
```sh
bin/plugin install --no-verify
```
- Run Logstash with your plugin
```sh
bin/logstash -e 'filter {awesome {}}'
```
At this point any modifications to the plugin code will be applied to this local Logstash setup. After modifying the plugin, simply rerun Logstash.

#### 2.2 Run in an installed Logstash

You can use the same **2.1** method to run your plugin in an installed Logstash by editing its `Gemfile` and pointing the `:path` to your local plugin development directory or you can build the gem and install it using:

- Build your plugin gem
```sh
gem build logstash-filter-awesome.gemspec
```
- Install the plugin from the Logstash home
```sh
bin/plugin install /your/local/plugin/logstash-filter-awesome.gem
```
- Start Logstash and proceed to test the plugin

## Contributing

All contributions are welcome: ideas, patches, documentation, bug reports, complaints, and even something you drew up on a napkin.

Programming is not a required skill. Whatever you've seen about open source and maintainers or community members  saying "send patches or die" - you will not see that here.

It is more important to the community that you are able to contribute.

For more information about contributing, see the [CONTRIBUTING](https://github.com/elasticsearch/logstash/blob/master/CONTRIBUTING.md) file.# How to run these tests

Run one:

  `rspec spec/the/test.rb`

Run them all:

  `rspec spec/**/*.rb`

Debug one test:

  `LOGSTASH_DEBUG=y rspec spec/the/test.rb`

