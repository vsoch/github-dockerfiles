## mirage-net -- Network signatures for MirageOS

mirage-net defines [Mirage_net.S][1] the signature for
network operations for MirageOS.

[1]: https://mirage.github.io/mirage-net/Mirage_net.S.html

### Installation

`mirage-net` can be installed with `opam`:

    opam install mirage-net

If you don't use `opam` consult the [`opam`](opam) file for build
instructions.

### Documentation

The documentation and API reference is automatically generated by
`ocamldoc` from the interfaces. It can be consulted [online][2].

[2]: https://mirage.github.io/mirage-net/Mirage_net.html
## MirageOS

MirageOS is a library operating system that constructs unikernels for secure,
high-performance network applications across a variety of cloud computing and
mobile platforms. Code can be developed on a traditional OS such as Linux or
MacOS X, and then compiled into a fully-standalone, specialised unikernel that
runs under the Xen or KVM hypervisors as well as lightweight hypervisors like
FreeBSD's BHyve, OpenBSD's VMM.  Xen and KVM power many public clouds;
MirageOS unikernels are currently running on Amazon's Elastic Compute Cloud
and Google Compute Engine, and maybe others!

The most up-to-date documentation can be found at the
[homepage](https://mirage.io). The site is [a Xen hosted unikernel](https://github.com/mirage/mirage-www).
Simpler [skeleton applications](https://github.com/mirage/mirage-skeleton) are also
available online.

[![Build Status](https://travis-ci.org/mirage/mirage.svg)](https://travis-ci.org/mirage/mirage)
[![docs](https://img.shields.io/badge/doc-online-blue.svg)](https://mirage.github.io/mirage/)

### This repository

This repository includes:

* a command-line tool to create and deploy applications with MirageOS; and
* in `types/`, a library of type signatures that compliant applications use.

There are several diverse backends in MirageOS that require rather specialised
build steps (from Xen to KVM unikernels), and this complexity is wrapped
up in the tool.

To work with `mirage`, you'll need to either install prerequisites
locally or use the Docker image.

**Local install**

You will need the following:

* a working [OCaml](https://ocaml.org) compiler (4.04.2 or higher).
* the [OPAM](https://opam.ocaml.org) source package manager (2.0.0 or higher).
* an x86\_64 or armel Linux host to compile Xen kernels, or FreeBSD, OpenBSD or
  MacOS X for the solo5 and userlevel versions.

**Docker image**

There is a maintained Docker image at
[unikernel/mirage](https://hub.docker.com/r/unikernel/mirage/).
You can also use the Dockerfile in this repository:

```
docker build -t mirage .
docker run -v <your-source>:/src opam config exec -- mirage
```

### Using `mirage`

There are two stages to using `mirage`:

* a *configure* phase where necessary code is generated and dependencies are determined.
* an optional *depends* phase where OPAM package dependencies are satisfied.
* a *build* phase where the compiler and any support scripts are run.

You can find documentation, walkthroughs and tutorials over on the
[MirageOS website](https://mirage.io).
The [install instructions](https://mirage.io/wiki/install)
are a good place to begin!
Block implementations for mirage
================================

This repo contains generic operations over Mirage `BLOCK` devices.

Please consult [the API documentation](https://mirage.github.io/mirage-block/index.html).

Example usage
-------------

In a top-level like utop:
```ocaml
# #require "io-page.unix";;
# #require "mirage-block";;
# #require "mirage-block-ramdisk";;
# #require "lwt.syntax";;

# lwt t_or_error = Ramdisk.create ~name:"hello" ~size_sectors:1024L ~sector_size:512;;
val t_or_error : [ `Error of Ramdisk.error | `Ok of Ramdisk.t ] = `Ok <abstr>

# let t = Mirage_block.Error.ok_exn t_or_error;;
val t : Ramdisk.t = <abstr>

# let page = Io_page.(to_cstruct (get 1));;
val page : Ramdisk.page_aligned_buffer =
  {Cstruct.buffer = <abstr>; off = 0; len = 4096}

# lwt result_or_error = Ramdisk.read t 0L [ page ];;
val result_or_error : [ `Error of Ramdisk.error | `Ok of unit ] = `Ok ()

# lwt ok_or_error = Mirage_block.sparse_copy (module Ramdisk) t (module Ramdisk) t;;
val ok_or_error :
  [ `Error of [> `Different_sizes | `Is_read_only | `Msg of bytes ]
  | `Ok of unit ] = `Ok ()
```
## mirage-device -- Abstract devices for MirageOS

mirage-device defines [Mirage_device.S][1], the signature for
basic abstract devices for MirageOS and a pretty-printing function
for device errors.

[1]: https://mirage.github.io/mirage-device/Mirage_device.S.html

### Installation

`mirage-device` can be installed with `opam`:

    opam install mirage-device

If you don't use `opam` consult the [`opam`](opam) file for build
instructions.

### Documentation

The documentation and API reference is automatically generated by
`ocamldoc` from the interfaces. It can be consulted [online][2].

[2]: https://mirage.github.io/mirage-device/Mirage_device.html
## mirage-kv — MirageOS signatures for key/value devices

mirage-kv provides the [Mirage_kv.RO][ro] and [Mirage_kv_lwt.RO][ro-lwt]
signatures the MirageOS key/value devices should implement.

mirage-kv is distributed under the ISC license.

[ro]: https://mirage.github.io/mirage-kv/Mirage_kv.html
[ro-lwt]: https://mirage.github.io/mirage-kv/Mirage_kv_lwt.html

## Installation

mirage-kv can be installed with `opam`:

    opam install mirage-kv

If you don't use `opam` consult the [`opam`](opam) file for build
instructions.

## Documentation

The documentation and API reference is generated from the source
interfaces. It can be consulted [online][doc] or via `odig doc
mirage-kv`.

[doc]: https://mirage.github.io/mirage-kv/
## mirage-profile -- collect runtime profiling information in CTF format

This library can be used to trace execution of OCaml/Lwt programs (such as Mirage unikernels) at the level of Lwt threads.
The traces can be viewed using JavaScript or GTK viewers provided by [mirage-trace-viewer][] or processed by tools supporting the [Common Trace Format (CTF)][ctf].
Some example traces can be found in the blog post [Visualising an Asynchronous Monad](http://roscidus.com/blog/blog/2014/10/27/visualising-an-asynchronous-monad/).

Libraries can use the functions mirage-profile provides to annotate the traces with extra information.
When compiled against a normal version of Lwt, mirage-profile's functions are null-ops (or call the underlying untraced operation, as appropriate) and OCaml's cross-module inlining will optimise these calls away, meaning there should be no overhead in the non-profiling case.


## Use with Mirage

See http://openmirage.org/wiki/profiling for instructions.

## Recording traces manually

To record traces you need to pin a version of Lwt with tracing support (this provides the `lwt.tracing` findlib module):

    $ opam pin add lwt 'https://github.com/mirage/lwt.git#tracing'

This will cause mirage-profile and any programs using it to be recompiled with tracing enabled.

To trace a **Unix process**, use `MProf_unix.mmap_buffer` to write to an mmapped file:

    let () =
      let buffer = MProf_unix.mmap_buffer ~size:1000000 "trace.ctf" in
      let trace_config = MProf.Trace.Control.make buffer MProf_unix.timestamper in
      MProf.Trace.Control.start trace_config

You'll also need to link with the `mirage-profile` and `mirage-profile-unix` libraries.

To begin tracing a **Xen unikernel**, create a buffer and call `MProf.Trace.Control.start`:

    let trace_pages = MProf_xen.make_shared_buffer ~size:1000000
    let () = 
      let buffer = trace_pages |> Io_page.to_cstruct |> Cstruct.to_bigarray in
      let trace_config = MProf.Trace.Control.make buffer MProf_xen.timestamper in
      MProf.Trace.Control.start trace_config

To share the buffer with dom0, do this somewhere in your initialisation code:

    MProf_xen.share_with (module Gnt.Gntshr) (module OS.Xs) ~domid:0 trace_pages

You'll also need to link with the `mirage-profile` and `mirage-profile-xen` libraries.

## Viewing traces

To view the trace you should, ideally, call `MProf.Trace.Control.stop` before reading the buffer to avoid race conditions, but in practice reading the trace at any time usually works.

If your program crashes, you can still read the trace buffer.
On Xen, you can ensure that the buffer doesn't disappear by adding these lines to your guest's config file:

    on_crash = 'preserve'
    on_poweroff = 'preserve'

[mirage-trace-viewer][] contains tools for saving and viewing traces, as well as a `metadata` description of the format, which allows the traces to be read using e.g. [babeltrace][].


## Recording extra trace data

Programs and libraries are encouraged to record extra useful information using the `MProf` module.
As using these functions generally has no overhead when a regular Lwt is used, there should be no need to use conditional compilation for this.
See the `MProf.Trace` and `MProf.Counter` modules for documentation about what can be recorded.


[ctf]: http://www.efficios.com/ctf
[babeltrace]: http://www.efficios.com/babeltrace
[mirage-trace-viewer]: https://github.com/talex5/mirage-trace-viewer
## mirage-fs — MirageOS signatures for filesystem devices

[![Build Status](https://travis-ci.org/mirage/mirage-fs.svg?branch=master)](https://travis-ci.org/mirage/mirage-fs)

mirage-fs provides the `[Mirage_fs.S][fs]` and `[Mirage_fs_lwt.S]` signatures
the MirageOS filesystem devices should implement.

[fs]: http://mirage.github.io/mirage-fs/Mirage_fs.html
[fslwt]: http://mirage.github.io/mirage-fs/Mirage_fs_lwt.html

## Installation

mirage-fs can be installed with `opam`:

    opam install mirage-fs

If you don't use `opam` consult the [`opam`](opam) file for build
instructions.

## Documentation

The documentation and API reference is generated from the source
interfaces. It can be consulted [online][doc] or via `odig doc
mirage-fs`.

[doc]: https://mirage.github.io/mirage-fs/

## License

mirage-fs is distributed under the ISC license, see the [LICENSE.md] file for its text.

[LICENSE.md]: ./LICENSE.md
mirage-fs-unix -- passthrough filesystem for MirageOS on Unix
-------------------------------------------------------------

This is a pass-through Mirage filesystem to an underlying Unix directory.  The
interface is intended to support eventual privilege separation (e.g. via the
Casper daemon in FreeBSD 11).

The current version supports the `Mirage_fs.S` and `Mirage_fs_lwt.S` signatures
defined in the `mirage-fs` package.

* WWW: <https://mirage.io>
* E-mail: <mirageos-devel@lists.xenproject.org>
mirage-channel — Buffered channels for MirageOS FLOW types
----------------------------------------------------------
%%VERSION%%

Channels are buffered reader/writers built on top of unbuffered `FLOW`
implementations.

Example:

```ocaml
module Channel = Channel.Make(Flow)
...
Channel.read_exactly ~len:16 t
>>= fun bufs -> (* read header of message *)
let payload_length = Cstruct.(LE.get_uint16 (concat bufs) 0) in
Channel.read_exactly ~len:payload_length t
>>= fun bufs -> (* payload of message *)

(* process message *)

Channel.write_buffer t header;
Channel.write_buffer t payload;
Channel.flush t
>>= fun () ->
```

mirage-channel is distributed under the ISC license.

* Homepage: https://github.com/mirage/mirage-channel  
* Issue: <https://github.com/mirage/mirage-channel/issues>
* Contact: `<mirageos-devel@lists.xenproject.org>`

## Installation

mirage-channel can be installed with `opam`:

    opam install channel

If you don't use `opam` consult the [`opam`](opam) file for build
instructions.

## Documentation

The documentation and API reference is automatically generated by
`ocamldoc` from the interfaces. It can be consulted [online][doc]
and there is a generated version in the `doc` directory of the
distribution.

[doc]: http://docs.mirage.io/channel

## Sample programs

If you installed mirage-channel with `opam` sample programs are located in
the directory `opam config var channel:doc`.

In the distribution sample programs and tests are located in the
[`test`](test) directory of the distribution. They can be built with:

    ./build test

The resulting binaries are in `_build/test`.

- `test.native` tests the library, nothing should fail.

## mirage-random -- Random signatures for MirageOS

mirage-random defines [Mirage_random.S][1] and [Mirage_random.C][2]
the signature for random-related devices for MirageOS.

[1]: https://mirage.github.io/mirage-random/Mirage_random.S.html
[2]: https://mirage.github.io/mirage-random/Mirage_random.C.html

### Installation

`mirage-random` can be installed with `opam`:

    opam install mirage-random

If you don't use `opam` consult the [`opam`](opam) file for build
instructions.

### Documentation

The documentation and API reference is automatically generated by
`ocamldoc` from the interfaces. It can be consulted [online][2].

[2]: https://mirage.github.io/mirage-random/Mirage_random.html
## mirage-protocols — MirageOS signatures for network protocols

mirage-protocols provides a set of module types which libraries intended to be used as MirageOS network implementations should implement.

The set of protocols defined is:

[Mirage_protocols.ETHIF](ethif) and [Mirage_protocols_lwt.ETHIF](ethif-lwt)
[Mirage_protocols.ARP](arp) and [Mirage_protocols_lwt.ARP](arp-lwt)
[Mirage_protocols.IP](ip) and [Mirage_protocols_lwt.IP](ip-lwt), via [Mirage_protocols_lwt.IPV4](ipv4-lwt) and [Mirage_protocols_lwt.IPV6](ipv6-lwt)
[Mirage_protocols.ICMP](icmp) and [Mirage_protocols_lwt.ICMP](icmp-lwt), via [Mirage_protocols_lwt.ICMPV4](icmpv4-lwt)
[Mirage_protocols.UDP](udp) and [Mirage_protocols_lwt.UDP](udp-lwt), via [Mirage_protocols_lwt.UDPV4](udpv4-lwt) and [Mirage_protocols_lwt.UDPV6](udpv6-lwt)
[Mirage_protocols.TCP](tcp) and [Mirage_protocols_lwt.TCP](tcp-lwt), via [Mirage_protocols_lwt.TCPV4](tcpv4-lwt) and [Mirage_protocols_lwt.TCPV6](tcpv6-lwt)

mirage-protocols is distributed under the ISC license.

## Installation

mirage-protocols can be installed with `opam`:

    opam install mirage-protocols

If you don't use `opam` consult the [`opam`](opam) file for build
instructions.

## Documentation

The documentation and API reference is generated from the source
interfaces. It can be consulted [online][doc] or via `odig doc
mirage-protocols`.

[doc]: https://mirage.github.io/mirage-protocols/
## mirage-console -- implementations of Mirage consoles, for Unix and Xen

%%VERSION%%
 
The Unix version of the console currently uses standard output. The code is in

  unix/console.{ml,mli}

The Xen kernel version of the console uses the primary PV console ring. The
code is in

  xen/console.{ml,mli}

There is also a Unix userspace utility which creates and services Xen consoles
("console backends"):

Connect a console to a VM like this:

```
[root@st30 ~]# ./mirage-console connect trusty
Operating on VM domain id: 19
Creating device 1 (linux device /dev/tty1)
{ ref = 128; event_channel = 13 }
```

Then inside the guest:

```
[root@trusty ~]# cat > /dev/hvc1
hello
there
```

And observe in dom0:

```
hello
there
```

Then hit Control+C and it all cleans up.
This shows how to customise the manifestation of a Xen console device in Linux.

Install the udev rule:
```
cp 99-xen-console.rules /etc/udev/rules.d/
cp xenconsole-setup-tty /lib/udev
```

Attach a console with a name:
```
mirage-console connect trusty --name myspecialname
```

Observe the console has been created in /dev/xenconsole/myspecialname
## mirage-net-unix -- Unix implementation of the Mirage NETWORK interface.

This interface exposes raw Ethernet frames using `ocaml-tuntap`,
suitable for use with an OCaml network stack such as the one
found at <https://github.com/mirage/mirage-tcpip>.
## mirage-block-unix -- MirageOS disk block driver for Unix

[![Build Status](https://travis-ci.org/mirage/mirage-block-unix.png?branch=master)](https://travis-ci.org/mirage/mirage-block-unix) [![Coverage Status](https://coveralls.io/repos/mirage/mirage-block-unix/badge.png?branch=master)](https://coveralls.io/r/mirage/mirage-block-unix?branch=master)

Unix implementation of the Mirage `BLOCK_DEVICE` interface.

This module provides raw I/O to files and block devices with as little
caching as possible.

E-mail: <mirageos-devel@lists.xenproject.org>
## mirage-stack — MirageOS signatures for network stacks

mirage-stack provides a set of module types which libraries intended to be used as MirageOS network stacks should implement.

The set of protocols defined is:

[Mirage_stack.STACKV4](stackv4) and [Mirage_stack_lwt.STACKV4](stackv4-lwt)

mirage-stack is distributed under the ISC license.

[stackv4]: http://docs.mirage.io/mirage-stack/Mirage_stack/module-type-V4/index.html
[stackv4-lwt]: http://docs.mirage.io/mirage-stack-lwt/Mirage_stack_lwt/module-type-V4/index.html

## Installation

mirage-stack can be installed with `opam`:

    opam install mirage-stack

If you don't use `opam` consult the [`opam`](opam) file for build
instructions.

## Documentation

[![Build Status](https://travis-ci.org/mirage/mirage-stack.svg?branch=v1.1.0)](https://travis-ci.org/mirage/mirage-stack)

The documentation and API reference is generated from the source
interfaces. It can be consulted [online][doc] or via `odig doc
mirage-stack`.

[doc]: http://docs.mirage.io/index.html#package-mirage-stack
## mirage-clock -- libraries and module types for portable clocks

This library implements portable support for an operating system timesource
that is compatible with the [MirageOS](https://mirage.io) library interfaces
found in: <https://github.com/mirage/mirage>

It implements an `MCLOCK` module that represents a monotonic timesource
since an arbitrary point, and `PCLOCK` which counts time since the Unix
epoch.

The following sources are used:

* The Unix version uses `gettimeofday` or `clock_gettime`, depending on
  which OS is in use (see [clock_stubs.c](https://github.com/mirage/mirage-clock/blob/master/unix/clock_stubs.c)).
* The freestanding version uses the paravirtual clock source from the hypervisor.
## mirag-flow -- Flow implementations and combinators for MirageOS

This repo contains generic operations over Mirage `FLOW` implementations.

Please consult [the API documentation](https://mirage.github.io/mirage-flow/index.html).

### Example usage

In a top-level like utop:
```ocaml
# #require "mirage-flow";;
# #require "mirage-clock-unix";;
# #require "lwt.syntax";;

# let a = Mirage_flow.Fun.(make ~input:(input_string "hellooooo") ());;
val a : Mirage_flow.Fun.flow = <abstr>

# let buffer = String.make 20 ' ';;
val buffer : bytes = "                    "
# let b = Mirage_flow.Fun.(make ~output:(output_string buffer) ());;
val b : Mirage_flow.Fun.flow = <abstr>

# lwt results = Mirage_flow.copy (module Clock) (module Mirage_flow.Fun) a (module Mirage_flow.Fun) b ();;
val results : [ `Error of [ `Msg of bytes ] | `Ok of Mirage_flow.CopyStats.t ] =  `Ok {Mirage_flow.CopyStats.read_bytes = 9L; read_ops = 1L; write_bytes = 9L; write_ops = 1L; duration = 6.9141387939453125e-06}
# buffer;;
- : bytes = "hellooooo           "
```
## mirage-time -- Time operations for MirageOS

mirage-time defines [Mirage_time.S][1] the signature for
time-related operations for MirageOS.

[1]: https://mirage.github.io/mirage-time/Mirage_time.S.html

### Installation

`mirage-time` can be installed with `opam`:

    opam install mirage-time

If you don't use `opam` consult the [`opam`](opam) file for build
instructions.

### Documentation

The documentation and API reference is automatically generated by
`ocamldoc` from the interfaces. It can be consulted [online][2].

[2]: https://mirage.github.io/mirage-time/Mirage_time.html
