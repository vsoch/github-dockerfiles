Dumbster was an open source project hosted at Sourceforge. Unfortunately, that project has not had any commits
to it since 2005. The code was copied here to be able to address a race condition in SimpleSmtpServer.

Dumbster is Copyright 2004 Jason Paul KitchenThis directory is mainly for storing configuration files used in various unit tests. As such, there are a few things
provided for your convenience in writing and maintaining unit tests.

Running Unit Tests
------------------

First, make sure you've recently run `mvn clean install` in `log4j-api` to get an up to date dependency. Then you can
run `mvn test` to run unit tests, or run `mvn verify` to run both unit tests and integration/performance tests.

Test Plugins
------------

Included are various Log4j plugins that are only useful for writing tests. These test plugins are automatically made
available to test classes. For instance, to use the ListAppender:

    <Configuration>
      <Appenders>
        <List name="List"/>
      </Appenders>
      <Loggers>
        <Logger name="org.apache.logging.log4j" level="debug">
          <AppenderRef ref="List"/>
        </Logger>
      </Loggers>
    </Configuration>

Note that if you don't specify a layout for a ListAppender, your log messages will be stored in a list of LogEvents.
With a layout, your log messages will be stored in a list of strings. For more details, check out the class
`org.apache.logging.log4j.test.appender.ListAppender`.

Specifying Configuration Files in JUnit Tests
---------------------------------------------

Added in JUnit 4.9, the concept of test fixtures (i.e., the `@Before`, `@After`, etc. methods) has been expanded into
the concept of test rules. A test rule is a reusable test fixture such as the `TemporaryFolder` JUnit rule for creating
temporary directories and files on a test-by-test (or suite) basis. To use a test rule, you need to use the
`@Rule` or `@ClassRule` annotation to get a method-level or class-level test fixture respectively. For instance,
suppose your test class uses the file named `MyTestConfig.xml` in this directory. Then you can use the following rule
in your test class:

    @Rule
    public InitialLoggerContext init = new InitialLoggerContext("MyTestConfig.xml");

    @Test
    public void testSomeAwesomeFeature() {
        final LoggerContext ctx = init.getContext();
        final Logger logger = init.getLogger("org.apache.logging.log4j.my.awesome.test.logger");
        final Configuration cfg = init.getConfiguration();
        final ListAppender app = init.getListAppender("List");
        logger.warn("Test message");
        final List<LogEvent> events = app.getEvents();
        // etc.
    }

Using this rule will automatically create a new LoggerContext using the specified configuration file for you to
retrieve via the `getContext()` method shown above. After the method finishes (or if you use `@ClassRule` and make
the field `static`), the `LoggerContext` is automatically stopped. No longer do you need to set any system properties,
reset the `StatusLogger` configuration, and all that other fun boilerplate code.

Cleaning Up Test Log Files
--------------------------

The `CleanFiles` rule is also available to automatically delete a list of files after every test.

    @Rule
    public CleanFiles files = new CleanFiles("target/file1.log", "target/file2.log", "more files");

You can specify either a list of strings or a list of `File`s.

If you have any questions about writing unit tests, feel free to send an email to the dev mailing list, or check out
the JUnit documentation over at junit.org.

Specifying Test Categories
--------------------------

If your test is something more than just a unit test, it's usually a good idea to add a JUnit category to it. This
can be done at the class or method level:

    @Category(PerformanceTests.class)
    @Test
    public void testRandomAccessFileLogging() {
        // ...
    }

Various pre-defined categories are defined in `org.apache.logging.log4j.categories` in `log4j-core` test.
If you only want to run your test as part of the `maven-failsafe-plugin` integration tests phase, then simply name
your test `FooIT` instead of `FooTest` for automatic configuration.
This directory contains files to test the TLSSyslogAppender and its helpers classes. Please don't remove them.

All certificates are signed with log4j2-cacert.pem, which is the root certificate (you can find help here to install it:
http://askubuntu.com/questions/73287/how-do-i-install-a-root-certificate). The client.log4j2-keystore.jks contains the
client private key, the corresponding certificate (client.log4j2-crt.pem) and the root CA certificate 
(log4j2-cacert.pem). The root CA certificate is also imported into the truststore.jks.

The server.log4j2-key.pem is a private key generated by OpenSSL, which can be used as a server private key. The 
server.log4j2-crt.pem is the corresponding certificate signed with log4j2-cacert.pem.

All JKS files are created with password "changeit".

The syslog-ng-sample.conf file contains the relevant part of a sample syslog-ng configuration with TLS support.
Sample to connect to a Flume Agent via Avro using the FlumeAppender.

This sample uses the classes in the sample flume-common project. It will randomly pick from the events defined there
and send them to Flume. At the same time it will intermix some random non-audit events.

To run this sample:
1. Run "mvn install" on the flume-common project.
2. Download and install Flume.
3. Copy the flume-conf.properties in src/main/resources/flume/conf to the conf directory of where Flume was installed.
4. In a terminal window start flume using "bin/flume-ng agent --conf ./conf/ -f conf/flume-conf.properties -Dflume.root.logger=DEBUG,console -n agent"
5. Verify Flume started and configured an Avro source, a memory channel and a logger sink by reviewing the startup log.
6. In a separate terminal window run "mvn jetty:run" in this project.
7. Verify the Flume appender connected to the Flume agent by finding "Starting FlumeAvroManager FlumeAvro[localhost:8800]"
   in the jetty log and that there are no exceptions and also by seeing something like
    "/127.0.0.1:53351 => /127.0.0.1:8800] OPEN" in the Flume log.
8. In a separate terminal window in the project directory run "tail -f target/logs/app.log" to see the application
   generate non-audit logs.
9. In the browser go to url "http://localhost:8080/flumeAgent/start.do". A started message should appear on the screen.
10. After verifying logs are being written click on the Stop button in the browser page.

Note that the Flume agent must be started for the FlumeAppender to successfully start. If the Flume agent is stopped
an exception will be thrown for each event that occurs while the agent is down. When the agent restarts the
appender will automatically reconnect.

The output from the Flume agent will include the generated Flume events. Since the events are sent individually
Avro will print the full event and Flume will print a hex dump of the first few bytes of the event.Sample to utilize an embedded Flume agent to connect to a remote Flume Agent via Avro.

This sample uses the classes in the sample flume-common project. It will randomly pick from the events defined there
and send them to Flume. At the same time it will intermix some random non-audit events.

To run this sample:
1. Run "mvn install" on the log4j-samples-flume-common project.
2. Download and install Flume.
3. Copy the flume-conf.properties in src/main/resources/flume/conf to the conf directory of where Flume was installed.
4. In a terminal window start flume using "bin/flume-ng agent --conf ./conf/ -f conf/flume-conf.properties -Dflume.root.logger=DEBUG,console -n agent"
5. Verify Flume started and configured an Avro source, a memory channel and a logger sink by reviewing the startup log.
6. In a separate terminal window run "mvn jetty:run" in this project.
7. Verify the Flume appender connected to the Flume agent by finding "Started SelectChannelConnector@0.0.0.0:8080"
   in the jetty log and that there are no exceptions and also by seeing something like
    "/127.0.0.1:53351 => /127.0.0.1:8800] OPEN" in the Flume log.
8. In a separate terminal window in the project directory run "tail -f target/logs/app.log" to see the application
   generate non-audit logs.
9. In the browser go to url "http://localhost:8080/flumeAgent/start.do". A started message should appear on the screen.
10. After verifying logs are being written click on the Stop button in the browser page.

The output from the Flume agent will include the generated Flume events. Since the events are sent by the embedded
Flume agent in a batch the Flume agent will only print a hex dump of the first few bytes of the event.